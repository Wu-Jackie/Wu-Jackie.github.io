<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Jackie">
    
    <title>
        
            经典排序算法 |
        
        Jackie&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logoow.svg">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
        
            
                
<link rel="stylesheet" href="/css/hide.css">

            
        
    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"Jackie's Blog","author":"Jackie","avatar":"/images/nemo.svg","logo":"/images/logoow.svg","favicon":"/images/logoow.svg"},"menu":{"home":"/ || fa-solid fa-home","archives":"/archives || fa-solid fa-box-archive","tags":"/tags || fa-solid fa-tags","links":"/links || fa-solid fa-link","about":"/about || fa-solid fa-user-graduate"},"first_screen":{"enable":true,"background_img":"/images/bg2.svg","background_img_dark":"/images/bg2.svg","description":"Welcome To My Blog! || 無限進步！","hitokoto":false},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":true,"percent":true,"hide_header":true},"home":{"announcement":"不定时更新博客，欢迎催更","category":true,"tag":true,"post_datetime":"updated","post_datetime_format":"YYYY年MM月DD日"},"post":{"author_badge":{"enable":false,"level_badge":false,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":true,"min2read":true},"datetime_format":"YYYY年MM月DD日","copyright_info":false,"share":true,"reward":{"enable":false,"img_link":null,"text":null,"icon":null},"img_align":"center"},"code_block":{"tools":{"enable":true,"style":"mac"},"highlight_theme":"default"},"toc":{"enable":true,"number":false,"expand_all":false,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":false,"site_uv":false,"site_pv":false,"page_pv":false}},"local_search":{"enable":true,"preload":true},"comment":{"enable":true,"use":"waline","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.39"},"waline":{"server_url":"waline-for-blog-psi.vercel.app","reaction":false,"version":"3.3.2","options":{"login":"force","copyright":false}},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":true},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":true},"footer":{"since":2022,"word_count":true,"site_deploy":{"enable":false,"provider":"github","url":null},"record":{"enable":false,"list":[{"code":null,"link":null}]}},"inject":{"enable":true,"css":["/css/hide.css"],"js":[null]},"root":"","source_data":{"links":[{"title":"Web"},{"name":"小小邵同学","link":"https://swq111.online/","description":null,"avatar":"https://swq111.online/wp-content/uploads/2024/01/3.jpg"},{"name":"yxhhyy","link":"https://yxhhyy.github.io/","description":null,"avatar":"https://yxhhyy.github.io/images/1.jpg"},{"title":"Pwn"},{"name":"jwjlearning","link":"https://jwjlearning.github.io/","description":null,"avatar":"https://jwjlearning.github.io/img/avatar.png"},{"name":"yw-by","link":"https://yw-by.github.io/","description":null,"avatar":"https://yw-by.github.io/images/avatar.jpg"},{"title":"Reverse"},{"name":"FeowmAomr","link":"https://feowmaomr.github.io/","description":null,"avatar":"https://FeowmAomr.github.io/picx-images-hosting/Aomr.webp"},{"name":"Yigod","link":"https://hexo-beta-fawn.vercel.app/","description":null,"avatar":"https://hexo-beta-fawn.vercel.app/images/avatar.jpg"},{"title":"Crypto"},{"name":"Waiting a destined person","link":"\\#","description":null,"avatar":"https://wu-jackie.github.io/images/nemo.svg"},{"title":"Embedded"},{"name":"Taboo","link":"http://taboo-sdh.top/","description":null,"avatar":"http://taboo-sdh.top/wp-content/uploads/2024/04/1712235965-%E6%A0%97%E5%AD%90%E7%90%83%E5%A4%B4%E5%83%8F.jpg"}]},"version":"4.2.5"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left flex-start border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logoow.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               Jackie&#39;s Blog
            </a>
        </div>

        <div class="right border-box">
            <div class="pc border-box">
                <ul class="menu-list border-box">
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-home"></i>
                                
                                首页
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/archives">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-box-archive"></i>
                                
                                归档
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/tags">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-tags"></i>
                                
                                标签
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/links">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-link"></i>
                                
                                友链
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/about">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-user-graduate"></i>
                                
                                关于
                                
                            </a>
                            
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="menu-text-color fas search fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile border-box flex-start">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list border-box">
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-home"></i>
                                </span>
                            
                            首页
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/archives">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-box-archive"></i>
                                </span>
                            
                            归档
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/tags">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-tags"></i>
                                </span>
                            
                            标签
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/links">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-link"></i>
                                </span>
                            
                            友链
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/about">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-user-graduate"></i>
                                </span>
                            
                            关于
                        </a>
                        
                    </label>
                    
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        经典排序算法
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/nemo.svg">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">Jackie</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2024年03月07日</span>
            </span>

            
                <span class="meta-info-item post-update-date">
                    <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                    <span class="datetime" data-updated="Mon Jan 26 2026 11:57:13 GMT+0800">2026年01月26日</span>
                </span>
            
        

        

        
            <span class="post-tag meta-info-item border-box">
                <ul class="post-tag-ul">
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/Summary/">Summary</a></li>
                        
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/LeetCode/">LeetCode</a></li>
                        
                    
                </ul>
            </span>
        

        
        
            <span class="meta-info-item post-wordcount">
                <i class="icon fas fa-file-word"></i>&nbsp;<span>6.5k 字</span>
            </span>
        
        
            <span class="meta-info-item post-min2read">
                <i class="icon fas fa-clock"></i>&nbsp;<span>26 分钟</span>
            </span>
        
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body ">
                    

                    
                         <h1 id="经典排序算法"><a class="markdownIt-Anchor" href="#经典排序算法"></a> 经典排序算法</h1>
<p><a class="link"   target="_blank" rel="noopener" href="https://visualgo.net/en" >可视化数据结构和算法<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" >旧金山大学数据结构可视化<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.hello-algo.com/" >Hello算法<i class="fas fa-external-link-alt"></i></a></p>
<p>本文部分内容参考自《2026年数据结构考研复习指导》王道论坛著</p>
<blockquote>
<ul>
<li>
<p>本文凡是没有特殊注明的，通常默认排序结果为非递减有序序列</p>
</li>
<li>
<p>每小节的时间复杂度表示均为平均时间复杂度</p>
</li>
<li>
<p>为使代码更简洁，使用函数swap()两两交换元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="各个算法时间复杂度"><a class="markdownIt-Anchor" href="#各个算法时间复杂度"></a> 各个算法时间复杂度</h1>
<p><img  
                       lazyload
                       alt="image"
                       data-src="%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png"
                        alt="时间复杂度" 
                 ></p>
<p>村里有两只做事很稳的动物：<strong>插帽龟</strong>和<strong>统计鸡</strong>。插帽龟喜欢去插人家堆起来的帽子，统计鸡喜欢做加减乘除。但有天插帽龟挑选帽子插的时候，恩姓长老看见就慌了，恩老大喊：“快点归还给堆”</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="%E5%BF%AB%E8%AE%B0%E8%A7%A3%E6%9E%90.png"
                        alt="快记解析" 
                 ></p>
<h1 id="一-直接插入排序direct-insertion-sort"><a class="markdownIt-Anchor" href="#一-直接插入排序direct-insertion-sort"></a> 一、直接插入排序（Direct Insertion Sort）</h1>
<h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2>
<p>每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成</p>
<h2 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h2>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<h2 id="动画演示"><a class="markdownIt-Anchor" href="#动画演示"></a> 动画演示</h2>
<p><img  
                       lazyload
                       alt="image"
                       data-src="%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif"
                        alt="插入排序" 
                 ></p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(ElemType A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;<span class="comment">//依次将A[2]~A[n]插入前面已排序序列</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;<span class="comment">//A[i]关键码小于其前驱，将A[i]插入有序表</span></span><br><span class="line">            A[<span class="number">0</span>]=A[i];<span class="comment">//复制为哨兵，A[0]不存放元素</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;A[<span class="number">0</span>]&lt;A[j];--j)&#123;<span class="comment">//从后往前查找插入位置</span></span><br><span class="line">                A[j+<span class="number">1</span>]=A[j];<span class="comment">//向后挪位</span></span><br><span class="line">            &#125;</span><br><span class="line">            A[j+<span class="number">1</span>]=A[<span class="number">0</span>];<span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n<sup>2</sup>)</li>
<li>空间复杂度：O(1)</li>
<li>稳定</li>
<li>适用性：适用于顺序存储和链式存储的线性表，采用链式存储时无须移动元素</li>
</ul>
<h1 id="二-折半插入排序binary-insertion-sort"><a class="markdownIt-Anchor" href="#二-折半插入排序binary-insertion-sort"></a> 二、折半插入排序（Binary Insertion Sort）</h1>
<h2 id="原理-2"><a class="markdownIt-Anchor" href="#原理-2"></a> 原理</h2>
<p>通过二分查找在已排序区间中快速定位插入位置，再移动元素完成插入</p>
<h2 id="步骤-2"><a class="markdownIt-Anchor" href="#步骤-2"></a> 步骤</h2>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素作为待插入元素key</li>
<li>在已排序的子序列（A[1…i-1]）中使用二分查找确定key的插入位置pos</li>
<li>将 pos位置及其后的所有元素依次向后移动一位</li>
<li>将 key插入到pos位置</li>
<li>重复步骤2~5</li>
</ol>
<h2 id="动画演示-2"><a class="markdownIt-Anchor" href="#动画演示-2"></a> 动画演示</h2>
<p>参考以下三个链接</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://visualgo.net/en" >可视化数据结构和算法<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" >旧金山大学数据结构可视化<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.hello-algo.com/" >Hello算法<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BinaryInsertSort</span><span class="params">(ElemType A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;<span class="comment">//依次将A[2]~A[n]插入前面的已排序序列</span></span><br><span class="line">        A[<span class="number">0</span>]=A[i];<span class="comment">//将A[i]暂存到A[0]</span></span><br><span class="line">        low=<span class="number">1</span>;<span class="comment">//设置折半查找的范围</span></span><br><span class="line">        high=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;<span class="comment">//折半查找（默认递增有序）</span></span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;<span class="comment">//取中间点</span></span><br><span class="line">            <span class="keyword">if</span>(A[mid]&gt;A[<span class="number">0</span>])&#123;<span class="comment">//查找左半子表</span></span><br><span class="line">                high=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;<span class="comment">//查找右半子表</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;--j)&#123;</span><br><span class="line">            A[i+<span class="number">1</span>]=A[j];<span class="comment">//统一后移元素，空出插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        A[high+<span class="number">1</span>]=A[<span class="number">0</span>];<span class="comment">//插入操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n<sup>2</sup>)</li>
<li>空间复杂度：O(1)</li>
<li>稳定</li>
<li>适用性：仅适用于顺序存储的线性表</li>
</ul>
<h1 id="三-希尔排序shell-sort"><a class="markdownIt-Anchor" href="#三-希尔排序shell-sort"></a> 三、希尔排序（Shell Sort）</h1>
<h2 id="原理-3"><a class="markdownIt-Anchor" href="#原理-3"></a> 原理</h2>
<p>希尔排序又叫<strong>缩小增量排序</strong>，也是一种插入排序方法（通常快于直接插入法），具体做法是将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序</p>
<h2 id="步骤-3"><a class="markdownIt-Anchor" href="#步骤-3"></a> 步骤</h2>
<ol>
<li>取一个小于n的增量d<sub>1</sub>，把表中的全部记录分成d<sub>1</sub>组，所有距离为d<sub>1</sub>的倍数的记录放在同一组，在各组内进行直接插入排序</li>
<li>取第二个增量d<sub>2</sub>&lt;d<sub>1</sub>，重复上述过程</li>
<li>直到所取到的d<sub>i</sub>=1，即所有记录已放在同一组中，再进行直接插入排序</li>
</ol>
<h2 id="动画演示-3"><a class="markdownIt-Anchor" href="#动画演示-3"></a> 动画演示</h2>
<p><img  
                       lazyload
                       alt="image"
                       data-src="%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif"
                        alt="希尔排序" 
                 ></p>
<h2 id="代码实现-3"><a class="markdownIt-Anchor" href="#代码实现-3"></a> 代码实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(ElemType A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> d,i,j;</span><br><span class="line">    <span class="keyword">for</span>(d=n/<span class="number">2</span>;d&gt;=<span class="number">1</span>;d=d/<span class="number">2</span>)&#123;<span class="comment">//此处以n/2为增量</span></span><br><span class="line">        <span class="keyword">for</span>(i=d+<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;A[i-d])&#123;<span class="comment">//需将A[i]插入有序增量子表</span></span><br><span class="line">                A[<span class="number">0</span>]=A[i];<span class="comment">//暂存在A[0]</span></span><br><span class="line">                <span class="keyword">for</span>(j=i-d;j&gt;<span class="number">0</span>&amp;&amp;A[<span class="number">0</span>]&lt;A[j];j-=d)&#123;</span><br><span class="line">                    A[j+d]=A[j];<span class="comment">//记录后移，查找插入位置（先内后外）</span></span><br><span class="line">                &#125;</span><br><span class="line">                A[j+d]=A[<span class="number">0</span>];<span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n<sup>1.3</sup>)</li>
<li>空间复杂度：O(1)</li>
<li>不稳定</li>
<li>适用性：仅适用于顺序存储的线性表</li>
</ul>
<h1 id="四-冒泡排序bubble-sort"><a class="markdownIt-Anchor" href="#四-冒泡排序bubble-sort"></a> 四、冒泡排序（Bubble Sort）</h1>
<h2 id="原理-4"><a class="markdownIt-Anchor" href="#原理-4"></a> 原理</h2>
<p>从后往前（或从前往后）两两比较相邻元素的值，若为逆序（A[i-1]&gt;A[i]）则交换它们，直到序列比较完，关键字最小的元素如气泡一般逐渐往上“漂浮”至“水面”（或关键字最大的元素如石头一般下沉至水底），每趟冒泡的结果是把序列中的最小元素（或最大元素）放到了序列的最终位置，直到所有元素排序完成</p>
<blockquote>
<p>冒泡排序中所产生的有序子序列一定是全局有序的（不同于直接插入排序），即有序子序列中的所有元素的关键字一定小于（或大于）无序子序列中所有元素的关键字，这样每趟排序都会将一个元素放置到其最终的位置上</p>
</blockquote>
<h2 id="步骤-4"><a class="markdownIt-Anchor" href="#步骤-4"></a> 步骤</h2>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数</li>
<li>针对所有的元素重复步骤1~2，除了最后一个元素，直到排序完成</li>
</ol>
<h2 id="动画演示-4"><a class="markdownIt-Anchor" href="#动画演示-4"></a> 动画演示</h2>
<p><img  
                       lazyload
                       alt="image"
                       data-src="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif"
                        alt="冒泡排序" 
                 ></p>
<h2 id="代码实现-4"><a class="markdownIt-Anchor" href="#代码实现-4"></a> 代码实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(ElemType A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;<span class="comment">//表示本趟冒泡是否发生交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;i;j--)&#123;<span class="comment">//一趟冒泡过程</span></span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>]&gt;A[j])&#123;<span class="comment">//若为逆序</span></span><br><span class="line">                swap(A[j<span class="number">-1</span>],A[j]);<span class="comment">//使用封装的swap函数交换</span></span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag=<span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;<span class="comment">//本趟遍历后没有发生交换，说明已经有序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n<sup>2</sup>)</li>
<li>空间复杂度：O(1)</li>
<li>稳定</li>
<li>适用性：适用于顺序存储和链式存储的线性表</li>
</ul>
<h1 id="五-快速排序quick-sort"><a class="markdownIt-Anchor" href="#五-快速排序quick-sort"></a> 五、快速排序（Quick Sort）</h1>
<h2 id="原理-5"><a class="markdownIt-Anchor" href="#原理-5"></a> 原理</h2>
<p>在待排序表L[1…n]中任取一个元素pivot作为枢轴（或称基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分L[1…k-1]和L[k+1…n]，使得L[1…k-1]中的所有元素小于pivot，L[k+1…n]中的所有元素大于或等于pivot，则pivot放在了其最终位置L(k)上，分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或为空位置，即所有元素放在了其最终位置上</p>
<h2 id="步骤-5"><a class="markdownIt-Anchor" href="#步骤-5"></a> 步骤</h2>
<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ol>
<li>选取基准元素（pivot）</li>
<li>划分，根据选取的pivot将数组划分成小于pivot的部分和大于pivot的部分</li>
<li>递归求解小于pivot和大于pivot的部分</li>
</ol>
<p>基准元素可以选择第一个元素或者最后一个元素即Lomuto Partition Scheme，但是这样划分成两部分的时候有一部分是空的，这样可能造成死循环；从中间划分可以保证两部分都不为空，即Hoare Partition Scheme</p>
<blockquote>
<p>对n个元素进行第一趟快速排序后，会确定一个基准元素，根据这个基准元素在数组中的位置，有两种情况：</p>
<p>①基准元素在数组的首端或尾端，接下来对剩下的n-1个元素构成的子序列进行第二趟快速排序，再确定一个基准元素。这样，在两趟排序后就至少能确定两个元素的最终位置，其中至少有一个元素是在数组的首端或尾端</p>
<p>②基准元素不在数组的首端或尾端，第二趟快速排序对基准元素划分开的两个子序列分别进行一次划分，两个子序列各确定一个基准元素。这样，两趟排序后就至少能确定三个元素的最终位置</p>
</blockquote>
<h2 id="动画演示-5"><a class="markdownIt-Anchor" href="#动画演示-5"></a> 动画演示</h2>
<p><img  
                       lazyload
                       alt="image"
                       data-src="%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif"
                        alt="快速排序" 
                 ></p>
<h2 id="代码实现-5"><a class="markdownIt-Anchor" href="#代码实现-5"></a> 代码实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;<span class="comment">//递归跳出条件</span></span><br><span class="line">        <span class="type">int</span> pivotpos=Partition(A,low,high);<span class="comment">//划分</span></span><br><span class="line">        QuickSort(A,low,pivotpos<span class="number">-1</span>);<span class="comment">//依次对两个子表进行递归排序</span></span><br><span class="line">        QuickSort(A,pivotpos+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;<span class="comment">//划分操作，将表A[low...high]划分为满足上述条件的两个子表</span></span><br><span class="line">    ElemType pivot=A[low];<span class="comment">//将当前表中第一个元素设为枢轴，对表进行划分</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;<span class="comment">//循环跳出条件</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[high]&gt;=pivot)&#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        A[low]=A[high];<span class="comment">//将比枢轴小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[low]&lt;=pivot)&#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        A[high]=A[low];<span class="comment">//将比枢轴大的元素移动到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low]=pivot;<span class="comment">//枢轴元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;<span class="comment">//返回存放枢轴的最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(nlog<sub>2</sub>n)</li>
<li>空间复杂度：O(log<sub>2</sub>n)</li>
<li>不稳定</li>
<li>适用性：适用于顺序存储的线性表</li>
</ul>
<blockquote>
<ul>
<li>快速排序的边界问题</li>
</ul>
<p>快排属于分治算法，最怕的就是n分成0和n，或n分成n和0，导致死循环</p>
<ol>
<li>
<p><strong>以j为划分时，x不能选q[r]（若以i为划分，则x不能选q[l]）</strong></p>
<p>假设x=q[r]</p>
<p>关键句子quick_sort(q,l,j),quick_sort(q,j+1,r)</p>
<p>由于j的最小值是l，所以q[j+1…r]不会造成无限划分</p>
<p>但q[l…j]（即quick_sort(q,l,j)）却可能造成无限划分，因为j可能为r</p>
<p>举例来说，若x选为q[r]，数组中q[l…r-1]&lt;x，</p>
<p>那么这一轮循环结束时i=r,j=r，显然会造成无限划分</p>
</li>
<li>
<p><strong>do i++;while q[i]&lt;x和do j–;whileq[j]&gt;x不能用q[i]&lt;=x和q[j]&gt;=x</strong></p>
<p>假设q[l…r]全相等</p>
<p>则执行完do i++;while(q[i]&lt;=x);之后，i会自增到r+1</p>
<p>然后继续执行q[i]&lt;=x判断条件，造成数组下标越界但这貌似不会报错但这貌似不会报错</p>
<p>并且如果之后的q[i]&lt;=x此时i&gt;r此时i&gt;r条件也不幸成立，</p>
<p>就会造成一直循环下去亲身实验亲身实验，造成内存超限MemoryLimitExceeded</p>
</li>
<li>
<p><strong>if(i&lt;j)swap(q[i],q[j])能否使用i&lt;=j</strong></p>
<p>可以使用if(i&lt;=j)swap(q[i],q[j])</p>
<p>因为i=j时，交换一下q[i]，q[j]无影响，因为马上就会跳出循环了</p>
</li>
<li>
<p><strong>最后一句能否改用quick_sort q,l,j−1,quick_sort q,j,r作为划分用i做划分时也是同样的道理，用i做划分时也是同样的道理，</strong></p>
<p>不能根据之前的证明，最后一轮循环可以得到这些结论</p>
<p>j&lt;=i和q[l…i-1]&lt;=x,q[i]&gt;=x和q[j+1…r]&gt;=x,q[j]&lt;=x</p>
<p>所以，q[l…j-1]&lt;=x是显然成立的，</p>
<p>但quick_sort(q,j,r)中的q[j]却是q[j]&lt;=x，这不符合快排的要求</p>
<p>另外一点，注意quick_sort(q,l,j-1),quick_sort(q,j,r)可能会造成无限划分</p>
<p>当x选为q[l]时会造成无限划分，报错为MLE，</p>
<p>如果手动改为x=q[r]，可以避免无限划分</p>
<p>但是上面所说的q[j]&lt;=x的问题依然不能解决，这会造成WA WrongAnswer</p>
</li>
<li>
<p><strong>j的取值范围为[l…r-1]</strong></p>
<p>假设j最终的值为r，说明只有一轮循环（两轮的话j至少会自减两次）</p>
<p>说明q[r]&lt;=x因为要跳出do−while循环因为要跳出do-while循环</p>
<p>说明i&gt;=r（while循环的结束条件），i为r或r+1必不可能成立必不可能成立</p>
<p>说明i自增到了r，说明q[r]&gt;=x和q[l…r-1]&lt;x，</p>
<p>得出q[r]=x和q[l…r-1]&lt;x的结论，但这与x=q[l+r&gt;&gt;1]矛盾</p>
<p>反证法得出j&lt;r</p>
<p>假设j可能小于l说明q[l…r]&gt;x，矛盾</p>
<p>反证法得出j&gt;=l</p>
</li>
</ol>
<p><strong>所以j的取值范围为[l…r-1]，不会造成无限划分和数组越界。</strong></p>
</blockquote>
<h1 id="六-选择排序selection-sort"><a class="markdownIt-Anchor" href="#六-选择排序selection-sort"></a> 六、选择排序（Selection Sort）</h1>
<h2 id="原理-6"><a class="markdownIt-Anchor" href="#原理-6"></a> 原理</h2>
<p>假设排序表为L[1…n]，第i趟排序即从L[i…n]中选择关键字最小的元素与L(i)交换，每一趟排序可以确定一个元素的最终位置，这样经过n-1趟排序就可使得整个排序表有序</p>
<h2 id="步骤-6"><a class="markdownIt-Anchor" href="#步骤-6"></a> 步骤</h2>
<p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ol>
<li>初始状态：无序区为R[1…n]，有序区为空</li>
<li>第i趟排序（i=1,2,3…n-1）开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n)。该趟排序从当前无序区中选出关键字最小的记录R[k]，将它与无序区的第1个记录R交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区</li>
<li>n-1趟结束，数组有序化了</li>
</ol>
<h2 id="动画演示-6"><a class="markdownIt-Anchor" href="#动画演示-6"></a> 动画演示</h2>
<p><img  
                       lazyload
                       alt="image"
                       data-src="%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif"
                        alt="选择排序" 
                 ></p>
<h2 id="代码实现-6"><a class="markdownIt-Anchor" href="#代码实现-6"></a> 代码实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(ElemType A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;<span class="comment">//一共进行n-1趟</span></span><br><span class="line">        <span class="type">int</span> min=i;<span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;<span class="comment">//在A[i...n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[min])&#123;</span><br><span class="line">                min=j;<span class="comment">//更新最小元素位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min!=i)&#123;</span><br><span class="line">            swap(A[i],A[min]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n<sup>2</sup>)</li>
<li>空间复杂度：O(1)</li>
<li>不稳定</li>
<li>适用性：适用于顺序存储和链式存储的线性表，以及关键字较少的情况</li>
</ul>
<h1 id="七-堆排序heap-sort"><a class="markdownIt-Anchor" href="#七-堆排序heap-sort"></a> 七、堆排序（Heap Sort）</h1>
<h2 id="原理-7"><a class="markdownIt-Anchor" href="#原理-7"></a> 原理</h2>
<p>堆是一种特殊的树形数据结构，即完全二叉树。堆分为大根堆和小根堆，大根堆为根节点的值大于两个子节点的值；小根堆为根节点的值小于两个子节点的值，同时根节点的两个子树也分别是一个堆</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="%E5%A0%86%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86.png"
                        alt="堆排序原理" 
                 ></p>
<p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：子结点的键值或索引总是小于（或者大于）它的父节点</p>
<p>首先将存放在L[1…n]中的n个元素建成初始堆，因为堆本身的特点（以大顶堆为例），所以堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继保大该堆的性质，再输出堆顶元素。如此重复，直到堆中仅剩一个元素为止</p>
<h2 id="步骤-7"><a class="markdownIt-Anchor" href="#步骤-7"></a> 步骤</h2>
<ol>
<li>构建堆：将待排序序列构建成一个堆H[0…n-1]，从最后一个非叶子结点开始，从左至右，从下至上进行调整。根据升序或降序需求选择大顶堆或小顶堆，此时的堆顶元素，为最大或者最小元素</li>
<li>把堆顶元素和堆尾元素互换，调整堆，重新使堆有序，此时堆顶元素为第二大元素</li>
<li>重复以上步骤，直到堆变空</li>
</ol>
<h2 id="动画演示-7"><a class="markdownIt-Anchor" href="#动画演示-7"></a> 动画演示</h2>
<p><img  
                       lazyload
                       alt="image"
                       data-src="%E5%A0%86%E6%8E%92%E5%BA%8F.gif"
                        alt="堆排序" 
                 ></p>
<h2 id="代码实现-7"><a class="markdownIt-Anchor" href="#代码实现-7"></a> 代码实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以建立大根堆为例</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(ElemType A[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)&#123;<span class="comment">//从i=[n/2]~1,反复调整堆</span></span><br><span class="line">        HeadAdjust(A,i,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(ElemType A[],<span class="type">int</span> k,<span class="type">int</span> len)</span>&#123;<span class="comment">//对以k为根的子树进行调整</span></span><br><span class="line">    A[<span class="number">0</span>]=A[k];<span class="comment">//A[0]暂存子树的根结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*k;i&lt;=len;i*=<span class="number">2</span>)&#123;<span class="comment">//沿key较大的子结点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len&amp;&amp;A[i]&lt;A[i+<span class="number">1</span>])&#123;</span><br><span class="line">            i++;<span class="comment">//取key较大的子结点的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>]&gt;A[i])&#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//筛选结束</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            A[k]=A[i];<span class="comment">//将A[i]调整到双亲结点上</span></span><br><span class="line">            k=i;<span class="comment">//修改i值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k]=A[<span class="number">0</span>];<span class="comment">//被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(ElemType A[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    BuildMaxHeap(A,len);<span class="comment">//初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;<span class="number">1</span>;i--)&#123;<span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        Swap(A[i],A[<span class="number">1</span>]);<span class="comment">//输出堆顶元素（和堆底元素交换）</span></span><br><span class="line">        HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>);<span class="comment">//把剩余的i-1个元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(nlog<sub>2</sub>n)</li>
<li>空间复杂度：O(1)</li>
<li>不稳定</li>
<li>适用性：适用于顺序存储的线性表</li>
</ul>
<h1 id="八-归并排序merge-sort"><a class="markdownIt-Anchor" href="#八-归并排序merge-sort"></a> 八、归并排序（Merge Sort）</h1>
<h2 id="原理-8"><a class="markdownIt-Anchor" href="#原理-8"></a> 原理</h2>
<p>该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2路归并</p>
<blockquote>
<p>对N个元素进行k路归并排序时，排序趟数m满足k<sup>m</sup>=N，从而m=log<sub>k</sub>N，考虑到m为整数，因此</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo>=</mo><mrow><mo fence="true">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>k</mi></msub><mi>N</mi><mo fence="true">⌉</mo></mrow></mrow><annotation encoding="application/x-tex">m=\left \lceil log_kN \right \rceil
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">⌈</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose delimcenter" style="top:0em;">⌉</span></span></span></span></span></span></p>
</blockquote>
<h2 id="步骤-8"><a class="markdownIt-Anchor" href="#步骤-8"></a> 步骤</h2>
<ol>
<li>把长度为n的输入序列分成两个长度为n/2的子序列</li>
<li>对这两个子序列分别采用归并排序</li>
<li>将两个排序好的子序列合并成一个最终的排序序列</li>
</ol>
<h2 id="动画演示-8"><a class="markdownIt-Anchor" href="#动画演示-8"></a> 动画演示</h2>
<p><img  
                       lazyload
                       alt="image"
                       data-src="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif"
                        alt="归并排序" 
                 ></p>
<h2 id="代码实现-8"><a class="markdownIt-Anchor" href="#代码实现-8"></a> 代码实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ElemType *B=(ElemType *)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="keyword">sizeof</span>(ElemType));<span class="comment">//辅助数组B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//表A的两段A[low...mid]和A[mid+1...high]各自有序，将它们合并成一个有序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k=low;k&lt;=high;k++)&#123;</span><br><span class="line">        B[k]=A[k];<span class="comment">//将A中所有元素复制到B中</span></span><br><span class="line">        <span class="keyword">for</span>(i=low;j=mid+<span class="number">1</span>;k=i;i&lt;mid&amp;&amp;j&lt;=high;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(B[i]&lt;=B[j])&#123;<span class="comment">//比较B的两个段中的元素</span></span><br><span class="line">                A[k]=B[i++];<span class="comment">//将较小值复制到A中</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                A[k]=B[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;<span class="comment">//两个while循环只有一个会执行</span></span><br><span class="line">            A[k++]=B[i++];<span class="comment">//若第一个表未检测完，复制</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=high)&#123;</span><br><span class="line">            A[k++]=B[j++];<span class="comment">//若第二个表未检测完，复制</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;<span class="comment">//从中间划分两个子序列</span></span><br><span class="line">        MergeSort(A,low,mid);<span class="comment">//对左侧子序列进行递归排序</span></span><br><span class="line">        MergeSort(A,mid+<span class="number">1</span>,high);<span class="comment">//对右侧子序列进行递归排序</span></span><br><span class="line">        Merge(A,low,mid,high);<span class="comment">//归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(nlog<sub>2</sub>n)</li>
<li>空间复杂度：O(n)</li>
<li>稳定</li>
<li>适用性：适用于顺序存储和链式存储的线性表</li>
</ul>
<h1 id="九-基数排序radix-sort"><a class="markdownIt-Anchor" href="#九-基数排序radix-sort"></a> 九、基数排序（Radix Sort）</h1>
<h2 id="原理-9"><a class="markdownIt-Anchor" href="#原理-9"></a> 原理</h2>
<p>基数排序是一种很特别的排序算法，它不依赖于元素间的比较，而基于关键字各位的大小进行排序。基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法</p>
<p>假设长度为n的线性表中，每个结点a<sub>j</sub>的关键字由d个分量（k<sup>d-1</sup><sub>j</sub>,k<sup>d-2</sup><sub>j</sub>,…,k<sup>1</sup><sub>j</sub>,k<sup>0</sup><sub>j</sub>）组成，满足0≤k<sup>i</sup><sub>j</sub>≤r-1（0≤j&lt;n,0≤i≤d-1）。其中k<sup>d-1</sup><sub>j</sub>为最高位关键字，k为最低位关键字</p>
<p>为实现多关键字排序，通常有两种方法：第一种是最高位优先（MSD）法，按关键字位权重递减依次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列；第二种是最低位优先（LSD）法，按关键字位权重递增依次进行排序，最后形成一个有序序列</p>
<h2 id="步骤-9"><a class="markdownIt-Anchor" href="#步骤-9"></a> 步骤</h2>
<p>以下描述以基数r进行的最低位优先基数排序过程。算法使用r个队列Q<sub>0</sub>,Q<sub>1</sub>,…,Q<sub>r-1</sub>。对每一位i=0,1,…,d-1，依次执行一次分配和收集操作（每轮本质上是一次稳定的排序）：</p>
<ol>
<li>分配：初始化所有队列为空，然后依次扫描线性表中的每个结点a<sub>j</sub>（j=0,1,…,n-1），若a<sub>j</sub>在当前位上的关键字值为k，则将其加入队列Q<sub>k</sub></li>
<li>收集：按Q<sub>0</sub>到Q<sub>r-1</sub>的顺序，依次将各队列中的结点连接起来，形成新的线性表</li>
</ol>
<h2 id="动画演示-9"><a class="markdownIt-Anchor" href="#动画演示-9"></a> 动画演示</h2>
<p><img  
                       lazyload
                       alt="image"
                       data-src="%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif"
                        alt="基数排序" 
                 ></p>
<h2 id="代码实现-9"><a class="markdownIt-Anchor" href="#代码实现-9"></a> 代码实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxbit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxv = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (maxv &lt; a[i])</span><br><span class="line">            maxv = a[i];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (maxv &gt;= <span class="number">10</span>) maxv /= <span class="number">10</span>, cnt ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RadixSort</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = maxbit();</span><br><span class="line">    <span class="type">int</span> radix = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j ++ ) count[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = (a[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            count[k] ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j ++ ) count[j] += count[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = (a[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            temp[count[k]<span class="number">-1</span>] = a[j];</span><br><span class="line">            count[k] -- ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ ) a[j] = temp[j];</span><br><span class="line">        radix *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(d(n+r))</li>
<li>空间复杂度：O(r)</li>
<li>稳定</li>
<li>适用性：适用于顺序存储和链式存储的线性表，链式结构尤其适合</li>
</ul>
<h1 id="十-计数排序counting-sort"><a class="markdownIt-Anchor" href="#十-计数排序counting-sort"></a> 十、计数排序（Counting Sort）</h1>
<h2 id="原理-10"><a class="markdownIt-Anchor" href="#原理-10"></a> 原理</h2>
<p>核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数</p>
<p>计数排序是一种用<strong>空间换时间</strong>的排序。对每个待排序元素x，统计小于x的元素个数，从而确定x在有序序列中的位置。当存在重复元素时，需对算法稍做调整，以保证排序的稳定性</p>
<h2 id="步骤-10"><a class="markdownIt-Anchor" href="#步骤-10"></a> 步骤</h2>
<ol>
<li>找出待排序的数组中最大和最小的元素</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C<sub>i</sub>项，每放一个元素就将C<sub>i</sub>减去1</li>
</ol>
<h2 id="动画演示-10"><a class="markdownIt-Anchor" href="#动画演示-10"></a> 动画演示</h2>
<p><img  
                       lazyload
                       alt="image"
                       data-src="%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif"
                        alt="计数排序" 
                 ></p>
<h2 id="代码实现-10"><a class="markdownIt-Anchor" href="#代码实现-10"></a> 代码实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CountSort</span><span class="params">(ElemType A[],ElemType B[],<span class="type">int</span> m,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,C[k];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        C[i]=<span class="number">0</span>;<span class="comment">//初始化计数数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//遍历输入数组，统计每个元素出现的次数</span></span><br><span class="line">        C[A[i]]=C[A[i]]+<span class="number">1</span>;<span class="comment">//C[A[i]]保存的是等于A[i]的元素个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">        C[i]=C[i]+C[i<span class="number">-1</span>];<span class="comment">//C[x]保存的是小于或等于x的元素总数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//从后往前遍历输入数组</span></span><br><span class="line">        B[C[A[i]]<span class="number">-1</span>]=A[i];<span class="comment">//将元素A[i]放置到输出数组B[]的正确位置</span></span><br><span class="line">        C[A[i]]=C[A[i]]<span class="number">-1</span>;<span class="comment">//更新计数数组，确保相同元素的相对顺序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n+k)</li>
<li>空间复杂度：O(n+k)</li>
<li>稳定</li>
<li>适用性：适用于顺序存储的线性表；序列中的元素是整数且元素范围（0~k-1）不能太大，否则会造成辅助空间的浪费</li>
</ul>
<h1 id="十一-桶排序bucket-sort"><a class="markdownIt-Anchor" href="#十一-桶排序bucket-sort"></a> 十一、桶排序（Bucket Sort）</h1>
<h2 id="原理-11"><a class="markdownIt-Anchor" href="#原理-11"></a> 原理</h2>
<p>遍历原始序列确定最大值maxval和最小值minval，并确定桶的个数n，然后将待排序集合中处于同一个值域的元素存入同一个桶中，在桶内使用各种现有的算法进行排序；最后按照从小到大的顺序依次收集桶中的每一个元素，即为最终结果</p>
<h2 id="步骤-11"><a class="markdownIt-Anchor" href="#步骤-11"></a> 步骤</h2>
<ol>
<li>设置一个定量的数组当作空桶</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去</li>
<li>对每个不是空的桶进行排序</li>
<li>从不是空的桶里把排好序的数据拼接起来</li>
</ol>
<p>桶排序是一种用<strong>空间换时间</strong>的排序。桶的个数和大小都是我们人为设置的，而每个桶又要避免空桶的情况，所以我们在使用桶排序的时候即需要对待排序数列要求偏均匀，又要要求桶的设计兼顾效率和空间；数要相对均匀分布，桶的个数也要合理设计。在设计桶排序时，需要知道输入数据的上界和下界</p>
<h2 id="动画演示-11"><a class="markdownIt-Anchor" href="#动画演示-11"></a> 动画演示</h2>
<p><img  
                       lazyload
                       alt="image"
                       data-src="%E6%A1%B6%E6%8E%92%E5%BA%8F.gif"
                        alt="桶排序" 
                 ></p>
<h2 id="代码实现-11"><a class="markdownIt-Anchor" href="#代码实现-11"></a> 代码实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//桶排序 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BucketSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> minval = a[<span class="number">0</span>], maxval = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;<span class="comment">//寻找原序列数组元素的最大值和最小值 </span></span><br><span class="line">        minval = min(minval, a[i]);</span><br><span class="line">        maxval = max(maxval, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bnum = <span class="number">10</span>;<span class="comment">//桶中元素个数 </span></span><br><span class="line">    <span class="type">int</span> m = (maxval - minval) / bnum + <span class="number">1</span>;<span class="comment">//桶的个数 </span></span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &gt; bucket(m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收集,将元素入相应的桶中. 减偏移量是为了将元素映射到更小的区间内,省内存 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) bucket[(a[i] - minval) / bnum].push_back(a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将桶内元素排序 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) sort(bucket.begin(), bucket.end());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收集, 将各个桶中的元素收集到一起 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; bucket[i].size(); j ++)&#123;</span><br><span class="line">            data[k ++] = bucket[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n+k)</li>
<li>空间复杂度：O(n+k)</li>
<li>稳定</li>
<li>适用性：适用于顺序存储的线性表</li>
</ul>

                    
                </div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                            <ul class="post-tags-box border-box">
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/Summary/">Summary</a>
                                    </li>
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/LeetCode/">LeetCode</a>
                                    </li>
                                
                            </ul>
                        
                    </div>
                    <div>
                        
                            <div class="post-share-container border-box">
    <ul class="share-list-wrap border-box">
        <li class="qq share-item border-box flex-center tooltip"
            data-tooltip-content="分享到 QQ"
        >
            <i class="fa-brands fa-qq"></i>
        </li>
        <li class="wechat share-item border-box flex-center tooltip tooltip-img"
            data-tooltip-content="分享到微信"
            data-tooltip-img-tip="微信扫一扫"
            data-tooltip-img-style="background-color: #fff; top: -10px; padding: 0.6rem 0.6rem 0.1rem 0.6rem;"
        >
            <i class="fa-brands fa-weixin"></i>
        </li>
        <li class="weibo share-item border-box flex-center tooltip"
            data-tooltip-content="分享到微博"
        >
            <i class="fa-brands fa-weibo"></i>
        </li>
    </ul>
</div>

                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/2024/03/10/04CDN%E7%BB%95%E8%BF%87/"
                                   title="04CDN绕过"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">04CDN绕过</span>
                                        <span class="post-nav-item">上一篇</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/2024/03/01/03%E4%BF%A1%E6%81%AF%E6%89%93%E7%82%B9/"
                                   title="03信息打点"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">03信息打点</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    


    <div class="comments-container border-box">
        <div id="comments-anchor" class="comment-area-title border-box">
            <i class="fas fa-comments"></i>&nbsp;评论
        </div>
        <div class="comment-plugin-fail border-box">
    <span class="fail-tip">评论插件加载失败</span>
    <button class="reload keep-button">点击重新加载</button>
</div>
<div class="comment-plugin-loading flex-center border-box">
    <i class="loading-icon fa-solid fa-spinner fa-spin"></i>
    <span class="load-tip">正在加载评论插件</span>
</div>
<script data-pjax>
  window.KeepCommentPlugin = {}
  window.KeepCommentPlugin.hideLoading = () => {
    const cplDom = document.querySelector('.comments-container .comment-plugin-loading')
    cplDom.style.display = 'none'
  }
  window.KeepCommentPlugin.loadFailHandle = () => {
    window.KeepCommentPlugin.hideLoading()
    const cpfDom = document.querySelector('.comments-container .comment-plugin-fail')
    cpfDom.style.display = 'flex'
    cpfDom.querySelector('.reload').addEventListener('click', () => {
      window.location.reload()
    })
  }
</script>

        
            

    <div class="waline-comment-container">
        <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@waline/client@v3.3.2/dist/waline.css"/>
        <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@waline/client@v3.3.2/dist/waline-meta.css"/>
        <div id="waline-comment"></div>
        <script data-pjax>
          window.KeepCommentPlugin.walineOptions = JSON.parse('{&#34;login&#34;:&#34;force&#34;,&#34;copyright&#34;:false}'.replace(/&#34;/g, '"'))
          window.KeepCommentPlugin.walineOptions.el = '#waline-comment'
          window.KeepCommentPlugin.walineOptions.comment = '.post-comments-count'
          window.KeepCommentPlugin.walineOptions.serverURL = 'waline-for-blog-psi.vercel.app'
          window.KeepCommentPlugin.walineOptions.lang = 'zh-CN' || 'zh-CN'
          window.KeepCommentPlugin.walineOptions.reaction = 'false' === 'true'
        </script>

        

        
            <script data-pjax
                    async
                    type="module"
            >
              import { init } from '//cdn.jsdelivr.net/npm/@waline/client@v3.3.2/dist/waline.js'
              window.KeepCommentPlugin.initWaline = () => {
                if (init) {
                  init(window.KeepCommentPlugin.walineOptions)
                  window.KeepCommentPlugin.hideLoading()
                } else {
                  setTimeout(() => {
                    window.KeepCommentPlugin.initWaline()
                  }, 1000)
                }
              }

              if ('true' === 'true') {
                setTimeout(() => {
                  window.KeepCommentPlugin.initWaline()
                }, 1200)
              } else {
                window.addEventListener('DOMContentLoaded', window.KeepCommentPlugin.initWaline)
              }
            </script>
        
    </div>


        
    </div>





                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-text"> 经典排序算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%84%E4%B8%AA%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text"> 各个算法时间复杂度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8Fdirect-insertion-sort"><span class="nav-text"> 一、直接插入排序（Direct Insertion Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8Fbinary-insertion-sort"><span class="nav-text"> 二、折半插入排序（Binary Insertion Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-2"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-2"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-2"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8Fshell-sort"><span class="nav-text"> 三、希尔排序（Shell Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-3"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-3"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-3"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8Fbubble-sort"><span class="nav-text"> 四、冒泡排序（Bubble Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-4"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-4"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-4"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fquick-sort"><span class="nav-text"> 五、快速排序（Quick Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-5"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-5"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-5"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8Fselection-sort"><span class="nav-text"> 六、选择排序（Selection Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-6"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-6"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-6"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-6"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83-%E5%A0%86%E6%8E%92%E5%BA%8Fheap-sort"><span class="nav-text"> 七、堆排序（Heap Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-7"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-7"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-7"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-7"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8Fmerge-sort"><span class="nav-text"> 八、归并排序（Merge Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-8"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-8"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-8"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-8"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8Fradix-sort"><span class="nav-text"> 九、基数排序（Radix Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-9"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-9"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-9"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-9"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8Fcounting-sort"><span class="nav-text"> 十、计数排序（Counting Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-10"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-10"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-10"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-10"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%80-%E6%A1%B6%E6%8E%92%E5%BA%8Fbucket-sort"><span class="nav-text"> 十一、桶排序（Bucket Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-11"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-11"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-11"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-11"><span class="nav-text"> 代码实现</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="copyright-info info-item">
    &copy;&nbsp;<span>2022</span>&nbsp;-&nbsp;2026
    
            &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">Jackie</a>
        
    </div>

    <div class="theme-info info-item">
        由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
    </div>

    

    
        <div class="count-info info-item">
            
                <span class="count-item border-box word">
                    <span class="item-type border-box">总字数</span>
                    <span class="item-value border-box word">164.3k</span>
                </span>
            

            

            
        </div>
    

    
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="post-tools-list border-box">
        <!-- PC encrypt again -->
        

        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        
            <li class="tools-item flex-center go-to-comments">
                <i class="fas fa-comment"></i>
                <span class="post-comments-count"></span>
            </li>
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <!-- toggle mode -->
        
            <li class="tools-item tool-toggle-theme-mode flex-center">
                <i class="fas fa-moon"></i>
            </li>
        

        <!-- rss -->
        

        <!-- to bottom -->
        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        
            <li class="tools-item go-to-comments-tablet flex-center">
                <i class="fas fa-comment"></i>
            </li>
        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-text"> 经典排序算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%84%E4%B8%AA%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text"> 各个算法时间复杂度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8Fdirect-insertion-sort"><span class="nav-text"> 一、直接插入排序（Direct Insertion Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8Fbinary-insertion-sort"><span class="nav-text"> 二、折半插入排序（Binary Insertion Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-2"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-2"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-2"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8Fshell-sort"><span class="nav-text"> 三、希尔排序（Shell Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-3"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-3"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-3"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8Fbubble-sort"><span class="nav-text"> 四、冒泡排序（Bubble Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-4"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-4"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-4"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fquick-sort"><span class="nav-text"> 五、快速排序（Quick Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-5"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-5"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-5"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8Fselection-sort"><span class="nav-text"> 六、选择排序（Selection Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-6"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-6"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-6"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-6"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83-%E5%A0%86%E6%8E%92%E5%BA%8Fheap-sort"><span class="nav-text"> 七、堆排序（Heap Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-7"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-7"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-7"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-7"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8Fmerge-sort"><span class="nav-text"> 八、归并排序（Merge Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-8"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-8"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-8"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-8"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8Fradix-sort"><span class="nav-text"> 九、基数排序（Radix Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-9"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-9"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-9"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-9"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8Fcounting-sort"><span class="nav-text"> 十、计数排序（Counting Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-10"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-10"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-10"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-10"><span class="nav-text"> 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%80-%E6%A1%B6%E6%8E%92%E5%BA%8Fbucket-sort"><span class="nav-text"> 十一、桶排序（Bucket Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-11"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-11"><span class="nav-text"> 步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-11"><span class="nav-text"> 动画演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-11"><span class="nav-text"> 代码实现</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>





<!-- common js -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local search -->

    
<script src="/js/local-search.js"></script>



<!-- lazyload -->

    
<script src="/js/lazyload.js"></script>



<div class="pjax">
    <!-- home page -->
    

    <!-- post page -->
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        
            
<script src="/js/post/toc.js"></script>

        

        <!-- copyright-info -->
        

        <!-- share -->
        
            
<script src="/js/post/share.js"></script>

        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->

    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart()
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd()
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'))
            KEEP.initExecute()
        });
    });
</script>




    
        
    

</body>
</html>
